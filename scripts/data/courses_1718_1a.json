{"Databases": {"supervisions": 3, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "\n\n\n<a name=\"SECTION03023100000000000000\">\nAims</a>\n\n\nThe database world is currently undergoing swift \nand dramatic transformations largely driven by \nInternet-oriented applications and services. \nToday many more options are available to database\napplication developers than in the past and so it \nis becoming increasingly difficult to sort fact \nfrom fiction. \nThe course attempts to cut through the fog with a \npractical approach that emphasises engineering \ntradeoffs that underpin these recent developments\nand also guide our selection of \u201cthe right \ntool for the job.\u201d \n\n\nThis course covers three approaches. \nFirst, the traditional mainstay of the database industry -- \nthe relational approach -- \nis described with emphasis on eliminating logical redundancy in data. \nThen two representatives of recent trends \nare presented -- graph-oriented and document-oriented databases. \nThe lectures are tightly integrated with the associated \npractical sessions where students gain hands-on experience \nwith all three of these approaches. \n\n\n<a name=\"SECTION03023200000000000000\">\nLectures</a>\n\n\n\n<li><b>Introduction.</b>\nWhat is a database system? \nWhat is a data model? \nA central tradeoff in the choice of data representation: \noptimise for ease of updating or for fast query response. \nOn-Line Transaction Processing (OLTP) \n<span class=\"textit\">versus</span> \nOn-line Analytical Processing (OLAP). \nApplication independent <span class=\"textit\">versus</span> application specific data representations. \n[1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>Conceptual modeling</b>\nThe Entity-Relationship (ER) approach as an implementation-independent \ntechnique for modeling data. \n[1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>The relational model</b>\nImplementing ER models with relational tables. \nRelational algebra and SQL. \nUpdate anomalies caused by logical redundancy. \nMinimise logical redundancy with normalised data representation. \nFunctional dependencies (FDs) as a formal means of investigating redundancy. \nWhat is transitive closure? \nWhy SQL struggles with transitive closure. \n[2\u00a0lectures]\n\n<p>\n</p></li>\n<li><b>The graph-oriented model</b>\nThe NoSQL movement. \nImplementing ER models in a graph-oriented database. \nGraph databases: optimised for computing transitive closure. \nPath-oriented queries. \n[2\u00a0lectures]\n\n<p>\n</p></li>\n<li><b>The document-oriented model</b>\nSemi-structured data (XML, JSON). \nDocument-oriented databases. \nEmbracing data redundancy: representing data \nfor fast, application-specific, access. \nThe CAP principle for distributed database \nrelating Consistency, Availability, and Partition Tolerance. \nIntegration of relational and document-oriented approaches. \n[2\u00a0lectures]\n</li>\n\n\n<a name=\"SECTION03023300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios\n\n<p>\n</p></li>\n<li>know how to convert entity-relationship diagrams to relational- \nand graph-oriented implementations \n\n<p>\n</p></li>\n<li>understand the fundamental tradeoff between the ease of updating data \nand the response time of complex queries \n\n<p>\n</p></li>\n<li>understand that no single data architecture can be used to meet all \ndata management requirements \n\n<p>\n</p></li>\n<li>be familiar with recent trends in the database area.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION03023400000000000000\">\nRecommended reading</a>\n\n\nUllman, J. &amp; Widom, J. (1997) <em>A first course in database systems</em>. Prentice Hall.\n<br/>\n\n\n\n", "course_name": "Databases", "course_code": "Databases", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/Databases", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "\n\n\n<a name=\"SECTION02023100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02023200000000000000\">\nLectures</a>\n\n\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p>\n</p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\nQuine-McCluskey method.\n\n<p>\n</p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p>\n</p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p>\n</p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p>\n</p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p>\n</p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p>\n</p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n  Elimination of redundant states.\n\n<p>\n</p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p>\n</p></li>\n<li><b>Electronics, Devices and Circuits.</b> Current and voltage, resistance, basic circuit theory, the potential divider. Solving non-linear circuits. Materials, semiconductors and the p-n junction, i.e., the diode. n and p channel MOSFETs and n-MOSFET logic, e.g., n-MOSFET inverter. Switching speed and power consumption problems in n-MOSFET logic. CMOS logic. Logic families. Noise margin. Analogue interfacing and operational amplifiers.  [3\u00a0lectures]\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02023300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p>\n</p></li>\n<li>be able to design and minimise combinational logic;\n\n<p>\n</p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p>\n</p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p>\n</p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p>\n</p></li>\n<li>understand how to use MOSFETs to build digital logic circuits.\n\n<p>\n</p></li>\n<li>understand the effect of finite load capacitance on the performance of digital logic circuits.\n\n<p>\n</p></li>\n<li>understand basic analogue interfacing.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02023400000000000000\">\nRecommended reading</a>\n\n\n* Harris, D.M. &amp; Harris, S.L. (2013). <em>Digital design and computer architecture</em>. Morgan Kaufmann (2nd ed.). The first edition is still relevant.\n<br/>\nKatz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>\nHayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\n\nBooks for reference:\n\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>\nWeste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>\nMead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>\nCrowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>\nGibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/DigElec", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMath": {"supervisions": 7, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "\n\n\n<a name=\"SECTION02024100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02024200000000000000\">\nLectures</a>\n\n\n\n<li><b>Proof [5\u00a0lectures].</b>\n<p>\nProofs in practice and mathematical jargon. Mathematical statements:\n  implication, bi-implication, universal quantification, conjunction,\n  existential quantification, disjunction, negation.  Logical deduction: proof\n  strategies and patterns, scratch work, logical equivalences.  Proof by\n  contradiction.  Divisibility and congruences.  Fermat\u2019s Little Theorem.\n\n</p><p>\n</p></li>\n<li><b>Numbers [5\u00a0lectures].</b>\n<p>\nNumber systems: natural numbers, integers, rationals, modular integers.  The\n  Division Theorem and Algorithm.  Modular arithmetic.  Sets: membership and\n  comprehension.  The greatest common divisor, and Euclid\u2019s Algorithm and\n  Theorem. The Extended Euclid\u2019s Algorithm and multiplicative inverses in\n  modular arithmetic.  The Diffie-Hellman cryptographic method.  Mathematical\n  induction: Binomial Theorem, Pascal\u2019s Triangle, Fundamental Theorem of\n  Arithmetic, Euclid\u2019s infinity of primes.\n\n</p><p>\n</p></li>\n<li><b>Sets [9\u00a0lectures].</b>\n<p>\nExtensionality Axiom: subsets and supersets.  Separation Principle:\n  Russell\u2019s Paradox, the empty set.  Powerset Axiom: the powerset Boolean\n  algebra, Venn and Hasse diagrams.  Pairing Axiom: singletons, ordered pairs,\n  products.  Union axiom: big unions, big intersections, disjoint unions.\n  Relations: composition, matrices, directed graphs, preorders and partial\n  orders.  Partial and (total) functions.  Bijections: sections and\n  retractions.  \n  Equivalence relations and set partitions. Calculus of bijections: characteristic (or indicator) functions.  Finite\n  cardinality and counting.  Infinity axiom.  \n  Surjections. \nEnumerable and countable sets.  Axiom of choice.  \n  Injections. \nImages:  direct and inverse images.  Replacement Axiom: set-indexed\n  constructions.  Set cardinality: Cantor-Schoeder-Bernstein Theorem,\n  unbounded cardinality, diagonalisation, fixed-points.  Foundation Axiom.\n\n</p><p>\n</p></li>\n<li><b>Formal languages and automata [5\u00a0lectures].</b>\n<p>\nIntroduction to inductive definitions using rules and proof by rule\n  induction. Abstract syntax trees.\n  \n\n</p><p>\nRegular expressions and their algebra.  \n  \n\n</p><p>\nFinite automata and regular languages: Kleene\u2019s theorem and the Pumping\n  Lemma.\n  \n</p></li>\n\n\n<br/>\n<a name=\"SECTION02024300000000000000\">\nObjectives</a>\n\n\nOn completing the course, students should be able to\n\n\n\n<li>prove and disprove mathematical statements using a variety of\n  techniques; \n\n<p>\n</p></li>\n<li>apply the mathematical principle of induction;\n\n<p>\n</p></li>\n<li>know the basics of modular arithmetic and appreciate its role in\n  \ncryptography; \n\n<p>\n</p></li>\n<li>understand and use the language of set theory in applications to\n  computer science;\n\n<p>\n</p></li>\n<li>define sets inductively using rules and prove properties about them; \n\n<p>\n</p></li>\n<li>convert between regular expressions and finite automata; \n\n<p>\n</p></li>\n<li>use the Pumping Lemma to prove that a language is not regular.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02024400000000000000\">\nRecommended reading</a>\n\n\nBiggs, N.L. (2002). \n  <em>Discrete mathematics.</em> \n  Oxford University Press (Second Edition).\n<br/>\nDavenport, H. (2008).\n  <em>The higher arithmetic: an introduction to the theory of numbers.</em>\n  Cambridge University Press.\n<br/>\nHammack, R. (2013).\n  <em>Book of proof.</em>\n  Privately published (Second edition). Available at:\n<br/> <a href=\"http://www.people.vcu.edu/~rhammack/BookOfProof/index.html\" name=\"tex2html4\"><tt>http://www.people.vcu.edu/\u00a0rhammack/BookOfProof/index.html</tt></a>\n<br/>\nHouston, K. (2009).\n\n<em>How to think like a mathematician: a companion to undergraduate\n    mathematics.</em>\n  Cambridge University Press.\n<br/>\nKozen, D.C. (1997). \n  <em>Automata and computability</em>. \n  Springer.\n<br/>\nLehman, E.; Leighton, F.T.; Meyer, A.R. (2014).\n  <em>Mathematics for computer science.</em> \n  Available on-line.\n<br/>\nVelleman, D.J. (2006).\n  <em>How to prove it: a structured approach.</em>\n  Cambridge University Press (Second Edition).\n\n\n\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/DiscMath", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "\n\n\n<a name=\"SECTION02021100000000000000\">\nAims</a>\n\n\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using <span class=\"MATH\"><i>O</i></span>-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\n\nThe course will use a functional language (ML).  ML is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash and ML\u2019s unobtrusive type system captures many program faults\nbefore execution.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso introduce traditional (procedural) programming, such as\nassignments, arrays and references.\n\n\n<a name=\"SECTION02021200000000000000\">\nLectures</a>\n\n\n<li><b>Introduction to Programming.</b>\nThe role of abstraction and representation.  Introduction to integer and floating-point arithmetic.\nDeclaring functions. Decisions and booleans. Example: integer exponentiation.\n\n<p>\n</p></li>\n<li><b>Recursion and Efficiency.</b>\nExamples: Exponentiation and summing integers.  Overloading. Iteration <em>versus</em> recursion. \nExamples of growth rates.  Dominance and <span class=\"MATH\"><i>O</i></span>-Notation.  The costs\nof some representative functions.  Cost estimation.\n\n<p>\n</p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p>\n</p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p>\n</p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p>\n</p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p>\n</p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p>\n</p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying. \nThe \u201capply to all\u201d functional, <tt>map</tt>.  \n<span class=\"textit\">Examples</span>: matrix transpose and product.  \nThe predicate functionals <tt>filter</tt> and <tt>exists</tt>.\n\n<p>\n</p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in ML.\nApplications, for example Newton-Raphson square roots.\n\n<p>\n</p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p>\n</p></li>\n<li><b>Polynomial arithmetic.</b>\nAddition, multiplication of polynomials using ideas from sorting,\netc.\n\n<p>\n</p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not. Introduction to linked lists. \n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02021300000000000000\">\nObjectives</a>\n\n\nAt the end of the course, students should\n\n\n\n<li>be able to write simple ML programs;\n\n<p>\n</p></li>\n<li>understand the fundamentals of using a data structure to represent some mathematical abstraction;\n\n<p>\n</p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p>\n</p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p>\n</p></li>\n<li>understand binary search and binary search trees;\n\n<p>\n</p></li>\n<li>know how to use currying and higher-order functions;\n\n<p>\n</p></li>\n<li>understand how ML combines imperative and functional programming in a single language.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02021400000000000000\">\nRecommended reading</a>\n\n\n* Paulson, L.C. (1996). <em>ML for the working programmer</em>. Cambridge University Press (2nd\u00a0ed.).\n<br/>\n\nOkasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\n\nFor reference only:\n<br/>\nGansner, E.R. &amp; Reppy, J.H. (2004). <em>The Standard ML Basis Library</em>. Cambridge University Press. ISBN: 0521794781\n\n\n\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/FoundsCS", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n<li><a href=\"hardware_17.pdf\">Notes</a> for hardware practical classes</li>\n\n<a href=\"../../1617/HW/\">Last year\u2019s course materials</a> are still available.\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/HW", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Graphics": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION030210100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION030210200000000000000\">\nLectures</a>\n\n\n<li><b>Background.</b> What is an image? Resolution and quantisation. Storage of\nimages in memory. [1 lecture]\n\n<p>\n</p></li>\n<li><b>Rendering.</b> Perspective. Reflection of light from surfaces and shading.\nGeometric models. Ray tracing. [2 lectures]\n\n<p>\n</p></li>\n<li><b>Graphics pipeline.</b> Polygonal mesh models. Transformations using\nmatrices in 2D and 3D. Homogeneous coordinates. Projection: orthographic\nand perspective. [1 lecture]\n\n<p>\n</p></li>\n<li><b>Graphics hardware and modern OpenGL.</b> GPU rendering. GPU frameworks and APIs. Vertex processing.\nRasterisation. Fragment processing. Working with meshes and textures. Z-buffer. Double-buffering and frame synchronization. [3 lectures]\n\n<p>\n</p></li>\n<li><b>Colour</b>. Perception of colour. Colour spaces. [1 lecture]\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION030210300000000000000\">\nObjectives</a>\n\n\nBy the end of the course students should be able to:\n\n\n\n<li>understand and apply in practice basic concepts of ray-tracing: ray-object intersection, reflections, refraction, shadow rays, distributed ray-tracing, direct and indirect illumination;\n\n<p>\n</p></li>\n<li>describe and explain the following algorithms:  Gouraud and Phong shading, z-buffer, texture mapping, double buffering, mip-map, bump- and normal-mapping;\n\n<p>\n</p></li>\n<li>use matrices and homogeneous coordinates to represent and perform 2D and 3D transformations; understand and use 3D to 2D projection, the viewing volume, and 3D clipping;\n\n<p>\n</p></li>\n<li>implement OpenGL code for rendering of polygonal objects, control camera and lighting, work with vertex and fragment shaders;\n\n<p>\n</p></li>\n<li>describe a number of colour spaces and their relative merits.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION030210400000000000000\">\nRecommended reading</a>\n\n\n* Shirley, P. &amp; Marschner, S. (2009). <em>Fundamentals of Computer Graphics</em>. CRC Press (3rd ed.).\n<br/>\n\nFoley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>\n\nKessenich, J.M., Sellers, G. and  Shreiner, D (2016). <em>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.5 with SPIR-V</em>, [seventh edition and later]\n\n\n\n", "course_name": "Introduction to Graphics", "course_code": "Graphics", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/Graphics", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "ML": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n", "course_name": "ML Practical Classes", "course_code": "ML", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/ML", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html", "description": "\n\n\n<a name=\"SECTION02022100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02022200000000000000\">\nLecture syllabus</a>\n\n\n\n<li><b>Types, Objects and Classes</b> Moving from functional to\n  imperative. Functions, methods. Control flow. values, variables and\n  types. Primitive Types. Classes as custom types. Objects vs\n  Classes. Class definition, constructirs. Statioc data and methods.\n\n<p>\n</p></li>\n<li><b>Designing Classes</b> Identifying classes. UML class\n  diagrams. Modularity. Encapsulation/data\n  hiding. Immutability. Access modifiers. Parameterised types\n  (Generics).\n\n<p>\n</p></li>\n<li><b>Pointers, References and Memory</b> Pointers and\n  references. Reference types in Java. The call stack. The\n  heap. Iteration and recursion. Pass-by-value and\n  pass-by-reference.\n\n<p>\n</p></li>\n<li><b>Inheritance</b> Inheritance. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.\n\n<p>\n</p></li>\n<li><b>Polymorphism and Multiple Inheritance</b> Polymorphism in ML\n  and Java. Multiple inheritance. Interfaces in Java.  \n\n<p>\n</p></li>\n<li><b>Lifecycle of an Object</b> Constructors and\n  chaining. Destructors. Finalizers. Garbage Collection: reference\n  counting, tracing.\n\n<p>\n</p></li>\n<li><b>Java Collections and Object Comparison</b> Java Collection\n  interface. Key classes. Collections class. Iteration options and the\n  use of Iterator. Comparing primitives and objects. Operator\n  overloading.\n\n<p>\n</p></li>\n<li><b>Error Handling</b> Types of errors. Limitations of return\n  values. Deferred error handling. Exceptions. Custom\n  exceptions. Checked vs unchecked. Inappropriate use of\n  exceptions. Assertions.\n\n<p>\n</p></li>\n<li><b>Copying Objects</b>. Shallow and deep copies. Copy\n  constructors. Cloning in Java. Cloneable as a marker interface in\n  Java.\n\n<p>\n</p></li>\n<li><b>DesignLanguage evolution</b> Need for languages to\n   evolve. Generics in Java. Type erasure. Introduction to Java 8:\n   Lambda functions, functions as values, method references, streams.\n\n<p>\n</p></li>\n<li><b>Design Patterns</b> Introduction to design\n  patterns. Open-closed principle. Examples of Singleton, Decorator,\n  State, Composite, Strategy, Observer.  [2 lectures]\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02022300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>be familiar with the main features and limitations of the Java\n  language;\n\n<p>\n</p></li>\n<li>be able to write a Java program to solve a well specified problem;\n\n<p>\n</p></li>\n<li>understand the principles of OOP;\n\n<p>\n</p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p>\n</p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p>\n</p></li>\n<li>be familiar with common errors in Java and its associated\n    libraries;\n\n<p>\n</p></li>\n<li>understand a Java program written by someone else;\n\n<p>\n</p></li>\n<li>be able to debug and test Java programs;\n\n<p>\n</p></li>\n<li>be familiar with major parts of Java 8 SE libraries;\n\n<p>\n</p></li>\n<li>understand how to read Javadoc library documentation and reuse\n    library code.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02022400000000000000\">\nRecommended reading</a>\n\n\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>\nFlanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>\nFlanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>\nGamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>\nBloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/OOProg", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n", "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/Registratn", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "SciComp": {"supervisions": 0, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION02027100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02027200000000000000\">\nSyllabus</a>\n\n\n\n<li>Python notebooks.\nOverview of the Python programming language. Use of notebooks for scientific computing.\n\n<p>\n</p></li>\n<li>Numerical computation.\nWriting fast vectorized code in <tt>numpy</tt>. Optimization and fitting. Simulation.\n\n<p>\n</p></li>\n<li>Working with data.\nData import. Common ways to summarize and plot data, for univariate and multivariate analysis.\n</li>\n\n\n<a name=\"SECTION02027300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>be able to import data, plot it, and summarize it appropriately\n\n<p>\n</p></li>\n<li>be able to write fast vectorized code for scientific / data work\n</li>\n\n\n\n", "course_name": "Scientific Computing Practical Course", "course_code": "SciComp", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/SciComp", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Algorithms": {"supervisions": 7, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms.html", "description": "\n\n\n<a name=\"SECTION02031100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02031200000000000000\">\nLectures</a>\n\n\n<li><b>Sorting.</b>  Review of complexity and O-notation. Trivial\n  sorting algorithms of quadratic complexity. Review of merge sort and\n  quicksort, understanding their memory behaviour on statically\n  allocated arrays. Heapsort. Stability. Other sorting methods\n  including sorting in linear time. Median and order statistics.\n  [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9] [about 4 lectures] \n\n<p>\n</p></li>\n<li><b>Strategies for algorithm design.</b>\nDynamic programming, divide and conquer, greedy algorithms and other\nuseful paradigms.\n[Ref: CLRS3 chapters 4, 15, 16] [about 3 lectures] \n\n<p>\n</p></li>\n<li><b>Data structures.</b>  Primitive data structures. Abstract data\n  types. Pointers, stacks, queues, lists, trees. Binary search\n  trees. Red-black trees. B-trees. Hash tables. Priority queues and\n  heaps.  [Ref: CLRS3 chapters 6, 10, 11, 12, 13, 18] [about 5 lectures] \n\n<p>\n</p></li>\n<li><b>Graph algorithms.</b>  Graph representations. Breadth-first and\n  depth-first search. Topological sort. Minimum spanning tree. Kruskal\n  and Prim algorithms. Single-source shortest paths: Bellman-Ford and\n  Dijkstra algorithms.  All-pairs shortest paths: matrix\n  multiplication and Johnson\u2019s algorithms. Maximum flow:\n  Ford-Fulkerson method, Max-Flow Min-Cut Theorem. Matchings in bipartite graphs.  [Ref: CLRS3\n    chapters 22, 23, 24, 25, 26] [about 7 lectures]\n\n<p>\n</p></li>\n<li><b>Advanced data structures.</b>  Binomial heap. Amortized analysis:\n  aggregate analysis, potential method. Fibonacci heaps. Disjoint sets.\n  [Ref: CLRS3 chapters 17, 19, 20, 21] [about 4 lectures]\n\n<p>\n</p></li>\n<li><b>Geometric algorithms.</b>  Intersection of segments. Convex\n  hull: Graham\u2019s scan, Jarvis\u2019s march.  [Ref: CLRS3 chapter 33] [about\n    1 lecture]\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02031300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>have a thorough understanding of several classical algorithms\n  and data structures;\n\n<p>\n</p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p>\n</p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p>\n</p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02031400000000000000\">\nRecommended reading</a>\n\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein,\nC. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN\n978-0-262-53305-8\n<br/>\n\nSedgewick, R., Wayne, K. (2011). <em>Algorithms</em>. Addison-Wesley. ISBN\n978-0-321-57351-3.\n<br/>\n\nKleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.\n<br/>\n\nKnuth, D.A. (2011). <em>The Art of Computer\n  Programming</em>. Addison-Wesley. ISBN 978-0-321-75104-1.\n<br/>\n\n\n", "course_name": "Algorithms", "course_code": "Algorithms", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/Algorithms", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "MLRD": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MachineLearningandReal-worldData.html", "description": "\n\n\n<a name=\"SECTION03036100000000000000\">\nAims</a>\n\n\n<li>Statistical classification: Determining movie review\n  sentiment using Naive Bayes (7 sessions);\n</li>\n<li>Sequence Analysis: Hidden Markov Modelling and its application to a task from biology (predicting protein interactions with a cell membrane) (4 sessions);\n</li>\n<li>Analysis of social networks, including detection of\n  cliques and central nodes (5 sessions).\n</li>\n\n\n<br/>\n<a name=\"SECTION03036200000000000000\">\nSyllabus</a>\n\n\n\n<li><b>Topic One: Statistical Classification [7 sessions].</b>\n<br/>\nIntroduction to sentiment classification.\n<br/>\nNaive Bayes parameter estimation.\n<br/>\nStatistical laws of language.\n<br/>\nStatistical tests for classification tasks.\n<br/>\nCross-validation and test sets.\n<br/>\nUncertainty and human agreement.\n<br/>\n<p>\n</p></li>\n<li><b>Topic Two: Sequence Analysis [4 sessions].</b>\n<br/>\nHidden Markov Models (HMM) and HMM training.\n<br/>\nThe Viterbi algorithm.\n<br/>\nUsing an HMM in a biological application.\n<br/>\n<p>\n</p></li>\n<li><b>Topic Three: Social Networks [5 sessions].</b>\n<br/>\nProperties of networks: Degree, Diameter.\n<br/>\nBetweenness Centrality.\n<br/>\nClustering using betweenness centrality.\n<br/></li>\n\n\n<a name=\"SECTION03036300000000000000\">\nObjectives</a>\n\n\nBy the end of the course students should be able to:\n\n\n\n<li>understand and program two simple\nsupervised machine learning algorithms;\n</li>\n<li>use these algorithms in statistically valid experiments,\nincluding the design of baselines, evaluation\nmetrics, statistical testing of results, and provision against\novertraining;\n</li>\n<li>visualise the connectivity and centrality in large\nnetworks;\n</li>\n<li>use clustering (i.e., a type of unsupervised machine learning) for\ndetection of cliques in unstructured networks.\n</li>\n\n\n<a name=\"SECTION03036400000000000000\">\nRecommended reading</a>\n\n\nJurafsky, D. &amp; Martin, J. (2008). <i>Speech and language\nprocessing</i>. Prentice Hall.\n<br/>\n\nEasley, D. and Kleinberg, J. (2010). <i>Networks, crowds, and markets:\nreasoning about a highly connected world</i>. Cambridge University\nPress.\n\n\n\n", "course_name": "Machine Learning and Real-world Data", "course_code": "MLRD", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/MLRD", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OpSystems": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "\n\n\n<a name=\"SECTION02032100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02032200000000000000\">\nLectures</a>\n\n\n<li><b>Introduction to operating systems.</b> Abstract view of an operating system. Elementary computer architecture. OS evolution: multi-programming, time-sharing. [1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>Protection.</b> Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels. Virtual machines and containers. Subjects and objects. Authentication. Access matrix: ACLs and capabilities. Combined scheme. Covert channels. [1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>Processes.</b> Job/process concepts. Lifecycle. Process management. Inter-process communication. [1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>Scheduling.</b> Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p>\n</p></li>\n<li><b>Memory management.</b> Processes in memory. Logical addresses. Partitions: static <em>versus</em> dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes. [3\u00a0lectures]\n\n<p>\n</p></li>\n<li><b>I/O subsystem.</b> General structure. Polled mode <em>versus</em> interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking <em>versus</em> non-blocking I/O. Other issues: caching, scheduling, spooling, performance. [1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>File management.</b> File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control. [1\u00a0lecture]\n\n<p>\n</p></li>\n<li><b>Unix case study.</b> History. General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection, pipes, signals. Character and block I/O. Process scheduling. [2\u00a0lectures]\n\n<p>\n</p></li>\n\n\n<br/>\n<a name=\"SECTION02032300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should be able to\n\n\n\n<li>describe the general structure and purpose of an operating system;\n</li>\n<li>explain the concepts of process, address space, and file;\n</li>\n<li>compare and contrast various CPU scheduling algorithms;\n</li>\n<li>understand the differences between segmented and paged memories, and be able to describe the advantages and disadvantages of each;\n</li>\n<li>compare and contrast polled, interrupt-driven and DMA-based access to I/O devices.\n</li>\n\n\n<br/>\n<a name=\"SECTION02032400000000000000\">\nRecommended reading</a>\n\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>. Addison-Wesley (3rd ed.).\n<br/>\nSilberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <em>Operating systems concepts</em>. Wiley (8th ed.).\n<br/>\nAnderson, T. &amp; Dahlin, M. (2014). <em>Operating Systems: Principles &amp; Practice</em>. Recursive Books (2nd ed.).\n<br/>\nLeffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>\nMcKusick, M.K., Neville-Neil, G.N. &amp; Watson, R.N.M. (2014) <em>The Design and Implementation of the FreeBSD Operating System</em>. Pearson Education. (2nd ed.).\n<br/>\nSolomon, D. &amp; Russinovich, M. (2000). <em>Inside Windows 2000</em>. Microsoft Press (3rd ed.).\n\n\n\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/OpSystems", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "FJavaBrfg": {"supervisions": null, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION02044100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02044200000000000000\">\nLecture</a>\n\n\nThe lecture describes the requirements for the first assessed\nexercise of the Part\u00a0IB Further Java course.\n\n\n<a name=\"SECTION02044300000000000000\">\nObjectives</a>\n\n\nOn completing the exercise students should\n\n\n\n<li>be prepared for the Part\u00a0IB Further Java course;\n\n<p>\n</p></li>\n<li>have developed their practical Java programming skills further.\n\n<p>\n</p></li>\n\n\n\n\n", "course_name": "Further Java Briefing", "course_code": "FJavaBrfg", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/FJavaBrfg", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "IntDesign": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-InteractionDesign.html", "description": "\n\n\n<a name=\"SECTION03045100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION03045200000000000000\">\nLectures</a>\n\n\n<li><b>Overview and requirements analysis.</b> Introduction to the course and\nthe practicals. Participatory design process. Identifying potential users and\nunderstanding their tasks. Identifying and establishing non-functional and\nfunctional requirements. Socio-technical Models and Soft Systems Methodology.\n\n<p>\n</p></li>\n<li><b>Data gathering.</b> Data collection techniques: Observation, interviews,\ncard sorting, questionnaires, studying documentation, focus groups, contextual\ninquiry, scenarios / use cases, and researching similar products. Quantitative\nand qualitative analysis.\n\n<p>\n</p></li>\n<li><b>Design and prototyping.</b> Participatory design process. Conceptual\nversus physical design. Concept development. Prototyping and different kinds\nof prototypes. Personas and storyboards. Task models.\n\n<p>\n</p></li>\n<li><b>Case studies from the industry.</b> Guest lecture.\n\n<p>\n</p></li>\n<li><b>Principles of good design.</b> Shneiderman\u2019s golden rules of interface\ndesign. Overview of other design principles/rules.\n\n<p>\n</p></li>\n<li><b>Human cognition for interaction design.</b> The Model human processor.\nAttention, perception/recognition, memory, context and grouping, and their\nimplications for interaction design. Gestalt Laws of perceptual organisation.\n\n<p>\n</p></li>\n<li><b>GOMS &amp; Hick\u2019s Law and Fitts\u2019s Law</b> Definition and use of GOMS in\ninteraction design. Definition and use of Hicks law / Fitts law.\n\n<p>\n</p></li>\n<li><b>Heuristic evaluation.</b> The process of Heuristic Evaluation (HE):\nPre-evaluation training, evaluation, severity ratings, and feedback into\ndesign. Ten usability Heuristics with definitions and practical examples.\n<br/><b>Cognitive walkthrough.</b> The process of cognitive walkthrough:\nDefining inputs, stepping through action sequences, recording information,\nand revising the user interface.\n\n<p>\n</p></li>\n<li><b>Student (group) presentations</b>\n</li>\n\n\n<a name=\"SECTION03045300000000000000\">\nObjectives</a>\n\n\nBy the end of the course students should \n\n\n\n<li>have a thorough understanding of the iterative design process and be\nable to apply it to interaction design;\n\n<p>\n</p></li>\n<li>be able to design new user interfaces that are informed by principles of\ngood design, and the principles of human visual and affective perception,\ncognition and communication;\n\n<p>\n</p></li>\n<li>be able to construct user interfaces using Java with a strong emphasis\non users, usability and appearance;\n\n<p>\n</p></li>\n<li>be able to evaluate existing or new user interfaces using multiple\ntechniques;\n\n<p>\n</p></li>\n<li>be able to compare and contrast different design techniques and to\ncritique their applicability to new domains.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION03045400000000000000\">\nRecommended reading</a>\n\n\n* Preece, J., Rogers, Y. &amp; Sharp, H. (2015). <em>Interaction design</em>.\nWiley (4th ed.).\n\n\n\n", "course_name": "Interaction Design", "course_code": "IntDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/IntDesign", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "NumMethods": {"supervisions": 4, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-NumericalMethods.html", "description": "\n\n\n<a name=\"SECTION02041100000000000000\">\nAims</a>\n\n\n<li>an introduction to\n(IEEE) floating-point data representation and arithmetic; \n</li>\n<li>illustrations of how na\u00efve implementations of obvious mathematics can go badly wrong;\n</li>\n<li>a study of several standard numerical processes, algorithms and techniques.\n</li>\n\n\nAn overall implicit aim is to encourage caution when using any\nfloating-point value produced by a computer program.  A variety of code\nfragments are provided and most are available in multiple languages.\nStudents are strongly encouraged to experiment with these fragments.\n\n\n(Changes from last year: One fewer topics will be lectured. A full-text Learners\u2019 Guide PDF will be available as well as slide hardcopies.)\n\n\n<br/>\n<a name=\"SECTION02041200000000000000\">\nLectures</a>\n\n\n<li><b>Integer and floating-point representation and arithmetic.</b>\nSigned and unsigned integers and fixed-point; arithmetic, saturating arithmetic.\nLong division and multiplication.\nFloating point I/O in ASCII.\nWhat numbers are exactly representable in bases 2 and 10.\nAccuracy in terms of significant figures.\n\n<p>\n</p></li>\n<li><b>IEEE floating-point arithmetic.</b>\nFloating-point arithmetic, and the IEEE requirements.\nIEEE 754/854 floating point (32 and 64 bit); zeros, infinities, NaN.\nOverflow, underflow, progressive loss of significance.      Rounding modes.\nFloating-point arithmetic is non-associative, and mathematical equivalences fail.\nNonsensical results, e.g. <tt>sin(1e40)</tt>.\nDifficulty in obtaining IEEE-quality in libraries.\n\n<p>\n</p></li>\n<li><b>How floating-point computations diverge from real-number calculations.</b>\nAbsolute Error, Relative Error, Machine epsilon, Unit in Last Place (ulp).\nFinite computation: solving a quadratic.\nSumming a finite series.\nRounding (round-off) and truncation (discretisation) error.\nNumerical differentiation; determining a good step size.\n\n<p>\n</p></li>\n<li><b>Iteration and when to stop.</b>\nUnbounded computation may produce unbounded errors.\nSolving equations by iteration and comparison to terminate it.\nNewton\u2019s method.\nOrder of convergence. Limit cycles.\nWhy summing a Taylor series is problematic. \nCondition number, partial derivatives, backwards stability and chaos.\n\n<p>\n</p></li>\n<li><b>Matrix Form Simultaneous Equations.</b>\nGaussian Elimination. \nStability and pivoting improvements.\nPositive-definite. L/U and Cholesky decompositions.  Doolittle/Crout method.\n\n<p>\n</p></li>\n<li><b>Efficient and Approximate Implementations</b>\nA subset of the following topics will we be lectured/examinable as announced on the website:\nChebychev orthogonal basis (for power series economisation) \nPractical implementation of scientific (trig/log) functions. \nSplines. Comparison of Taylor, Chebychev and Cordic.\n\n<p>\n</p></li>\n<li><b>Finite-Difference Time-Domain Simulation.</b>\nNumerical simulation of SHM, charge/discharge, waves and other various examples (such as a Moniac Simulator). \n\n<p>\n</p></li>\n<li><b>Fluid Flow Analysis.</b>  Using a matrix representation\nof a linear flow circuit (water, electricity etc) to find steady\nstate. Extensions for non-linear and time-varying branches (as used by SPICE).\n\n<p>\n</p></li>\n<li><b>Adaptive Methods and Custom Encodings</b> \nA subset of the following topics will we be lectured/examinable as announced on the website:\nArbitrary precision floating point, adaptive floating point, interval arithmetic.\nRounding errors in PCM. Logarithmic and other non-linear representations. Their use in a-posteriori decision algorithms.\nEg for rapid multiplication in Viterbi/Bayes and specialist ALUs (e.g. for low-density parity).\nSimulated Annealing. Non-linear spatial quantisation.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02041300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>be able to convert simple decimal numbers to and from IEEE\n  floating-point format, and to perform IEEE arithmetic on them;\n\n<p>\n</p></li>\n<li>be able to identify problems with floating-point implementations of\n      simple mathematical problems and know when incorrect solution is likely;\n\n<p>\n</p></li>\n<li>be familiar with several key algorithms from the history of numerical analysis;\n\n<p>\n</p></li>\n<li>decide how and when computation energy should be traded for accuracy;\n\n<p>\n</p></li>\n<li>know to use a professionally-written package whenever possible\n      (and still to treat claims of accuracy with suspicion).\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02041400000000000000\">\nRecommended reading</a>\n\n\nOverton, M.L. (2001). <em>Numerical computing with IEEE floating point arithmetic</em>. SIAM.\n\n\nFurther reading - goes far beyond the course\n\n\nGoldberg, D. (1991). <em>What every computer scientist should know about floating-point arithmetic</em>. ACM Computing Surveys, vol. 23, pp. 5-48.\n\n\n\n", "course_name": "Numerical Methods", "course_code": "NumMethods", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/NumMethods", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWSecEng": {"supervisions": 3, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandSecurityEngineering.html", "description": "\n\n\n<a name=\"SECTION02042100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION02042200000000000000\">\nLectures</a>\n\n\n\n<li><b>What is a security policy or a safety case?</b> Definitions and\nexamples; one-way flows for both confidentiality and safety properties; \nseparation of duties. Top-down and bottom-up analysis methods. What \narchitecture can do, versus benefits of decoupling policy from mechanism.\n\n<p>\n</p></li>\n<li><b>Predicting user behaviour.</b> Predicting and mitigating user\nerrors. The hierarchy of harms. Attitudes to risk: expected utility, \nprospect theory, framing, status quo bias, gender. The characteristics \nof human memory; forgetting passwords versus guessing them.\n\n<p>\n</p></li>\n<li><b>Security protocols;</b> how to enforce policy using cryptography \nand structured human interaction. Man-in-the-middle attacks. The role of \nverification and its limitations.\n\n<p>\n</p></li>\n<li><b>Bugs of different types:</b> design errors, implementation errors \naffecting arithmetic, logic, syntax, and concurrency. Code injection \nattacks. Defensive programming: secure coding, contracts. Fuzzing.\n\n<p>\n</p></li>\n<li><b>The software crisis.</b> Examples of large-scale project failure, \nsuch as the London Ambulance Service system and the NHS National \nProgramme for IT. Intrinsic difficulties with complex software.\n\n<p>\n</p></li>\n<li><b>The software life cycle.</b> The software life cycle. Getting the\nspecification right; requirements analysis methods; modular design; the role of \nprototyping; the waterfall and spiral models.\n\n<p>\n</p></li>\n<li><b>Guest lecture.</b> A guest lecture on design for testability.\n\n<p>\n</p></li>\n<li><b>Modern integrated development environments.</b> Tools to support code \nmanagement, code review and test case generation; git and Jenkins.\nContinuous integration, refactoring, release engineering, patch \nstrategies.\n\n<p>\n</p></li>\n<li><b>Critical systems:</b> where real-time performance, safety or security \nis essential. Examples of catastrophic failure; problems with usability and \nhuman error for both safety engineering and security engineering.\n\n<p>\n</p></li>\n<li><b>Quality assurance.</b> The contribution of reviews and testing; \nreliability growth models; static analysis tools; programming philosophies; \nsoftware maintenance life-cycle costs. The need for code indexing, code \nownership, library management, design documentation and the maintenance of\nsafety and security ratings.\n\n<p>\n</p></li>\n<li><b>Real-world challenges in combining safety and security.</b> Project \nplanning tools; PERT and GANTT charts. Open source: advantages and \ndrawbacks. Evaluation and assurance; maintaining a security rating or a \nsafety case.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION02042300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should know how writing programs \nwith tough assurance targets, in large teams, or both, differs from \nthe programming exercises they have engaged in so far. They should \nappreciate the waterfall, spiral and evolutionary models of software \ndevelopment as well as the value of various development and \nmanagement tools. They should understand the development life cycle \nand its basic economics. They should understand the various types of \nbugs, vulnerabilities and hazards, how to find them, and how to avoid \nintroducing them. Finally, they should be prepared for the \norganizational aspects of their Part\u00a0IB group project.\n\n\n<a name=\"SECTION02042400000000000000\">\nRecommended reading</a>\n\n\nHoward, M. &amp; LeBlanc, D. (2003). <em>Writing secure code</em>. Microsoft Press.\n<br/>\nAnderson, R. (2008). <em>Security engineering</em> (Part 1 and Chapters 25-26). Wiley. Available at:\n<br/><a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html5\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n<br/>\nLeveson, N. (1994). <i>Safeware</i>. Addison-Wesley.\n<br/>\n\nFurther reading:\n\n\nBrooks, F.P. (1975). <i>The mythical man month</i>. Addison-Wesley.\n<br/>\nReason, J. (2008). <i>The human contribution</i>. Ashgate Publishing.\n<br/>\nMaguire, S. (1993). <i>Writing solid code</i>. Microsoft Press.\n<i>Report of the inquiry into the London Ambulance Service</i> (SW Thames RHA, 40 Eastbourne Terrace, London W2 3QR, February 1993).\n<br/><a href=\"http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html\" name=\"tex2html6\"><tt>http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html</tt></a>\n<br/>\n\n\n", "course_name": "Software and Security Engineering", "course_code": "SWSecEng", "course_url": "https://www.cl.cam.ac.uk/teaching/1718/SWSecEng", "lecturers": [], "year": "1718", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}