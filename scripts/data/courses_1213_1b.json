{"AlgorithII": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-AlgorithmsII.html", "description": "\n\n\n<a name=\"SECTION03021100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03021200000000000000\">Lectures</a>\n\n<li><b>Advanced data structures.</b>\nFibonacci heaps. Disjoint sets. Van Emde Boas trees.\n[Ref: Cormen <span class=\"textit\">et al.</span> Ch 19, 20, 21] [4 lectures]\n\n<p></p></li>\n<li><b>Graph algorithms.</b>\nGraph representations. Breadth-first and depth-first search. Topological \nsort. Minimum spanning tree. Kruskal and Prim algorithms. Shortest \npaths. Bellman-Ford and Dijkstra algorithms. Maximum flow. \nFord-Fulkerson method. Matchings in bipartite graphs.\n[Ref: Ch 22, 23, 24, 25, 26] [6 lectures]\n\n<p></p></li>\n<li><b>Multithreaded algorithms.</b>\nMatrix multiplication. Mergesort.\n[Ref: Ch 27] [1 lecture]\n\n<p></p></li>\n<li><b>Geometric algorithms.</b>\nIntersection of segments. Convex hull: Graham\u2019s scan, Jarvis\u2019s march.\n[Ref: Ch 33] [1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION03021300000000000000\">Objectives</a>\n\nAt the end of the course students should \n\n\n<li>have a good understanding of how several elaborate algorithms\n  work;\n\n<p></p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of complex\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\n\n<a name=\"SECTION03021400000000000000\">Recommended reading</a>\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein, C. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN 0-262-53196-8\n<br/>Sedgewick, R. (2004). <em>Algorithms in Java</em> vol. 2 (note that C and C++ editions are also available and are equally good for this course). Addison-Wesley. ISBN 0-201-36121-3. New edition forthcoming in 2008.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm design</em>. Addison-Wesley. ISBN 0-321-29535-8.\n<br/>\n<br/>\nStudents are expected to buy, make extensive use of, and keep as \nreference for their future career, one of the above textbooks: those not \ndoing so will be severely disadvantaged. The recommended choice is \nCormen <em>et al.</em> which, in spite of its superb quality, is the cheapest \n(about 35 GBP new for over 1300 pages). The pointers in the syllabus are \nto chapters in the second edition of that book. The other textbooks are \nall excellent alternatives and their relative merits are discussed in \nthe course handout.\n\n\n", "course_name": "Algorithms\u00a0II", "course_code": "AlgorithII", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/AlgorithII", "lecturers": ["fms27"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompDesign": {"supervisions": 5, "lectures": 18, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerDesign.html", "description": "\n\nPostponement of lectures\n\nOverview\n<a name=\"SECTION03022100000000000000\">Aims</a>\n\nThe aims of this course are to introduce a hardware description\nlanguage (SystemVerilog) and computer architecture concepts in order to\ndesign computer systems. The parallel ECAD practical classes will allow\nstudents to apply the concepts taught in lectures.\n\nThere are 18 lectures which cover design with hardware description\nlanguages, computer architecture and then computer implementation.  A\nweb based tutor (equivalent of 4 lectures) is used to teach much of\nthe SystemVerilog hardware description language.\n\n\n<a name=\"SECTION03022200000000000000\">Lectures</a>\n\n<li><b>Introduction and motivation.</b>\n  Current technology, technology trends, ECAD trends, challenges. \n<p></p></li>\n<li><b>Logic modelling, simulation and synthesis.</b>\n  Logic value and delay modelling. Discrete event and device\n  simulation. Automatic logic minimization. \n<p></p></li>\n<li><b>SystemVerilog FPGA design.</b>\n  Practicalities of mapping SystemVerilog descriptions of hardware\n  (including a processor) onto an FPGA\n  board.  Tips and pitfalls when generating larger modular designs. \n<p></p></li>\n<li><b>Chip, board and system testing.</b>\n  Production testing, fault models, testability, fault coverage,\n  scan path testing, simulation models. \n<p></p></li>\n<li><b>Historical perspective on computer architecture.</b>\n<p></p></li>\n<li><b>Early instruction set architecture.</b>\n   EDSAC <em>versus</em> Manchester Mark I.\n\n<p></p></li>\n<li><b>RISC machines.</b>\n   Introduction to RISC processor design.\n\n<p></p></li>\n<li><b>Building a simple RISC machine.</b>\n<p></p></li>\n<li><b>CISC machines and the Intel x86 instruction set.</b>\n<p></p></li>\n<li><b>Java Virtual Machine.</b>\n<p></p></li>\n<li><b>Memory hierarchy.</b>\n  Caching, etc.\n\n<p></p></li>\n<li><b>Hardware support for operating systems.</b>\n  Memory protection, exceptions, interrupts, etc.\n\n<p></p></li>\n<li><b>Pipelining and data paths.</b>\n<p></p></li>\n<li><b>Internal and external communication.</b>\n<p></p></li>\n<li><b>Introduction to many-core processors.</b>\n<p></p></li>\n<li><b>Data-flow machines.  Future directions.</b>\n<p></p></li>\n\n\n<a name=\"SECTION03022300000000000000\">On-Line Learning Component: Cambridge SystemVerilog Tutor</a>\n\n<li>The interactive web-based tutor teaches the synthesizable\n  subset of SystemVerilog which is required to complete the laboratory\n  sessions.\n</li>\n\n\n<a name=\"SECTION03022400000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read assembler given a guide to the instruction set\nand be able to write short pieces of assembler if given an\ninstruction set or asked to invent an instruction set;\n\n<p></p></li>\n<li>understand the differences between RISC and CISC assembler;\n\n<p></p></li>\n<li>understand what facilities a processor provides to support\noperating systems, from memory management to software interrupts;\n\n<p></p></li>\n<li>understand memory hierarchy including different cache\nstructures;\n\n<p></p></li>\n<li>appreciate the use of pipelining in processor design;\n\n<p></p></li>\n<li>understand the communications structures, from buses close to\nthe processor, to peripheral interfaces;\n\n<p></p></li>\n<li>have an appreciation of control structures used in processor design;\n\n<p></p></li>\n<li>have an appreciation of how to implement a processor in SystemVerilog.\n\n<p></p></li>\n\n\n<a name=\"SECTION03022500000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture: from gates to processors</em>. Morgan Kaufmann.\n\nRecommended further reading:\n\nHennessy, J. &amp; Patterson, D. (2006). <em>Computer architecture: a quantitative approach</em>. Elsevier (4th ed.). ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also still generally relevant.)\n<br/>Patterson, D.A. &amp; Hennessy, J.L. (2004). <em>Computer organization and design</em>. Morgan Kaufmann (3rd ed., as an alternative to the above). (2nd ed., 1998, is also good.)\n<br/>Pointers to sources of more specialist information are included in the\nlecture notes and on the associated course web page.\n\n\n", "course_name": "Computer Design", "course_code": "CompDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CompDesign", "lecturers": ["swm11"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompGraph": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerGraphicsandImageProcessing.html", "description": "\n\n\n<a name=\"SECTION030213100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030213200000000000000\">Lectures</a>\n\n<li><b>Background.</b>  What is an image? What are computer graphics, image processing, and computer vision? How do they relate to one another? Image capture. Image display. Human vision. Resolution and quantisation. Colour and colour spaces. Storage of images in memory, and double buffering. Display devices: brief overview of two display technologies (LCD, DMD) and two printer technology (ink jet and laser printer). [3\u00a0lectures]\n\n<p></p></li>\n<li><b>2D computer graphics.</b>  Drawing a straight line. Drawing circles and ellipses. Cubic curves: specification and drawing. Clipping lines. Filling polygons. Clipping polygons. 2D transformations, vectors and matrices, homogeneous co-ordinates. Uses of 2D graphics: HCI, typesetting, graphic design. [4\u00a0lectures]\n\n<p></p></li>\n<li><b>3D computer graphics.</b>  Projection: orthographic and perspective. 3D transforms and matrices. 3D rotation using a non-matrix method. 3D clipping. 3D curves. 3D scan conversion using the z-buffer. Anti-aliasing and the A-buffer. Lighting: theory, BRDF, approximations: flat shading, Gouraud shading, Phong shading. Texture mapping. OpenGL programming. [7\u00a0lectures]\n\n<p></p></li>\n<li><b>Image processing.</b>  Operations on images: filtering, point processing, compositing. Halftoning and dithering, error diffusion. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION030213300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>explain the basic function of the human eye and how this impinges on resolution, quantisation, and colour representation for digital images; describe a number of colour spaces and their relative merits; explain the workings of two display technologies and two printer technologies;\n\n<p></p></li>\n<li>describe and explain the following algorithms: mid-point line drawing, mid-point circle drawing, Bezier cubic drawing, Cohen-Sutherland line clipping, scanline polygon fill, Sutherland-Hodgman polygon clipping, <span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$z$\" border=\"0\" height=\"21\" src=\"img1.png\" width=\"14\"/></span>-buffer, <span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$A$\" border=\"0\" height=\"21\" src=\"img2.png\" width=\"19\"/></span>-buffer, texture mapping, error diffusion;\n\n<p></p></li>\n<li>use matrices and homogeneous coordinates to represent and perform 2D and 3D transformations; understand and use 3D to 2D projection, the viewing volume, and 3D clipping;\n\n<p></p></li>\n<li>understand Bezier curves and patches; understand sampling and super-sampling issues; understand lighting techniques and how they are applied to z-buffer polygon scan conversion; understand texture mapping;\n\n<p></p></li>\n<li>explain how to use filters, point processing, and arithmetic operations in image processing and describe a number of examples of the use of each; explain how halftoning, ordered dither, and error diffusion work.\n\n<p></p></li>\n\n\n<a name=\"SECTION030213400000000000000\">Recommended reading</a>\n\n* Foley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>Gonzalez, R.C. &amp; Woods, R.E. (2008). <em>Digital image processing</em>. Addison-Wesley (3rd ed). [The second edition (1992) and the first edition (Gonzalez &amp; Wintz, 1977) are as useful for this course.]\n<br/>* Slater, M., Steed, A. &amp; Chrysanthou, Y. (2002). <em>Computer graphics and virtual environments: from realism to real-time</em>.  Addison-Wesley.\n\n\n\n", "course_name": "Computer Graphics and Image Processing", "course_code": "CompGraph", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CompGraph", "lecturers": ["pr10"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ConcDisSys": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html", "description": "\n\n\n<a name=\"SECTION03024100000000000000\">Aims of the Michaelmas Term part of the course</a>\n\n\n<a name=\"SECTION03024200000000000000\">Michaelmas Term Lectures (Concurrency)</a>\n\n\n<li><b>Introduction; thread models.</b>\nOverview of properties of distributed and concurrent systems. Software\nsystem structure. Occurrence of concurrency in systems. Recap of scheduling\nand pre-emption. Thread models.\n\n<p></p></li>\n<li><b>Classical concurrency control.</b>\nShared data and critical regions. Mutual exclusion and condition\nsynchronisation. Semaphores. Implementation of concurrency control.\n\n<p></p></li>\n<li><b>Classical problems using semaphores.</b>\nBounded cyclic buffer (producer(s) and consumer(s)), multiple readers and\nwriters. Problems arising in semaphore programming.\n\n<p></p></li>\n<li><b>Concurrency support in programming languages.</b>\nShared data: monitors, pthreads, Java. No shared data: occam, Ada active\nobjects, Erlang, Kilim, tuple spaces.  \nLock-free programming.\n\n<p></p></li>\n<li><b>Concurrent composite operations.</b>\nComposite operations in main memory and persistent memory. Dynamic\nresources allocation and deadlock. Dining philosophers program. Deadlock\ndetection and avoidance.\n\n<p></p></li>\n<li><b>Transactions.</b>\nACID properties. Concurrency control and crash recovery. Definition of\nconflicting operations. Serialisation. Cascading aborts.\n\n<p></p></li>\n<li><b>Database concurrency control.</b>\nPessimistic concurrency control: two-phase locking, timestamp ordering.  \nOptimistic concurrency control.\n\n<p></p></li>\n<li><b>Database recovery and summary of \u201cConcurrency\u201d.</b>\nWrite ahead log, undo/redo. Points to take forward.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the need for concurrency control in operating systems and\napplications, both mutual exclusion and condition synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the implications of\ndifferent approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming languages for\nconcurrency control and be able to judge the scope, performance\nimplications and possible applications of the various approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of transactions,\nhow concurrency control can be assured and how transactions can be\ndistributed;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and their\nimplications for system design;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of fundamental\nservices and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent Systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.). \n\n\n<a name=\"SECTION03024500000000000000\">Aims of the Lent Term part of the course</a>\n\nThe aims of this course are to study the fundamental characteristics of\ndistributed systems, including their models and architectures; the\nimplications for software design; some of the techniques that have been\nused to build them; and the resulting details of good distributed\nalgorithms and applications.\n\n\n<a name=\"SECTION03024600000000000000\">Lent Term Lectures (Distributed Systems)</a>\n\n\n<li><b>Introduction, Evolution, Architecture.</b>\nFundamental properties. Evolution from LANs. Introduction to the need\nfor naming, authentication, policy specification and enforcement.\nExamples of multi-domain systems. Why things can get difficult\nquickly.  Enough Erlang to understand subsequent examples.\n\n<p></p></li>\n<li><b>Time and event ordering.</b>\n Time, clocks and event ordering.\n    Earth time, computer clocks, clock drift, clock synchronisation.\n    Order imposed by inter-process communication. \n    Timestamps point/interval. \n    Event composition; uncertainty of ordering, failure and delay.\n<br/><p>Process groups: open/closed, structured/unstructured. \n    Message delivery ordering: arrival order; causal order (vector \nclocks);\n    total order. Physical causality from real-world examples. \n\n</p><p></p></li>\n<li><b>Consistency and commitment.</b>\nStrong and weak consistency. Replica management. Quorum assembly.\n    Distributed transactions. Distributed concurrency control:\n    two-phase locking, timestamp ordering.\n    Atomic commitment; two-phase commit protocol.\n    Distributed optimistic concurrency control and commitment. \n<br/><p>Some algorithm outlines: Election of a leader. \n    Distributed mutual exclusion.\n\n</p><p></p></li>\n<li><b>Middleware.</b>\n  Synchronous: RPC, object-orientated. Asynchronous: message orientated,\n    publish/subscribe, peer-to-peer. \n    Event-based systems. \n    Examples of some simple distributed programs in Java and Erlang.\n\n<p></p></li>\n<li><b>Naming and name services.</b>\nUnique identifiers, pure and impure names.\n    Name spaces, naming domains, name resolution.\n    Large scale name services: DNS, X.500/LDAP, GNS.\n    Use of replication. Consistency-availability tradeoffs. \n    Design assumptions and future issues.\n\n<p></p></li>\n<li><b>Access control for multi-domain distributed systems.</b>\n Requirements from healthcare, police, emergency services, globally\n    distributed companies.\n    ACLs, capabilities, Role-Based Access Control (RBAC). Context aware \naccess control.\n    Examples: OASIS, CBCL OASIS, Microsoft Healthvault, ...     Authentication and authorisation: Raven, Shibboleth, OpenID.\n\n<p></p></li>\n<li><b>Distributed storage services. Summary and roundup.</b>\nNetwork-based storage services. Naming and access control. \nPeer-to-peer protocols. Content distribution. \nSummary and roundup. Open problems for future years: transactional main\nmemory; multicore concurrency control; untrusted components. Byzantine \nfailure.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024700000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the need for concurrency control in operating systems\n  and applications, both mutual exclusion and condition\n  synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the\n  implications of different approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming\n  languages for concurrency control and be able to judge the scope,\n  performance implications and possible applications of the various\n  approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock;\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of\n  transactions, how concurrency control can be assured and how\n  transactions can be distributed;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and\n  their implications for system design;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of\n  fundamental services and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024800000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent Systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.).\n\n\n", "course_name": "Concurrent and Distributed Systems", "course_code": "ConcDisSys", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/ConcDisSys", "lecturers": ["rnw24", "avsm2"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "ECAD+Arch": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\nLaboratory Materials\n\n", "course_name": "ECAD and Architecture Practical Classes", "course_code": "ECAD+Arch", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/ECAD+Arch", "lecturers": ["swm11", "rdm34"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "FJava": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Further Java", "course_code": "FJava", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/FJava", "lecturers": ["arb33", "acr31"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "GroupProj": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Group Project", "course_code": "GroupProj", "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/", "lecturers": ["iml1"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "LogicProof": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html", "description": "\n\n\n<a name=\"SECTION03027100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03027200000000000000\">Lectures</a>\n\n<li><b>Introduction to logic.</b>\nSchematic statements.  Interpretations and validity.  Logical\nconsequence.  Inference.\n\n<p></p></li>\n<li><b>Propositional logic.</b>\nBasic syntax and semantics.  Equivalences.  Normal forms.\nTautology checking using CNF.\n\n<p></p></li>\n<li><b>The sequent calculus.</b>\nA simple (Hilbert-style) proof system.  Natural deduction systems.\nSequent calculus rules.  Sample proofs.\n\n<p></p></li>\n<li><b>First order logic.</b>\nBasic syntax.  Quantifiers.  Semantics (truth definition).\n\n<p></p></li>\n<li><b>Formal reasoning in FOL.</b>\nFree <em>versus</em> bound variables.  Substitution. Equivalences for\nquantifiers.  Sequent calculus rules.  Examples.\n\n<p></p></li>\n<li><b>Clausal proof methods.</b>\nClause form.  A SAT-solving procedure.  The resolution rule.\nExamples.  Refinements.\n\n<p></p></li>\n<li><b>Skolem functions and Herbrand\u2019s theorem.</b>\nPrenex normal form.  Skolemisation.  Herbrand models and their\nproperties.\n\n<p></p></li>\n<li><b>Unification.</b>\nComposition of substitutions.  Most general unifiers. A\nunification algorithm.  Applications and variations.\n\n<p></p></li>\n<li><b>Prolog.</b>\nBinary resolution.  Factorisation.  Example of Prolog\nexecution. Proof by model elimination.\n\n<p></p></li>\n<li><b>Binary decision diagrams.</b>\nGeneral concepts.  Fast canonical form algorithm.  Optimisations.\nApplications.\n\n<p></p></li>\n<li><b>Modal logics.</b>\nPossible worlds semantics.  Truth and validity.  A Hilbert-style\nproof system.  Sequent calculus rules.\n\n<p></p></li>\n<li><b>Tableaux methods.</b>\nSimplifying the sequent calculus.  Examples.  Adding unification.\nSkolemisation.  The world\u2019s smallest theorem prover?\n\n<p></p></li>\n\n\n<a name=\"SECTION03027300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to manipulate logical formulas accurately;\n\n<p></p></li>\n<li>be able to perform proofs using the presented formal calculi;\n\n<p></p></li>\n<li>be able to construct a small BDD;\n\n<p></p></li>\n<li>understand the relationships among the various calculi, e.g. SAT solving, resolution and Prolog;\n\n<p></p></li>\n<li>be able to apply the unification algorithm and to describe its uses.\n\n<p></p></li>\n\n\n<a name=\"SECTION03027400000000000000\">Recommended reading</a>\n\n* Huth, M. &amp; Ryan, M. (2004). <em>Logic in computer science: modelling and reasoning about systems</em>. Cambridge University Press (2nd ed.).\n<br/>Ben-Ari, M. (2001). <em>Mathematical logic for computer science</em>. Springer (2nd ed.).\n\n\n", "course_name": "Logic and Proof", "course_code": "LogicProof", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/LogicProof", "lecturers": ["lp15"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "MathMforCS": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MathematicalMethodsforComputerScience.html", "description": "\n\n\n<a name=\"SECTION03028100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03028200000000000000\">Lectures</a>\n\n<li>Part A: Fourier and related methods (Professor J. Daugman)\n  \n<ul><li><b>Fourier representations.</b>  Inner product spaces and orthonormal\n    systems. Periodic functions and Fourier series. Results and\n    applications. The Fourier transform and its properties. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Discrete Fourier methods.</b> The Discrete Fourier transform,\n    efficient algorithms implementing it, and applications.  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Wavelets.</b>  Introduction to wavelets, with applications in\n    signal processing, coding, communications, and computing. [1\u00a0lecture]\n  \n</li>\n</ul>\n</li>\n<li>Part B: Probability methods (Dr R.J. Gibbens)\n  \n<ul><li><b>Inequalities and limit theorems.</b>  Bounds on tail\n    probabilities, moment generating functions, notions of convergence,\n    weak and strong laws of large numbers, the central limit theorem,\n    statistical applications, Monte Carlo simulation. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Markov chains.</b>  Discrete-time Markov chains,\n    Chapman-Kolmogorov equations, classifications of states, limiting and\n    stationary behaviour, time-reversible Markov chains. Examples and\n    applications. [3\u00a0lectures]\n  \n</li>\n</ul>\n</li>\n\n\n<a name=\"SECTION03028300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the fundamental properties of inner product spaces\n  and orthonormal systems;\n\n<p></p></li>\n<li>grasp key properties and uses of Fourier series and transforms,\n  and wavelets;\n\n<p></p></li>\n<li>understand discrete transform techniques, algorithms, and applications;\n\n<p></p></li>\n<li>understand basic probabilistic inequalities and limit results\n  and be able to apply them to commonly arising models;\n\n<p></p></li>\n<li>be familiar with the fundamental properties and uses of\n  discrete-time Markov chains.\n\n<p></p></li>\n\n\n<a name=\"SECTION03028400000000000000\">Reference books</a>\n\n* Pinkus, A. &amp; Zafrany, S. (1997). <em>Fourier series and integral transforms</em>. Cambridge University Press.\n<br/>* Ross, S.M. (2002). <em>Probability models for computer science</em>. Harcourt/Academic Press.\n<br/>Mitzenmacher, M. &amp; Upfal, E. (2005). <em>Probability and computing: randomized algorithms and probabilistic analysis</em>. Cambridge University Press.\n<br/>Oppenheim, A.V. &amp; Willsky, A.S. (1997). <em>Signals and systems</em>.  Prentice\u00a0Hall.\n\n\n", "course_name": "Mathematical Methods for Computer Science", "course_code": "MathMforCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/MathMforCS", "lecturers": ["jgd1000", "rg31"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CandC++": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html", "description": "\n\n\n<a name=\"SECTION03029100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03029200000000000000\">Lectures</a>\n\n<li><b>Introduction to the C language.</b>  Background and goals of C.\n  Types and variables.  Expressions and statements.  Functions.\n  Multiple compilation units. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Further C concepts.</b>  Preprocessor. Pointers and pointer\n  arithmetic. Data structures. Dynamic memory management.  Examples.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Introduction to C++.</b>  Goals of C++. Differences between C\n  and C++. References <i>versus</i> pointers. Overloading functions.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Objects in C++.</b>  Classes and structs. Operator overloading.\n  Virtual functions. Multiple inheritance. Virtual base classes.\n  Examples. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Further C++ concepts.</b>  Exceptions. Templates and\n  meta-programming. Java Native Interface (JNI). Examples. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03029300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read and write C and C++ programs;\n\n<p></p></li>\n<li>understand the interaction between C and C++ programs and the\n  host operating system;\n\n<p></p></li>\n<li>be familiar with the structure of C and C++ program execution in\n  machine memory;\n\n<p></p></li>\n<li>understand the object-oriented paradigm presented by C++;\n\n<p></p></li>\n<li>be able to make effective use of templates and meta-programming\n  techniques as used in the STL;\n\n<p></p></li>\n<li>understand the potential dangers of writing programs in C and C++.\n\n<p></p></li>\n\n\n<a name=\"SECTION03029400000000000000\">Recommended reading</a>\n\n* Eckel, B. (2000). <em>Thinking in C++, Vol.\u00a01: Introduction to Standard C++</em>. Prentice\u00a0Hall (2nd ed.).  Also available at\n<br/><a href=\"http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html\" name=\"tex2html8\"><tt>http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html</tt></a>\n<br/>Kernighan, B.W. &amp; Ritchie, D.M. (1988). <em>The C programming language</em>. Prentice\u00a0Hall (2nd ed.).\n<br/>Stroustrup, B. (2008). <em>Programming -- principles and practice using C++</em>. Addison-Wesley.\n<br/>Stroustrup, B. (1994). <em>The design and evolution of C++</em>. Addison-Wesley.\n<br/>Lippman, S.B. (1996). <em>Inside the C++ object model</em>. Addison-Wesley.\n\n\n", "course_name": "Programming in C and C++", "course_code": "CandC++", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CandC++", "lecturers": ["am21"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Prolog": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-PrologforArtificialIntelligence.html", "description": "\n\n\n<a name=\"SECTION030210100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030210200000000000000\">Lectures</a>\n\n<li><b>Introduction to Prolog.</b>  The structure of a Prolog program\n  and how to use the Prolog interpreter.  Unification revisited. Some\n  simple programs.\n\n<p></p></li>\n<li><b>Arithmetic and lists.</b>  Prolog\u2019s support for evaluating\n  arithmetic expressions and lists.  The space complexity of program\n  evaluation discussed with reference to last-call optimisation.\n\n<p></p></li>\n<li><b>Backtracking, cut, and negation.</b>  The <tt>cut</tt> operator\n  for controlling backtracking.\n  <span class=\"textit\">Negation as failure</span> and its uses.\n\n<p></p></li>\n<li><b>Search and cut.</b>  Prolog\u2019s search method for solving\n  problems.  Graph searching exploiting Prolog\u2019s built-in\n  search mechanisms.\n\n<p></p></li>\n<li><b>Difference structures.</b>  Difference lists: introduction and\n  application to example programs.\n\n<p></p></li>\n<li><b>Building on Prolog.</b>  How particular limitations of Prolog\n  programs can be addressed by techniques such as Constraint Logic\n  Programming (CLP) and tabled resolution.\n\n<p></p></li>\n\n\n<a name=\"SECTION030210300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to write programs in Prolog using techniques such as\n  accumulators and difference structures;\n\n<p></p></li>\n<li>know how to model the backtracking behaviour of program\n  execution;\n\n<p></p></li>\n<li>appreciate the unique perspective Prolog gives to problem\n  solving and algorithm design;\n\n<p></p></li>\n<li>understand how larger programs can be created using the basic\n  programming techniques used in this course.\n\n<p></p></li>\n\n\n<a name=\"SECTION030210400000000000000\">Recommended reading</a>\n\n* Bratko, I. (2001). <i>PROLOG programming for artificial intelligence</i>. Addison-Wesley (3rd or 4th\u00a0ed.).\n<br/>Sterling, L. &amp; Shapiro, E. (1994). <i>The art of Prolog</i>. MIT Press (2nd\u00a0ed.).\n\nFurther reading:\n\nO\u2019Keefe, R. (1990). <i>The craft of Prolog</i>. MIT Press. [This book is beyond the scope of this course, but it is very instructive. If you understand its contents, you\u2019re more than prepared for the examination.]\n\n\n", "course_name": "Prolog", "course_code": "Prolog", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/Prolog", "lecturers": ["arb33", "acr31"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "SWEng": {"supervisions": 2, "lectures": 6, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareEngineering.html", "description": "\n\n\n<a name=\"SECTION030211100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030211200000000000000\">Lectures</a>\n\n\n<li><b>The software crisis.</b>  \nExamples of large-scale project failure, such as the London Ambulance \nService system and the NHS National Programme for IT. Intrinsic \ndifficulties with software.\n\n<p></p></li>\n<li><b>The software life cycle.</b>\nGetting the requirements right; requirements analysis methods; modular \ndesign; the role of prototyping; the waterfall, spiral and evolutionary \nmodels.\n\n<p></p></li>\n<li><b>Critical systems.</b>\nExamples of catastrophic failure; particular problems with real-time\nsystems; usability and human error; verification and validation.\n\n<p></p></li>\n<li><b>Quality assurance.</b>\nThe contribution of reviews and testing; reliability growth models; software\nmaintenance and configuration management; life-cycle costs.\n\n<p></p></li>\n<li><b>Tools.</b>\nThe effect of high-level languages; object-oriented systems and \nobject reuse; an overview of formal methods with some application \nexamples; project planning tools; automated testing tools.\n\n<p></p></li>\n<li><b>Guest lecture.</b>\nA guest lecture from an industry speaker about the realities of\nmanaging software development in a commercial environment.\n\n<p></p></li>\n\n\n<a name=\"SECTION030211300000000000000\">Objectives</a>\n\nAt the end of the course students should know how writing programs\nwith tough assurance targets, in large teams, or both, differs from\nthe programming exercises they have engaged in so far. They should\nappreciate the waterfall, spiral and evolutionary models of software\ndevelopment and be able to explain which kinds of software project\nmight profitably use them. They should appreciate the value of other\ntools and the difference between incidental and intrinsic complexity.\nThey should understand the software development life cycle and its\nbasic economics. They should be prepared for the organizational\naspects of their Part\u00a0IB group project.\n\n\n<a name=\"SECTION030211400000000000000\">Recommended reading</a>\n\n* Pressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>Leveson, N. (1994). <i>Safeware</i>. Addison-Wesley.\n<br/>Maguire, S. (1993). <i>Writing solid code</i>. Microsoft Press.\n\nFurther reading:\n\nBrooks, F.P. (1975). <i>The mythical man month</i>. Addison-Wesley.\n<br/>Reason, J. (2008). <i>The human contribution</i>. Ashgate Publishing.\n<br/>Leveson, N. (2008). <i>System safety engineering: back to the future</i>, available at\n<br/><a href=\"http://sunnyday.mit.edu/book2.pdf\" name=\"tex2html9\"><tt>http://sunnyday.mit.edu/book2.pdf</tt></a>\n<br/>Neumann, P. (1994). <i>Computer-related risks</i>. ACM Press.\n<br/><i>Report of the inquiry into the London Ambulance Service</i> (SW Thames RHA, 40 Eastbourne Terrace, London W2 3QR, February 1993).\n<br/><a href=\"http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html\" name=\"tex2html10\"><tt>http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html</tt></a>\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapters 25 and 26). Wiley. Alternatively see 2001 edition, Chapters 22 and 23, available at\n<br/><a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html11\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n\n", "course_name": "Software Engineering", "course_code": "SWEng", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/SWEng", "lecturers": ["rja14"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "UnixTools": {"supervisions": 1, "lectures": 10, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION030212100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030212200000000000000\">Lectures</a>\n\n<li><b>Unix concepts.</b> Brief review of Unix history and design\n  philosophy, documentation, terminals, inter-process communication\n  mechanisms and conventions, shell, command-line arguments,\n  environment variables, file descriptors.\n\n<p></p></li>\n<li><b>Shell basics.</b> Program invocation, redirecting standard I/O,\n  pipes, file-system navigation, argument expansion, quoting, job\n  control, signals, process groups, variables, locale.\n\n<p></p></li>\n<li><b>Shell script programming and configuration.</b> Efficient\n  command entry with history and alias functions. Scripts, plain-text\n  file formats, control structures, functions. Customizing user\n  environments. Basics of <span class=\"textit\">X Window System</span> configuration. Some\n  notes on PWF Linux.\n\n<p></p></li>\n<li><b>Common tools.</b> Overview of common text, shell, and network\n  utilities and their most frequently used options, including sed,\n  grep, chmod, find, ssh, rsync, packaging and compression tools.\n\n<p></p></li>\n<li><b>Revision control systems.</b> diff, patch, RCS, Subversion, git.\n\n<p></p></li>\n<li><b>Software development tools.</b> C compiler, linker and\n  debugger, makefiles.\n\n<p></p></li>\n<li><b>Perl.</b> Introduction to a powerful scripting and text\n  manipulation language. [2\u00a0lectures]\n\n<p></p></li>\n<li><b><span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span>.</b> Typesetting basics, introduction to the most\n  popular tool for scientific document formatting.\n\n<p></p></li>\n<li><b>Number crunching and data visualization.</b> Use of MATLAB on\n  PWF machines.\n\n<p></p></li>\n\n\n<a name=\"SECTION030212300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be confident in performing routine user tasks on a POSIX system,\n  understand command-line user-interface conventions and know how to\n  find more detailed documentation;\n\n<p></p></li>\n<li>appreciate how a range of simple tools can be combined with\n  little effort in pipes and scripts to perform a large variety of\n  tasks;\n\n<p></p></li>\n<li>be familiar with the most common tools, file formats and\n  configuration practices;\n\n<p></p></li>\n<li>be able to understand, write, and maintain shell scripts and\n  makefiles;\n\n<p></p></li>\n<li>appreciate how using revision control systems and fully\n  automated build processes help to maintain reproducibility and\n  audit trails during software development;\n\n<p></p></li>\n<li>know enough about basic development tools to be able to install\n  and modify C source code;\n\n<p></p></li>\n<li>have gained experience in using Perl, <span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span> and MATLAB.\n\n<p></p></li>\n\n\n<a name=\"SECTION030212400000000000000\">Recommended reading</a>\n\n* Lamport, L. (1994). <em><span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span> - a documentation preparation system user\u2019s guide and reference manual</em>. Addison-Wesley (2nd ed.).\n<br/>Robbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th ed.).\n<br/>Schwartz, R.L., Foy, B.D. &amp; Phoenix, T. (2011). <em>Learning Perl</em>. O\u2019Reilly (6th ed.).\n\n\n", "course_name": "Unix Tools", "course_code": "UnixTools", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/UnixTools", "lecturers": ["mgk25"], "year": "1213", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompConstr": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html", "description": "\n\n\n<a name=\"SECTION03032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03032200000000000000\">Lectures</a>\n\n<li><b>Survey of execution mechanisms.</b>\n      The spectrum of interpreters and compilers; compile-time and run-time.\n      Structure of a simple compiler. Java virtual machine (JVM), JIT.\n      Simple run-time structures (stacks).\n      Structure of interpreters for result of each stage of compilation\n      (tokens, tree, bytecode).\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Lexical analysis and syntax analysis.</b>\n      Recall regular expressions and finite state machine acceptors.\n      Lexical analysis: hand-written and machine-generated.\n      Recall context-free grammars.\n      Ambiguity, left- and right-associativity and operator precedence.\n      Parsing algorithms: recursive descent and machine-generated.\n      Abstract syntax tree; expressions, declarations and commands.\n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Simple type-checking.</b>\n      Type of an expression determined by type of subexpressions;\n      inserting coercions.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Translation phase.</b>\n      Translation of expressions, commands and declarations.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Code generation.</b>\n      Typical machine codes.\n      Code generation from intermediate code.\n      Simple peephole optimisation.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Object modules, linkers and run-time system.</b>\n      Resolving external references.\n      Static and dynamic linking.\n      Malloc and system calls.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Non-local variable references.</b>\n      Lambda-calculus as prototype, Landin\u2019s principle of correspondence.\n      Problems with <tt>rec</tt> and class variables.\n      Environments, function values are closures.\n      Static and dynamic binding (scoping).\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Machine implementation of a selection of interesting things.</b>\n      Free variable treatment, static and dynamic chains, ML free variables.\n      Compilation as source-to-source simplification, e.g. closure conversion.\n      Argument passing mechanisms.\n      Objects and inheritance; implementation of methods.\n      Labels, <tt>goto</tt> and exceptions.\n      Dynamic and static typing, polymorphism.\n      Storage allocation, garbage collection.\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Parser Generators.</b>\n      A user-level view of Lex and Yacc.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Parsing theory and practice.</b>\n      Phrase Structured Grammars.\n      Chomsky classification.\n      LL(k) and LR(k) parsing.\n      How tools like Yacc generate parsers, and their error messages.\n[2\u00a0lectures]\n</li>\n\n\n<a name=\"SECTION03032300000000000000\">Objectives</a>\n\nAt the end of the course students should understand the overall\nstructure of a compiler, and will know significant details of a number\nof important techniques commonly used. They will be aware of the way\nin which language features raise challenges for compiler builders.\n\n\n<a name=\"SECTION03032400000000000000\">Recommended reading</a>\n\n* Appel, A. (1997). <em>Modern compiler implementation in Java/C/ML</em> (3 editions). Cambridge University Press.\n<br/>Aho, A.V., Sethi, R. &amp; Ullman, J.D. (2007). <em>Compilers: principles, techniques and tools</em>. Addison-Wesley (2nd ed.).\n<br/>Bennett, J.P. (1990). <em>Introduction to compiling techniques: a first course using ANSI C, LEX and YACC</em>. McGraw-Hill.\n<br/>Bornat, R. (1979). <em>Understanding and writing compilers</em>. Macmillan.\n<br/>Fischer, C.N. &amp; LeBlanc, J. Jr (1988). <em>Crafting a compiler</em>. Benjamin/Cummings.\n<br/>Watson, D. (1989). <em>High-level languages and their compilers</em>. Addison-Wesley.\n\n\n\n", "course_name": "Compiler Construction", "course_code": "CompConstr", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CompConstr", "lecturers": ["tgg22"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompTheory": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html", "description": "\n\n\n<a name=\"SECTION03033100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03033200000000000000\">Lectures</a>\n\n<li><b>Introduction: algorithmically undecidable problems.</b>\n  Decision problems. The informal notion of algorithm, or effective\n  procedure. Examples of algorithmically undecidable problems. [1\n  lecture]\n\n<p></p></li>\n<li><b>Register machines.</b> Definition and examples; graphical\n  notation.  Register machine computable functions.  Doing arithmetic\n  with register machines. [1 lecture]\n\n<p></p></li>\n<li><b>Universal register machine.</b>  Natural number encoding of\n  pairs and lists.  Coding register machine programs as numbers.\n  Specification and implementation of a universal register\n  machine. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Undecidability of the halting problem.</b>  Statement and\n  proof. Example of an uncomputable partial function. Decidable sets\n  of numbers; examples of undecidable sets of numbers.  [1 lecture]\n\n<p></p></li>\n<li><b>Turing machines.</b> Informal description.  Definition and\n  examples.  Turing computable functions. Equivalence of register\n  machine computability and Turing computability. The Church-Turing\n  Thesis. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Primitive and partial recursive functions.</b> Definition and\n  examples.  Existence of a recursive, but not primitive recursive\n  function. A partial function is partial recursive if and only if it\n  is computable. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>lambda-Calculus.</b> Alpha and beta conversion.\n  Normalization. Encoding data. Writing recursive functions in the\n  lambda-calculus. The relationship between computable functions\n  and lambda-definable functions. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03033300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with the register machine, Turing machine and\n  lambda-calculus models of computability;\n\n<p></p></li>\n<li>understand the notion of coding programs as data, and of a universal\n  machine;\n\n<p></p></li>\n<li>be able to use diagonalisation to prove the undecidability of\n  the Halting Problem;\n\n<p></p></li>\n<li>understand the mathematical notion of partial recursive function\n  and its relationship to computability.\n\n<p></p></li>\n\n\n<a name=\"SECTION03033400000000000000\">Recommended reading</a>\n\n* Hopcroft, J.E., Motwani, R. &amp; Ullman, J.D. (2001). <em>Introduction to automata theory, languages, and computation</em>. Addison-Wesley (2nd ed.). \n<br/>* Hindley, J.R. &amp; Seldin, J.P. (2008). <em>Lambda-calculus and combinators, an introduction</em>. Cambridge University Press (2nd ed.).\n<br/>Cutland, N.J. (1980). <em>Computability: an introduction to recursive function theory</em>. Cambridge University Press.\n<br/>Davis, M.D., Sigal, R. &amp; Weyuker, E.J. (1994). <em>Computability, complexity and languages</em>. Academic Press (2nd ed.).\n<br/>Sudkamp, T.A. (2005). <em>Languages and machines</em>. Addison-Wesley (3rd ed.).\n\n\n", "course_name": "Computation Theory", "course_code": "CompTheory", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CompTheory", "lecturers": ["amp12"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompNet": {"supervisions": 6, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html", "description": "\n\n\n<a name=\"SECTION03035100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03035200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>\r\nOverview of networking using the Internet as an example. LANs and\r\nWANs. OSI reference model, Internet TCP/IP Protocol Stack.  Client/server\r\nparadigm, circuit-switching, packet-switching, Internet structure,\r\nnetworking delays and packet loss. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Link layer and local area networks.</b>\r\nLink layer services, error detection and correction, Multiple Access\r\nProtocols, link layer addressing, Ethernet, hubs and switches,\r\nPoint-to-Point Protocol. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Wireless and mobile networks.</b>\r\nWireless links and network characteristics, Wi-Fi: IEEE 802.11 wireless\r\nLANs, mobility management and mobile IP. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer addressing.</b>\r\nNetwork layer services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\r\n [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer routing.</b>\r\nRouting and forwarding, routing algorithms, routing in the Internet,\r\nRIP, OSPF, BGP, multicast. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Transport layer.</b>\r\nService models, multiplexing/demultiplexing, connection-less transport\r\n(UDP), principles of reliable data transfer, connection-oriented\r\ntransport (TCP), TCP congestion control, securing TCP (SSL), TCP variants.\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Application layer.</b>\r\nService requirements, WWW, HTTP, electronic mail, Domain Name System,\r\nP2P, socket programming API. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Multimedia networking.</b>\r\nNetworked multimedia applications, best-effort service and multimedia\r\ndelivery requirements, multimedia protocols (RTSP, RTP, RTCP, SIP),\r\ncontent distribution networks.  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Datacenter Networking</b>\r\nDatacenter introductions, architecting a datacenter, datacenter network\nand workload issues, datacenter transport issues. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03035300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse a communication system by separating out the\r\ndifferent functions provided by the network;\n\n<p></p></li>\n<li>understand that there are fundamental limits to any communications \r\nsystem;\n\n<p></p></li>\n<li>understand the general principles behind multiplexing, addressing,\r\nrouting, reliable transmission and other stateful protocols as well as\r\nspecific examples of each;\n\n<p></p></li>\n<li>understand what FEC is and how CRCs work;\n\n<p></p></li>\n<li>be able to compare communications systems in how they solve\r\nsimilar problems;\n\n<p></p></li>\n<li>have an informed view of both the internal workings of the\r\n  Internet and of a number of common Internet applications and\r\n  protocols.\n\n<p></p></li>\n\n\n<a name=\"SECTION03035400000000000000\">Recommended reading</a>\n\n* Peterson, L.L. &amp; Davie, B.S. (2011). <em>Computer networks: a systems approach</em>. Morgan Kaufmann (5th ed.). ISBN 9780123850591\n<br/>Kurose, J.F. &amp; Ross, K.W. (2009). <em>Computer networking: a top-down approach</em>. Addison-Wesley (5th ed.).\n<br/>Comer, D. &amp; Stevens, D. (2005). <em>Internetworking with TCP-IP, vol. </em>1<em> and </em>2. Prentice\u00a0Hall (5th ed.).\n<br/>Stevens, W.R., Fenner, B. &amp; Rudoff, A.M. (2003). <em>UNIX network programming, Vol.I: The sockets networking API</em>. Prentice\u00a0Hall (3rd ed.).\r\n\n\n", "course_name": "Computer Networking", "course_code": "CompNet", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/CompNet", "lecturers": ["awm22"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "Databases": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "\n\n\n<a name=\"SECTION03036100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03036200000000000000\">Lectures</a>\n\n\n<li><b>Introduction.</b>\nWhat is a database system? \nDatabase systems are more than just a collection of data. \nThree level architecture. \nOnLine Transaction Processing (OLTP) <span class=\"textit\">versus</span> \nOnLine Analytic Processing (OLAP). \n\n<p></p></li>\n<li><b>The relational data model.</b> \nRelations are sets of records. \nRepresenting entities and relationships as relations. \nQueries as derived relations. \nRelations are the basis of SQL (but note the use of multi-sets). \n\n<p></p></li>\n<li><b>Entity-Relationship (E/R) modelling.</b>\nA bit of set theory. \nEntities have attributes. \nRelations have <em>arity</em>. \nDatabase design and data modelling. \n\n<p></p></li>\n<li><b>Relational algebra and relational calculus.</b>\nRelational algebra as an abstract query language. \nCore operations - selection, projection, product, renaming, and joins. \nRelational calculus as an abstract query language \n that uses notation from set theory. \nEquivalence with relational algebra. \n\n<p></p></li>\n<li><b>SQL and integrity constraints.</b>\nAn overview of the core of SQL. \nSQL has constructs taken from both the relational algebra\n and the relational calculus. \nIntegrity constraints as special queries, often required to yield a null result. \n\n<p></p></li>\n<li><b>Case Study - Cancer registry for the NHS - challenges.</b> ECRIC is \na cancer registry, recording details about all tumours in people in the \nEast of England. This data is particularly sensitive, and its use is \nstrictly controlled. The lecture focusses on the challenges of scaling up \nthe registration system to cover all cancer patients in England, while \nstill maintaining the long term accuracy and continuity of the data set.\n\n<p></p></li>\n<li><b>Schema refinement I.</b> \nThe evils of redundancy. \nThe benefits of redundancy. \nFunctional dependencies (FDs) as a formal means of investigating\n redundancy. \nRelational decomposition. \nArmstrong\u2019s axioms and Heath\u2019s Rule. \n\n<p></p></li>\n<li><b>Schema refinement II and Normal Forms.</b> \nSchema normalisation. \nFirst and Second normal form.  \nThird normal form and Boyce-Codd normal form. \nMulti-valued dependencies (MVDs) and lossless-join decomposition. \nFourth normal form. \n\n<p></p></li>\n<li><b>Schema refinement III and advanced design.</b> \nGeneral Decomposition Method (GDM). Decomposition examples.\nGDM always preserves lossless-join decomposition. \nGDM may not preserve functional dependencies.\nWeak entity sets. Ternary or multiple binary relationships?\n\n<p></p></li>\n<li><b>On-line Analytical Processing (OLAP).</b>  \nWhen to forget about data normalisation. \nBeware of buzz-words and the Data Warehouse Death March. \nMore on OLTP <span class=\"textit\">versus</span> OLAP. \nWhat is a <em>data cube</em>? \nData modelling for data warehouses: <em>star schema</em>. \n\n<p></p></li>\n<li><b>Case Study - Cancer registry for the NHS - experiences.</b>\nThe extension of ECRIC to cover all of England requires the integration of data from seven other regions, each of which has developed its own database schema.\nJem Rashbass has a long track record in NHS IT, and is now CEO of ECRIC, making him the DB customer.\nHe will explain what\u2019s needed and why - some of the existing challenges and future opportunities.  \nThe session will close with an open forum in which the DBA of the now national level Cancer Registry DBMS will join Jem.\n\n<p></p></li>\n<li><b>XML as a data exchange format.</b> \nWhat is XML? \nXML can be used to share data between proprietary relational databases. \nXML-based databases? \n\n<p></p></li>\n\n\n<a name=\"SECTION03036300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios;\n\n<p></p></li>\n<li>know how to convert entity-relationship diagrams to relational \ndatabase schemas in the standard Normal Forms;\n\n<p></p></li>\n<li>be able to program simple database applications in SQL;\n\n<p></p></li>\n<li>understand the basic theory of the relational model and both its\nstrengths and weaknesses;\n\n<p></p></li>\n<li>be familiar with various recent trends in the database area.\n\n<p></p></li>\n\n\n<a name=\"SECTION03036400000000000000\">Recommended reading</a>\n\n* Silberschatz, A., Korth, H.F. &amp; Sudarshan, S. (2002). <em>Database system concepts</em>. McGraw-Hill (4th ed.).\n<br/>Ullman, J. &amp; Widom, J. (1997). <em>A first course in database systems</em>. Prentice Hall.\n<br/>Date, C.J. (2004). <em>An introduction to database systems</em>. Addison-Wesley (8th ed.).\n<br/>Miszczyk, J. and others (1998). <em>Mastering data warehousing functions</em>. (IBM Redbook DB2/400) Chapters 1 &amp; 2 only.  <a href=\"http://www.wminformatica.com/PDFs/DB2400-Mastering Data Warehousing.pdf\" name=\"tex2html14\"><tt>http://www.wminformatica.com/PDFs/DB2400-Mastering Data Warehousing.pdf</tt></a>\n<br/>Garcia-Molina, H. <em>Data warehousing and OLAP</em>. Stanford University. <tt><a href=\"http://www.cs.uh.edu/~ceick/6340/dw-olap.ppt\" name=\"tex2html13\">http://www.cs.uh.edu/~ceick/6340/dw-olap.ppt</a></tt>\n\n", "course_name": "Databases", "course_code": "Databases", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/Databases", "lecturers": ["tgg22"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "SecurityI": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SecurityI.html", "description": "\n\n\n<a name=\"SECTION03034100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03034200000000000000\">Lectures</a>\n\n<li><b>Cryptography.</b> Introduction, terminology, finite rings and\n  fields, modular arithmetic,\n  GF(2^n),\n  pseudo-random functions and permutations, semantic security.\n\n<p></p></li>\n<li><b>Classic ciphers.</b> Vigen\u00e9re, perfect secrecy, Vernam,\n  computational security, Kerckhoffs\u2019 principle, random bit sources,\n  attacking linear-congruential RNGs and LFSRs.\n\n<p></p></li>\n<li><b>Block ciphers.</b> SP networks, Feistel/Luby-Rackoff structure,\n  DES, AES, modes of operation, message authentication.\n\n<p></p></li>\n<li><b>Secure hash functions.</b> One-way functions, collision\n  resistance, Merkle-Damg\u00e5rd construction, padding, birthday\n  problem, MD5, SHA, HMAC, stream authentication, Merkle tree,\n  Lamport one-time signatures.\n\n<p></p></li>\n<li><b>Asymmetric cryptography.</b> Key-management problem,\n  signatures, certificates, PKI, discrete-logarithm problem,\n  Diffie-Hellman key exchange, ElGamal encryption and signature,\n  hybrid cryptography.\n\n<p></p></li>\n<li><b>Entity authentication.</b> Passwords, trusted path, phishing,\n  CAPTCHA. Authentication protocols: one-way and challenge-response\n  protocols, Needham-Schroeder, protocol failure examples.\n\n<p></p></li>\n<li><b>Access control.</b> Discretionary access control matrix, DAC in\n  POSIX and Windows, elevated rights and setuid bits, capabilities,\n  mandatory access control, covert channels, Clark-Wilson integrity.\n\n<p></p></li>\n<li><b>Operating system security.</b> Trusted computing base, domain\n  separation, reference mediation, residual information protection.\n\n<p></p></li>\n<li><b>Software security.</b> Malicious software, viruses. Common\n  implementation vulnerabilities: buffer overflows, integer overflows,\n  meta characters, syntax incompatibilities, race conditions,\n  unchecked values, side channels. [2 lectures]\n\n<p></p></li>\n<li><b>Network security.</b> Vulnerabilities of TCP/IP, DNS, Firewalls, VPNs,\n  HTTP authentication, cookies, cross-site scripting, browser\n  sandboxes. [2 lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03034300000000000000\">Objectives</a>\n\nBy the end of the course students should \n\n\n<li>be familiar with core security terms and concepts;\n\n<p></p></li>\n<li>have a basic understanding of some commonly used attack\n  techniques and protection mechanisms;\n\n<p></p></li>\n<li>have gained basic insight into aspects of modern cryptography\n  and its applications;\n\n<p></p></li>\n<li>appreciate the range of meanings that \u201csecurity\u201d has across\n  different applications.\n\n<p></p></li>\n\n\n<a name=\"SECTION03034400000000000000\">Recommended reading</a>\n\n* Paar, Ch. &amp; Pelzl, J. (2010). <em>Understanding cryptography</em>. Springer.\n<br/>Gollmann, D. (2010). <em>Computer security</em>. Wiley (3rd ed.).\n\n\n", "course_name": "Security\u00a0I", "course_code": "SecurityI", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/SecurityI", "lecturers": ["mgk25"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "Semantics": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Semantics.html", "description": "\n\n\n<a name=\"SECTION03031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03031200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Transition systems.  \n  The idea of structural operational semantics. \n  Transition semantics of a simple imperative language. \n  Language design options. \n[2 lectures]\n\n<p></p></li>\n<li><b>Types.</b>  Introduction to formal type systems.\n  Typing for the simple imperative language.\n  Statements of desirable properties.\n[2 lectures]\n\n<p></p></li>\n<li><b>Induction.</b>  Review of mathematical induction. Abstract\n  syntax trees and structural induction. Rule-based inductive\n  definitions and proofs. Proofs of type safety\n  properties. \n[2 lectures]\n\n<p></p></li>\n<li><b>Functions.</b>  Call-by-name and call-by-value function\n application, semantics and typing. Local recursive\n definitions. \n[2 lectures]\n\n<p></p></li>\n<li><b>Data.</b> Semantics and typing for products, sums, records,\nreferences.\n[1 lecture]\n\n<p></p></li>\n<li><b>Subtyping.</b>  Record subtyping and simple object encoding.\n[1 lecture]\n\n<p></p></li>\n<li><b>Semantic equivalence.</b>  Semantic equivalence of phrases in a\nsimple imperative language, including the congruence property.\nExamples of equivalence and non-equivalence.\n[1 lecture]\n\n<p></p></li>\n<li><b>Concurrency.</b>  Shared variable interleaving. Semantics for\nsimple mutexes; a serializability property.\n[1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION03031300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with rule-based presentations of the operational\n  semantics and type systems for some simple imperative, functional\n  and interactive program constructs;\n\n<p></p></li>\n<li>be able to prove properties of an operational semantics using\n  various forms of induction (mathematical, structural, and\n  rule-based);\n\n<p></p></li>\n<li>be familiar with some operationally-based notions of semantic\n  equivalence of program phrases and their basic properties.\n\n<p></p></li>\n\n\n<a name=\"SECTION03031400000000000000\">Recommended reading</a>\n\n* Pierce, B.C. (2002). <em>Types and programming languages</em>. MIT Press.\n<br/>Hennessy, M. (1990). <em>The semantics of programming languages</em>. Wiley. Out of print, but available on the web at <a href=\"http://www.scss.tcd.ie/Matthew.Hennessy/slexternal/reading.php\" name=\"tex2html12\"><tt>http://www.scss.tcd.ie/Matthew.Hennessy/slexternal/reading.php</tt></a>\n<br/>Winskel, G. (1993). <em>The formal semantics of programming languages</em>. MIT Press.\n\n\n", "course_name": "Semantics of Programming Languages", "course_code": "Semantics", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/Semantics", "lecturers": ["ss368"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "ArtIntI": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligenceI.html", "description": "\n\n\n<a name=\"SECTION03041100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03041200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b> Alternate ways of thinking about\n  AI. <span class=\"textit\">Agents</span> as a unifying view of AI systems. The basic\n  structure of an agent. Interaction of an agent with the\n  environment. Assessment of agents. What does this course cover, and\n  what is left out?  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search I.</b> How can search serve as a fundamental\n  paradigm for intelligent problem-solving? Simple, <span class=\"textit\">uninformed\n  search</span> algorithms. Tree search and graph search. More\n  sophisticated <span class=\"textit\">heuristic search</span> algorithms. The\n  A* algorithm and its properties. Improving memory\n  efficiency: the IDA* and recursive best first search\n  algorithms. Local search and gradient descent. \n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Search II.</b> Search in an adversarial\n  environment. Computer game playing. The minimax algorithm and its\n  shortcomings. Improving minimax using alpha-beta pruning.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Constraint satisfaction problems (CSPs).</b> Standardising\n  search problems to a common format. The backtracking algorithm for\n  CSPs.  Heuristics for improving the search for a solution. Forward\n  checking, constraint propagation and arc consistency. Backtracking,\n  backjumping using Gaschnig\u2019s algorithm, graph-based backjumping.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning I.</b> How can we\n  represent and deal with commonsense knowledge and other forms of\n  knowledge? Semantic networks, frames and rules. How can we use\n  inference in conjunction with a knowledge representation scheme to\n  perform reasoning about the world and thereby to solve problems?\n  Inheritance, forward and backward chaining. [1\u00a0lectures]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning II.</b> Knowledge\n  representation and reasoning using first order logic. The frame,\n  qualification and ramification problems.  The situation\n  calculus. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Planning.</b> Methods for planning in advance how to solve a\n  problem. The STRIPS language. Achieving preconditions, backtracking\n  and fixing threats by promotion or demotion: the partial-order\n  planning algorithm. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Learning.</b> A brief introduction to supervised learning from\n  examples. Learning as fitting a curve to data. The\n  perceptron. Learning by gradient descent. Multilayer perceptrons and\n  the backpropagation algorithm. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03041300000000000000\">Objectives</a>\n\nAt the end of the course students should:\n\n\n<li>appreciate the distinction between the popular view of the field\nand the actual research results;\n\n<p></p></li>\n<li>appreciate the fact that the computational complexity of most AI\n  problems requires us regularly to deal with approximate techniques;\n\n<p></p></li>\n<li>appreciate different perspectives on what the problems of\nartificial intelligence are and how different approaches are\njustified;\n\n<p></p></li>\n<li>be able to design basic problem solving methods based on\n  AI-based search, knowledge representation, reasoning, planning, and\n  learning algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03041400000000000000\">Recommended reading</a>\n\nThe recommended text is:\n\n* Russell, S. &amp; Norvig, P. (2010). <em>Artificial intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd ed.).\n<br/>There are many good books available on artificial intelligence; one \nalternative is:\n\nPoole, D. L. &amp; Mackworth, A. K. (2010). <em>Artificial intelligence: foundations of computational agents</em>.  Cambridge University Press.\n\nFor some of the material you might find it useful to consult more \nspecialised texts, in particular:\n\nDechter, R. (2003). <span class=\"textit\">Constraint processing</span>. Morgan Kaufmann.\n<br/>Cawsey, A. (1998). <em>The essence of artificial intelligence</em>. Prentice\u00a0Hall.\n<br/>Ghallab, M., Nau, D. &amp; Traverso, P. (2004). <span class=\"textit\">Automated planning: theory and practice</span>. Morgan Kaufmann.\n<br/>Bishop, C.M. (2006). <em>Pattern recognition and machine learning</em>. Springer.\n<br/>\n", "course_name": "Artificial Intelligence\u00a0I", "course_code": "ArtIntI", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/ArtIntI", "lecturers": ["sbh11"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Complexity": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Complexity.html", "description": "\n\n\n<a name=\"SECTION03043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03043200000000000000\">Lectures</a>\n\n<li><b>Algorithms and problems.</b>\nComplexity of algorithms and of problems.  Lower and upper bounds.\nExamples: sorting and travelling salesman.\n\n<p></p></li>\n<li><b>Time and space.</b>\nModels of computation and measures of complexity.  Time and space\ncomplexity on a Turing machine. Decidability and complexity.\n\n<p></p></li>\n<li><b>Time complexity.</b>\nTime complexity classes.  Polynomial time problems and algorithms.  P\nand NP. \n\n<p></p></li>\n<li><b>Non-determinism.</b>\nNon-deterministic machines.  The class NP redefined.  Non-deterministic\nalgorithms for reachability and satisfiability.\n\n<p></p></li>\n<li><b>NP-completeness.</b>\nReductions and completeness.  NP-completeness of satisfiability.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nGraph-theoretic problems.  Hamiltonian cycle and clique.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nSets, numbers and scheduling.  Matching, set covering and bin packing.\n\n<p></p></li>\n<li><b>coNP.</b>\nValidity of boolean formulae and its\ncompleteness.  NP<span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$\\cap$\" border=\"0\" height=\"21\" src=\"img3.png\" width=\"17\"/></span>coNP.  Primality and factorisation.\n\n<p></p></li>\n<li><b>Cryptographic complexity.</b>\nOne-way functions.  The class UP.\n\n<p></p></li>\n<li><b>Space complexity.</b>\nDeterministic and non-deterministic space complexity classes.  The\nreachability method.  Savitch\u2019s theorem.\n\n<p></p></li>\n<li><b>Hierarchy.</b>\nThe time and space hierarchy theorems and complete problems.\n\n<p></p></li>\n<li><b>Descriptive complexity.</b>\nLogics capturing complexity classes.  Fagin\u2019s theorem.\n\n<p></p></li>\n\n\n<a name=\"SECTION03043300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse practical problems and classify them\naccording to their complexity;\n\n<p></p></li>\n<li>be familiar with the phenomenon of NP-completeness, and be able\nto identify problems that are NP-complete;\n\n<p></p></li>\n<li>be aware of a variety of complexity classes and their\ninterrelationships;\n\n<p></p></li>\n<li>understand the role of complexity analysis in cryptography.\n\n<p></p></li>\n\n\n<a name=\"SECTION03043400000000000000\">Recommended reading</a>\n\n* Papadimitriou, Ch.H. (1994).  <em>Computational complexity</em>. Addison-Wesley.\n<br/>Goldreich, O. (2010). <em>P, NP, and NP-Completeness: the basics of \ncomputational complexity</em>. Cambridge University Press.\nSipser, M. (1997). <em>Introduction to the theory of computation</em>. PWS.\n\n\n", "course_name": "Complexity Theory", "course_code": "Complexity", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/Complexity", "lecturers": ["ad260"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ConceptsPL": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConceptsinProgrammingLanguages.html", "description": "\n\n\n<a name=\"SECTION03042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03042200000000000000\">Lectures</a>\n\n<li><b>Introduction, motivation, and overview.</b>\nWhat is a programming language?  Application domains in language \ndesign.  Program execution models.  Theoretical foundations. \nLanguage standardization.  History.\n\n<p></p></li>\n<li><b>The big ancestors: Fortran, Lisp, Algol, Pascal</b>\nKey ideas: procedural (Fortran), declarative (Lisp), block structured\n(Algol, Pascal).\nExecution models (abstract machines), storage allocation (static, stack, heap),\ndata types, procedures and parameter passing, arrays and pointers,\nstrict and lazy evaluation, garbage collection.  Programs as data (Lisp).\n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Object-oriented languages -- Concepts and origins:\nSimula\u00a0(1964-67) and Smalltalk\u00a0(1971-80).</b>\nDynamic lookup.  Abstraction.  Subtyping.  Inheritance.  Object \nmodels.\n\n<p></p></li>\n<li><b>Languages for parallel processing</b>\nShared-memory concurrency with spawn/sync (OpenMP, Cilk, X10).\nDistributed-memory models (the actor model, Erlang).\n\n<p></p></li>\n<li><b>Types.</b>\nTypes in programming languages.  Type systems.  Type safety.  \nType checking and type inference.  Polymorphism.  Overloading.  \nType equivalence. \n\n<p></p></li>\n<li><b>Data abstraction and modularity: SML Modules\u00a0(1984-97).</b>\nInformation hiding.  Modularity.  Signatures, structures, and functors. \nSharing.\n\n<p></p></li>\n<li><b>Scala: a principled feature-rich language.</b>\nProcedural and declarative aspects.  Blocks and functions.  Classes \nand objects.  Generic types and methods.  Variance annotations.  \nMixin-class composition.\n</li>\n\n\n<a name=\"SECTION03042300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with several \nlanguage paradigms and how they relate to different application\n   domains;\n\n<p></p></li>\n<li>understand the design space of programming languages, including\n   concepts and constructs from past \nlanguages as well as those that may be used \nin the future;\n\n<p></p></li>\n<li>develop a critical understanding of the programming languages that\n   we use by being able to identify and compare the same concept as it\n   appears in different languages.\n\n<p></p></li>\n\n\n<a name=\"SECTION03042400000000000000\">Recommended reading</a>\n\nBooks:\n\n* Mitchell, J.C. (2003). <em>Concepts in programming languages</em>. Cambridge University Press.\n<br/>* Scott, M.L. (2009). <em>Programming language pragmatics</em>.  Morgan Kaufmann.\nOdersky, M. (2008). <em>Scala by example</em>. Programming Methods Laboratory, EPFL.\n<br/>Pratt, T.W. &amp; Zelkowitz, M.V. (2001). <em>Programming languages: design and implementation</em>.  Prentice Hall.\n\nPapers:\n\nKay, A.C. (1993).  \n  The early history of Smalltalk.  \n  <em>ACM SIGPLAN Notices</em>, Vol.\u00a028, No.\u00a03.\n<br/>Kernighan, B. (1981).  \n  Why Pascal is not my favorite programming language.  \n  AT&amp;T Bell Laboratories.  \n  <em>Computing Science Technical Report</em> No.\u00a0100.\n<br/>Koenig, A. (1994).  \n  An anecdote about ML type inference.  \n  <em>USENIX Symposium on Very High Level Languages</em>.\n<br/>Landin, P.J. (1966).\n  The next 700 programming languages.\n  <em>Communications of the ACM</em>, Vol.\u00a09, Issue\u00a03.\n<br/>Odersky, M. <em>et al.</em> (2006).\n  An overview of the Scala programming language.\n  <em>Technical Report LAMP-REPORT-2006-001</em>, Second Edition.\n<br/>McCarthy, J. (1960).  \n  Recursive functions of symbolic expressions and their computation \n  by machine.  \n  <em>Communications of the ACM</em>, 3(4):184-195.\n<br/>Stroustrup, B. (1991). \n  What is Object-Oriented Programming?  (1991 revised version). \n  <em>Proceedings\u00a01st European Software Festival</em>.\n\n\n", "course_name": "Concepts in Programming Languages", "course_code": "ConceptsPL", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/ConceptsPL", "lecturers": ["mpf23"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "EconLaw": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsandLaw.html", "description": "\n\n\n<a name=\"SECTION03044100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03044200000000000000\">Lectures</a>\n\n<li><b>Game theory.</b> The choice between cooperation and conflict. \nPrisoners\u2019 Dilemma; Nash equilibrium; hawk-dove; iterated games; \nevolution of strategies; application to biology and computer science.\n\n<p></p></li>\n<li><b>Classical economics.</b> Brief history of economics. \nDefinitions: preference, utility, choice and budget. Pareto\nefficiency; the discriminating monopolist. Welfare and the Arrow\ntheorem.\n\n<p></p></li>\n<li><b>Classical economics continued.</b> Supply and demand; \nelasticity; utility; the marginalist revolution; competitive\nequilibrium. Trade; monopoly rents; public goods; oligopoly. The\nbusiness cycle.\n\n<p></p></li>\n<li><b>Market failure.</b> Asymmetric information: the market for \nlemons; adverse selection; moral hazard; signalling; and brands.\nTransaction costs and the theory of the firm. Behavioural economics:\nbounded rationality, heuristics and biases.\n\n<p></p></li>\n<li><b>Auctions.</b> English auctions; Dutch auctions; all-pay\nauctions; Vickrey auctions. The winner\u2019s curse. The revenue\nequivalence theorem.  Mechanism design and the combinatorial\nauction. Problems with real auctions. Applicability of auction\nmechanisms in computer science.\n\n<p></p></li>\n<li><b>Principles of law.</b> Contract and tort; copyright and patent; \nbinding actions; liabilities and remedies; competition law; choice of\nlaw and jurisdiction.\n\n<p></p></li>\n<li><b>Law and the Internet.</b> EU directives including distance \nselling, electronic commerce, data protection, electronic signatures \nand copyright; their UK implementation. UK laws that specifically\naffect the Internet, including RIP.\n\n<p></p></li>\n<li><b>Network economics.</b> Real and virtual networks, supply-side \n<em>versus</em> demand-side scale economies, Metcalfe\u2019s law, the dominant firm\nmodel, price discrimination. Regulatory and other public policy issues\nof information goods and services markets.\n\n<p></p></li>\n\n\n<a name=\"SECTION03044300000000000000\">Objectives</a>\n\nAt the end of the course students should have a basic appreciation of\neconomic and legal terminology and arguments. They should understand\nsome of the applications of economic models to systems engineering and\ntheir interest to theoretical computer science. They should also\nunderstand the main constraints that markets and legislation place on\nfirms dealing in information goods and services.\n\n\n<a name=\"SECTION03044400000000000000\">Recommended reading</a>\n\n* Shapiro, C. &amp; Varian, H. (1998). <em>Information rules</em>. Harvard Business School Press.\n<br/>Varian, H. (1999). <em>Intermediate microeconomics - a modern approach</em>. Norton.\n\nFurther reading:\n\nSmith, A. (1776). <i>An inquiry into the nature and causes of the wealth of \nnations</i>, available at\u00a0\u00a0\u00a0\u00a0<a href=\"http://www.econlib.org/LIBRARY/Smith/smWN.html\" name=\"tex2html15\"><tt>http://www.econlib.org/LIBRARY/Smith/smWN.html</tt></a>\n<br/>Poundstone, W. (1992). <i>Prisoner\u2019s dilemma</i>. Anchor Books.\n<br/>Levitt, S.D. &amp; Dubner, S.J. (2005). <i>Freakonomics</i>. Morrow.\n<br/>Seabright, P. (2005). <i>The company of strangers</i>. Princeton.\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapter 7). Wiley.\n<br/>Galbraith, J.K. (1991). <i>A history of economics</i>. Penguin.\n<br/>Lessig L. (2005). <i>Code and other laws of cyberspace v2</i>, available at\n<br/><a href=\"http://www.lessig.org/\" name=\"tex2html16\"><tt>http://www.lessig.org/</tt></a>\n\n", "course_name": "Economics and Law", "course_code": "EconLaw", "course_url": "https://www.cl.cam.ac.uk/teaching/1213/EconLaw", "lecturers": ["rja14"], "year": "1213", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}}