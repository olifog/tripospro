{"DatabasesA": {"supervisions": 3, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "\n\n\n<a name=\"SECTION02025100000000000000\">Aims</a>\n\nThe database world is currently undergoing swift \nand dramatic transformations largely driven by \nInternet-oriented applications and services. \nToday many more options are available to database\napplication developers than in the past and so it \nis becoming increasingly difficult to sort fact \nfrom fiction. \nThe course attempts to cut through the fog with a \npractical approach that emphasises engineering \ntradeoffs that underpin these recent developments\nand also guide our selection of \u201cthe right \ntool for the job.\u201d \n\nThis course covers three approaches. \nFirst, the traditional mainstay of the database industry -- \nthe relational approach -- \nis described with emphasis on eliminating logical redundancy in data. \nThen two representatives of recent trends \nare presented -- graph-oriented and document-oriented databases. \nThe lectures are tightly integrated with the associated \npractical sessions where students gain hands-on experience \nwith all three of these approaches. \n\n\n<a name=\"SECTION02025200000000000000\">Lectures</a>\n\n\n<li><b>Introduction.</b>\nWhat is a database system? \nWhat is a data model? \nA central tradeoff in the choice of data representation: \noptimise for ease of updating or for fast query response. \nOn-Line Transaction Processing (OLTP) \n<span class=\"textit\">versus</span> \nOn-line Analytical Processing (OLAP). \nApplication independent <span class=\"textit\">versus</span> application specific data representations. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Conceptual modeling</b>\nThe Entity-Relationship (ER) approach as an implementation-independent \ntechnique for modeling data. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>The relational model</b>\nImplementing ER models with relational tables. \nRelational algebra and SQL. \nUpdate anomalies caused by logical redundancy. \nMinimise logical redundancy with normalised data representation. \nFunctional dependencies (FDs) as a formal means of investigating redundancy. \nWhat is transitive closure? \nWhy SQL struggles with transitive closure. \n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>The graph-oriented model</b>\nThe NoSQL movement. \nImplementing ER models in a graph-oriented database. \nGraph databases: optimised for computing transitive closure. \nPath-oriented queries. \n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>The document-oriented model</b>\nSemi-structured data (XML, JSON). \nDocument-oriented databases. \nEmbracing data redundancy: representing data \nfor fast, application-specific, access. \nThe CAP principle for distributed database \nrelating Consistency, Availability, and Partition Tolerance. \nIntegration of relational and document-oriented approaches. \n[2\u00a0lectures]\n</li>\n\n\n<a name=\"SECTION02025300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios\n\n<p></p></li>\n<li>know how to convert entity-relationship diagrams to relational- \nand graph-oriented implementations \n\n<p></p></li>\n<li>understand the fundamental tradeoff between the ease of updating data \nand the response time of complex queries \n\n<p></p></li>\n<li>understand that no single data architecture can be used to meet all \ndata management requirements \n\n<p></p></li>\n<li>be familiar with recent trends in the database area.\n\n<p></p></li>\n\n\n<a name=\"SECTION02025400000000000000\">Recommended reading</a>\n\nUllman, J. &amp; Widom, J. (1997) <em>A first course in database systems</em>. Prentice Hall.\n<br/>\n\n", "course_name": "Databases", "course_code": "DatabasesA", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/DatabasesA", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": 4, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "\n\n\n<a name=\"SECTION02023100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02023200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p></p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\nQuine-McCluskey method.\n\n<p></p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p></p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p></p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p></p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p></p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p></p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n  Elimination of redundant states.\n\n<p></p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p></p></li>\n<li><b>Electronics, Devices and Circuits.</b>  Current and voltage,\nresistance, basic circuit theory, the potential divider. Solving non-linear\ncircuits. Materials, semiconductors and the p-n junction, i.e., the diode. n\nand p channel MOSFETs and n-MOSFET logic, e.g., n-MOSFET inverter. Switching\nspeed and power consumption problems in n-MOSFET logic. CMOS logic. Logic\nfamilies. Noise margin. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02023300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p></p></li>\n<li>be able to design and minimise combinational logic;\n\n<p></p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p></p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p></p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p></p></li>\n<li>understand how to use MOSFETs to build digital logic circuits.\n\n<p></p></li>\n<li>understand the effect of finite load capacitance on the performance of digital logic circuits.\n\n<p></p></li>\n\n\n<a name=\"SECTION02023400000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2013). <em>Digital design and computer architecture</em>. Morgan Kaufmann (2nd ed.). The first edition is still relevant.\n<br/>Katz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>Hayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\nBooks for reference:\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>Weste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>Mead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>Crowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>Gibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/DigElec", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMath": {"supervisions": 7, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "\n\n\n<a name=\"SECTION02024100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02024200000000000000\">Lectures</a>\n\n\n<li><b>Proof [5\u00a0lectures].</b>\n<p>Proofs in practice and mathematical jargon. Mathematical statements:\n  implication, bi-implication, universal quantification, conjunction,\n  existential quantification, disjunction, negation.  Logical deduction: proof\n  strategies and patterns, scratch work, logical equivalences.  Proof by\n  contradiction.  Divisibility and congruences.  Fermat\u2019s Little Theorem.\n\n</p><p></p></li>\n<li><b>Numbers [5\u00a0lectures].</b>\n<p>Number systems: natural numbers, integers, rationals, modular integers.  The\n  Division Theorem and Algorithm.  Modular arithmetic.  Sets: membership and\n  comprehension.  The greatest common divisor, and Euclid\u2019s Algorithm and\n  Theorem. The Extended Euclid\u2019s Algorithm and multiplicative inverses in\n  modular arithmetic.  The Diffie-Hellman cryptographic method.  Mathematical\n  induction: Binomial Theorem, Pascal\u2019s Triangle, Fundamental Theorem of\n  Arithmetic, Euclid\u2019s infinity of primes.\n\n</p><p></p></li>\n<li><b>Sets [9\u00a0lectures].</b>\n<p>Extensionality Axiom: subsets and supersets.  Separation Principle:\n  Russell\u2019s Paradox, the empty set.  Powerset Axiom: the powerset Boolean\n  algebra, Venn and Hasse diagrams.  Pairing Axiom: singletons, ordered pairs,\n  products.  Union axiom: big unions, big intersections, disjoint unions.\n  Relations: composition, matrices, directed graphs, preorders and partial\n  orders.  Partial and (total) functions.  Bijections: sections and\n  retractions.  \n  Equivalence relations and set partitions. Calculus of bijections: characteristic (or indicator) functions.  Finite\n  cardinality and counting.  Infinity axiom.  \n  Surjections. Enumerable and countable sets.  Axiom of choice.  \n  Injections. Images:  direct and inverse images.  Replacement Axiom: set-indexed\n  constructions.  Set cardinality: Cantor-Schoeder-Bernstein Theorem,\n  unbounded cardinality, diagonalisation, fixed-points.  Foundation Axiom.\n\n</p><p></p></li>\n<li><b>Formal languages and automata [5\u00a0lectures].</b>\n<p>Introduction to inductive definitions using rules and proof by rule\n  induction. Abstract syntax trees.\n  \n</p><p>Regular expressions and their algebra.  \n  \n</p><p>Finite automata and regular languages: Kleene\u2019s theorem and the Pumping\n  Lemma.\n  </p></li>\n\n<br/>\n<a name=\"SECTION02024300000000000000\">Objectives</a>\n\nOn completing the course, students should be able to\n\n\n<li>prove and disprove mathematical statements using a variety of\n  techniques; \n\n<p></p></li>\n<li>apply the mathematical principle of induction;\n\n<p></p></li>\n<li>know the basics of modular arithmetic and appreciate its role in\n  cryptography; \n\n<p></p></li>\n<li>understand and use the language of set theory in applications to\n  computer science;\n\n<p></p></li>\n<li>define sets inductively using rules and prove properties about them; \n\n<p></p></li>\n<li>convert between regular expressions and finite automata; \n\n<p></p></li>\n<li>use the Pumping Lemma to prove that a language is not regular.\n\n<p></p></li>\n\n\n<a name=\"SECTION02024400000000000000\">Recommended reading</a>\n\nBiggs, N.L. (2002). \n  <em>Discrete mathematics.</em> \n  Oxford University Press (Second Edition).\n<br/>Davenport, H. (2008).\n  <em>The higher arithmetic: an introduction to the theory of numbers.</em>\n  Cambridge University Press.\n<br/>Hammack, R. (2013).\n  <em>Book of proof.</em>\n  Privately published (Second edition). Available at:\n<br/> <a href=\"http://www.people.vcu.edu/~rhammack/BookOfProof/index.html\" name=\"tex2html4\"><tt>http://www.people.vcu.edu/\u00a0rhammack/BookOfProof/index.html</tt></a>\n<br/>Houston, K. (2009).\n\n<em>How to think like a mathematician: a companion to undergraduate\n    mathematics.</em>\n  Cambridge University Press.\n<br/>Kozen, D.C. (1997). \n  <em>Automata and computability</em>. \n  Springer.\n<br/>Lehman, E.; Leighton, F.T.; Meyer, A.R. (2014).\n  <em>Mathematics for computer science.</em> \n  Available on-line.\n<br/>Velleman, D.J. (2006).\n  <em>How to prove it: a structured approach.</em>\n  Cambridge University Press (Second Edition).\n\n\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/DiscMath", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "\n\n\n<a name=\"SECTION02021100000000000000\">Aims</a>\n\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using <span class=\"MATH\"><i>O</i></span>-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\nThe course will use a functional language (ML).  ML is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso introduce traditional (procedural) programming, such as\nassignments, arrays and references.\n\n\n<a name=\"SECTION02021200000000000000\">Lectures</a>\n\n<li><b>Introduction to Programming.</b>\nThe role of abstraction and representation.  Introduction to integer and floating-point arithmetic.\nDeclaring functions. Decisions and booleans. Example: integer exponentiation.\n\n<p></p></li>\n<li><b>Recursion and Efficiency.</b>\nExamples: Exponentiation and summing integers.  Overloading. Iteration <em>versus</em> recursion. \nExamples of growth rates.  Dominance and <span class=\"MATH\"><i>O</i></span>-Notation.  The costs\nof some representative functions.  Cost estimation.\n\n<p></p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p></p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p></p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p></p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p></p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p></p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying. \nThe \u201capply to all\u201d functional, <tt>map</tt>.  \n<span class=\"textit\">Examples</span>: matrix transpose and product.  \nThe predicate functionals <tt>filter</tt> and <tt>exists</tt>.\n\n<p></p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in ML.\nApplications, for example Newton-Raphson square roots.\n\n<p></p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p></p></li>\n<li><b>Polynomial arithmetic.</b>\nAddition, multiplication of polynomials using ideas from sorting,\netc.\n\n<p></p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not. Introduction to linked lists. \n\n<p></p></li>\n\n\n<a name=\"SECTION02021300000000000000\">Objectives</a>\n\nAt the end of the course, students should\n\n\n<li>be able to write simple ML programs;\n\n<p></p></li>\n<li>understand the fundamentals of using a data structure to represent some mathematical abstraction;\n\n<p></p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p></p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p></p></li>\n<li>understand binary search and binary search trees;\n\n<p></p></li>\n<li>know how to use currying and higher-order functions;\n\n<p></p></li>\n<li>understand how ML combines imperative and functional programming in a single language.\n\n<p></p></li>\n\n\n<a name=\"SECTION02021400000000000000\">Recommended reading</a>\n\n* Paulson, L.C. (1996). <em>ML for the working programmer</em>. Cambridge University Press (2nd\u00a0ed.).\n<br/>Okasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\nFor reference only:\n<br/>Gansner, E.R. &amp; Reppy, J.H. (2004). <em>The Standard ML Basis Library</em>. Cambridge University Press. ISBN: 0521794781\n\n\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/FoundsCS", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Graphics": {"supervisions": 2, "lectures": 15, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Graphics.html", "description": "\n\n\n<a name=\"SECTION02026100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02026200000000000000\">Lectures</a>\n\n<li><b>Background.</b> What is an image? Human vision. Resolution and quantisation. Storage of\nimages in memory. [1 lecture]\n\n<p></p></li>\n<li><b>Rendering.</b> Perspective. Reflection of light from surfaces and shading.\nGeometric models. Ray tracing. [3 lectures]\n\n<p></p></li>\n<li><b>Graphics pipeline.</b> Polygonal mesh models. Transformations using\nmatrices in 2D and 3D. Homogeneous coordinates. Projection: orthographic\nand perspective. [1 lecture]\n\n<p></p></li>\n<li><b>Graphics hardware and modern OpenGL.</b> Vertex processing.\nRasterisation. Fragment processing. Working with meshes and textures. [2 lectures]\n\n<p></p></li>\n<li><b>Technology</b>. Colour spaces. Output devices: brief overview of\ndisplay and printer technologies. [1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION02026300000000000000\">Objectives</a>\n\nBy the end of the course students should be able to:\n\n\n<li>understand and apply in practice basic concepts of ray-tracing: ray-object intersection, reflections, refraction, shadow rays, distributed ray-tracing, direct and indirect illumination;\n\n<p></p></li>\n<li>describe and explain the following algorithms:  Gouraud and Phong shading, z-buffer, texture mapping, double buffering, mip-map, bump- and normal-mapping;\n\n<p></p></li>\n<li>use matrices and homogeneous coordinates to represent and perform 2D and 3D transformations; understand and use 3D to 2D projection, the viewing volume, and 3D clipping;\n\n<p></p></li>\n<li>implement OpenGL code for rendering of polygonal objects, control camera and lighting, work with vertex and fragment shaders;\n\n<p></p></li>\n<li>describe a number of colour spaces and their relative merits; explain the workings of two display and printer technologies.\n\n<p></p></li>\n\n\n<a name=\"SECTION02026400000000000000\">Recommended reading</a>\n\n* Shirley, P. &amp; Marschner, S. (2009). <em>Fundamentals of Computer Graphics</em>. CRC Press (3rd ed.).\n<br/>Foley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>Kessenich, J.M., Sellers, G. and  Shreiner, D (2016). <em>OpenGL Programming Guide: The Official Guide to Learning OpenGL</em>, Version 4.5 with SPIR-V. [seventh edition and later]\n\n\n", "course_name": "Graphics", "course_code": "Graphics", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Graphics", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n<li><a href=\"Hardware_16.pdf\">Notes</a> for hardware practical classes</li>\n\n<a href=\"../../1516/HW/\">Last year\u2019s course materials</a> are still available.\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/HW", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "ML": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n", "course_name": "ML Practical Classes", "course_code": "ML", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/ML", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html", "description": "\n\n\n<a name=\"SECTION02022100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02022200000000000000\">Lecture syllabus</a>\n\n\n<li><b>Types, Objects and Classes</b> Moving from functional to\n  imperative. Distinguishing state and behaviour. Primitive\n  types. Function prototypes. Objects and classes as custom\n  types. Introduction to parameterised types (templates/Generics).\n\n<p></p></li>\n<li><b>Pointers, References and Memory</b> Pointers and\n  references. The call stack and heap. Iteration and\n  recursion. Pass-by-value and pass-by-reference. Objects as reference\n  types in Java.\n\n<p></p></li>\n<li><b>Creating Classes</b> Modularity. Encapsulation. Information\n  hiding. Access modifiers. \u00a0Advantages of immutability. Creating\n  Generic types in Java. Static data.\n\n<p></p></li>\n<li><b>Inheritance</b> Inheritance. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.\n\n<p></p></li>\n<li><b>Polymorphism and Multiple Inheritance</b> Polymorphism in ML\n  and Java. Multiple inheritance. Interfaces in Java.  \n\n<p></p></li>\n<li><b>Lifecycle of an Object</b> Constructors and chaining. Destructors. Finalizers. Garbage Collection.  Copying Objects. Shallow and deep copies. Copy\n  constructors. Cloning in Java. Cloneable as a marker interface in\n  Java.\n\n<p></p></li>\n<li><b>Java Collections</b> Java Collection interface. Key\n  classes. Collections class. Iteration options and the use of\n  Iterator.  \n\n<p></p></li>\n<li><b>Object Comparison</b> Comparing primitive and reference\n  types. Equals. Comparable and Comparator in Java. Operator\n  Overloading.\n\n<p></p></li>\n<li><b>Error Handling</b> Limitations of return\n  values. Exceptions. Custom exceptions.\n\n<p></p></li>\n<li><b>Design Patterns</b> Introduction to design patterns. Examples\n  of Singleton, Decorator, State, Strategy, Observer.  \n\n<p></p></li>\n<li><b>Case Studies and Worked Examples</b>\n<p></p></li>\n\n\n<a name=\"SECTION02022300000000000000\">Practical classes</a>\n\n\n<li><b>Methods, operators and types.</b>\nThis class will concentrate on the fundamentals of imperative\nprogramming. Students will learn about Java primitive types, variable\ndeclaration, operators and method calls.\n\n<p></p></li>\n<li><b>Control structures.</b>\nStudents will explore the control structures found in Java.\n\n<p></p></li>\n<li><b>Arrays, references and classes.</b>\nThis week the students will explore arrays and references in Java and\nlearn how to define and instantiate their own class.\n\n<p></p></li>\n<li><b>Input/Output and Exceptions.</b>\nThis class will examine streams and Exceptions. Students will read and\nwrite data to and from the filesystem and network and learn to handle\nerrors using Java Exceptions.\n\n<p></p></li>\n<li><b>Inheritance and interfaces.</b>\nThis class will explore object-oriented programming as expressed in\nJava. Students will learn how to extend classes, as well as specify\nand provide implementations for Java interfaces.\n\n<p></p></li>\n<li><b>Abstraction and graphical interfaces.</b>\nStudents will examine code-reuse through inheritance and the use of\ninner classes for encapsulation.  Students will begin to construct a\ngraphical interface using Swing.\n\n<p></p></li>\n<li><b>Swing and event handling.</b>\nStudents will complete their graphical interface by writing event\nhandlers to control the execution of a graphical application.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022400000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with the main features and limitations of the Java\n  language;\n\n<p></p></li>\n<li>be able to write a Java program to solve a well specified problem;\n\n<p></p></li>\n<li>understand the principles of OOP;\n\n<p></p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p></p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p></p></li>\n<li>be familiar with common errors in Java and its associated\n    libraries;\n\n<p></p></li>\n<li>understand a Java program written by someone else;\n\n<p></p></li>\n<li>be able to debug and test Java programs;\n\n<p></p></li>\n<li>be familiar with major parts of Java 8 SE libraries;\n\n<p></p></li>\n<li>understand how to read Javadoc library documentation and reuse\n    library code.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022500000000000000\">Recommended reading</a>\n\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>Gamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>Bloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/OOProg", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n", "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Registratn", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Algorithms": {"supervisions": 7, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms.html", "description": "\n\n\n<a name=\"SECTION02031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02031200000000000000\">Lectures</a>\n\n<li><b>Sorting.</b>  Review of complexity and O-notation. Trivial\n  sorting algorithms of quadratic complexity. Review of merge sort and\n  quicksort, understanding their memory behaviour on statically\n  allocated arrays. Heapsort. Stability. Other sorting methods\n  including sorting in linear time. Median and order statistics.\n  [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9] [about 4 lectures] \n<p></p></li>\n<li><b>Strategies for algorithm design.</b>\nDynamic programming, divide and conquer, greedy algorithms and other\nuseful paradigms.\n[Ref: CLRS3 chapters 4, 15, 16] [about 3 lectures] \n<p></p></li>\n<li><b>Data structures.</b>  Primitive data structures. Abstract data\n  types. Pointers, stacks, queues, lists, trees. Binary search\n  trees. Red-black trees. B-trees. Hash tables. Priority queues and\n  heaps.  [Ref: CLRS3 chapters 6, 10, 11, 12, 13, 18] [about 5 lectures] \n<p></p></li>\n<li><b>Advanced data structures.</b>  Amortized analysis: aggregate\n  analysis, potential method. Fibonacci heaps. Disjoint sets.  [Ref: CLRS3 chapters 17, 19, 20, 21] [about 4\n    lectures]\n\n<p></p></li>\n<li><b>Graph algorithms.</b>  Graph representations. Breadth-first and\n  depth-first search. Topological sort. Minimum spanning tree. Kruskal\n  and Prim algorithms. Single-source shortest paths: Bellman-Ford and\n  Dijkstra algorithms.  All-pairs shortest paths: matrix\n  multiplication and Johnson\u2019s algorithms. Maximum flow:\n  Ford-Fulkerson method, Max-Flow Min-Cut Theorem. Matchings in bipartite graphs.  [Ref: CLRS3\n    chapters 22, 23, 24, 25, 26] [about 7 lectures]\n\n<p></p></li>\n<li><b>Geometric algorithms.</b>  Intersection of segments. Convex\n  hull: Graham\u2019s scan, Jarvis\u2019s march.  [Ref: CLRS3 chapter 33] [about\n    1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION02031300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>have a thorough understanding of several classical algorithms\n  and data structures;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p></p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\n\n<a name=\"SECTION02031400000000000000\">Recommended reading</a>\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein,\nC. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN\n978-0-262-53305-8\n<br/>Sedgewick, R., Wayne, K. (2011). <em>Algorithms</em>. Addison-Wesley. ISBN\n978-0-321-57351-3.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.\n<br/>Knuth, D.A. (2011). <em>The Art of Computer\n  Programming</em>. Addison-Wesley. ISBN 978-0-321-75104-1.\n<br/>\n<br/>\nStudents hoping to receive a computer science degree from Cambridge\nare expected to buy, make extensive use of, and keep as reference for\ntheir future career, one of the above fundamental textbooks: those not\ndoing so will be severely disadvantaged. The recommended choice is\nCormen, Leiserson, Rivest and Stein (CLRS3, starred in the above list)\nwhich covers all topics listed and, in spite of its superb quality, is\nthe cheapest: about 35 GBP new for over 1300 pages. The references in\nthe syllabus are to this textbook. The other textbooks listed are\nexcellent additions for further study but might cost more and yet not\ncover the entire syllabus.\n\n\n", "course_name": "Algorithms", "course_code": "Algorithms", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Algorithms", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "MLRD": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MachineLearningandReal-worldData.html", "description": "\n\n\n<a name=\"SECTION02033100000000000000\">Aims</a>\n\n<li>Statistical classification: Determining a movie review\u2019s\n  sentiment using Naive Bayes (7 sessions)\n</li>\n<li>Sequence Analysis: Detection of proteins in genetic data using Hidden Markov Modelling (4 sessions)\n</li>\n<li>Network analysis of a social network, including detection of\n  cliques and central nodes (5 sessions)\n</li>\n\n\n<a name=\"SECTION02033200000000000000\">Syllabus</a>\n\n\n<li><b>Topic One: Statistical Classification [7 sessions].</b>\n<br/>Introduction to Sentiment Classification.\n<br/>Naive Bayes Parameter Estimation.\n<br/>Statistical Laws of Language.\n<br/>Smoothing and Statistical Tests.\n<br/>Overtraining.\n<br/>Uncertainty and Human Agreement.\n<br/><p></p></li>\n<li><b>Topic Two: Sequence Analysis [4 sessions].</b>\n<br/>Simple HMM Parameter Estimation.\n<br/>The Viterbi Algorithm.\n<br/>Random Baselines and Evaluation Metrics.\n<br/>Application to Protein Detection Data.\n<br/><p></p></li>\n<li><b>Topic Three: Network Analysis [5 sessions].</b>\n<br/>Degree, Diameter, Visualisation.\n<br/>Random Networks and Small World Property.\n<br/>Betweenness Centrality.\n<br/>Clique Finding.\n<br/></li>\n\n\n<a name=\"SECTION02033300000000000000\">Objectives</a>\n\nBy the end of the course students should be able to\n\n\n<li>understand and program two simple\nsupervised machine learning algorithms;\n</li>\n<li>use these algorithms in statistically valid experiments,\nincluding the design of baselines, evaluation\nmetrics, statistical testing of results, and provision against\novertraining;\n</li>\n<li>visualise and interpret examples of statistical\nlaws of language;\n</li>\n<li>visualise the connectivity and centrality in large\nnetworks;\n</li>\n<li>use clustering (i.e., a type of unsupervised machine learning) for\ndetection of cliques in unstructured networks.\n</li>\n\n\n<a name=\"SECTION02033400000000000000\">Recommended reading</a>\n\nJurafsky, D. &amp; Martin, J. (2008). <i>Speech and language\nprocessing</i>. Prentice Hall.\n<br/>Durbin, R., Eddy, S., Krough, A. &amp; Mitchison, G. (1998). <i>Biological\nsequence analysis: probabilistic models of proteins and nucleic\nacids</i>. Cambridge University Press.\n<br/>Easley, D. and Kleinberg, J. (2010). <i>Networks, crowds, and markets:\nreasoning about a highly connected world</i>. Cambridge University\nPress.\n\n\n", "course_name": "Machine Learning and Real-world Data", "course_code": "MLRD", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/MLRD", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OpSystems": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "\n\n\n<a name=\"SECTION02032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02032200000000000000\">Lectures</a>\n\n<li><b>Introduction to operating systems.</b> Abstract view of an operating system. Elementary computer architecture. OS evolution: multi-programming, time-sharing. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Protection.</b> Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels. Subjects and objects. Authentication. Access matrix: ACLs and capabilities. Combined scheme. Covert channels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Processes.</b> Job/process concepts. Lifecycle. Process management. Inter-process communication. [1\u00a0lectures]\n\n<p></p></li>\n<li><b>Scheduling.</b> Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Memory management.</b> Processes in memory. Logical addresses. Partitions: static <em>versus</em> dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>I/O subsystem.</b> General structure. Polled mode <em>versus</em> interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking <em>versus</em> non-blocking I/O. Other issues: caching, scheduling, spooling, performance. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>File management.</b> File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Unix case study.</b> History. General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection, pipes, signals. Character and block I/O. Process scheduling. [2\u00a0lectures]\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION02032300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>describe the general structure and purpose of an operating system;\n</li>\n<li>explain the concepts of process, address space, and file;\n</li>\n<li>compare and contrast various CPU scheduling algorithms;\n</li>\n<li>understand the differences between segmented and paged memories, and be able to describe the advantages and disadvantages of each;\n</li>\n<li>compare and contrast polled, interrupt-driven and DMA-based access to I/O devices.\n</li>\n\n<br/>\n<a name=\"SECTION02032400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>. Addison-Wesley (3rd ed.).\n<br/>Silberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <em>Operating systems concepts</em>. Wiley (8th ed.).\n<br/>Anderson, T. &amp; Dahlin, M. (2014). <em>Operating Systems: Principles &amp; Practice</em>. Recursive Books (2nd ed.).\n<br/>Leffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>McKusick, M.K., Neville-Neil, G.N. &amp; Watson, R.N.M. (2014) <em>The Design and Implementation of the FreeBSD Operating System</em>. Pearson Education. (2nd ed.).\n<br/>Solomon, D. &amp; Russinovich, M. (2000). <em>Inside Windows 2000</em>. Microsoft Press (3rd ed.).\n\n\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/OpSystems", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "FJavaBrfg": {"supervisions": null, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION02044100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02044200000000000000\">Lecture</a>\n\nThe lecture describes the requirements for the first assessed\nexercise of the Part\u00a0IB Further Java course.\n\n\n<a name=\"SECTION02044300000000000000\">Objectives</a>\n\nOn completing the exercise students should\n\n\n<li>be prepared for the Part\u00a0IB Further Java course;\n\n<p></p></li>\n<li>have developed their practical Java programming skills further.\n\n<p></p></li>\n\n\n\n", "course_name": "Further Java Briefing", "course_code": "FJavaBrfg", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/FJavaBrfg", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "IntDesign": {"supervisions": 2, "lectures": 15, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-InteractionDesign.html", "description": "\n\n\n<a name=\"SECTION02043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02043200000000000000\">Lectures</a>\n\n<li><b>Overview and requirements analysis.</b> Introduction to the course and\nthe practicals. Participatory design process. Identifying potential users and\nunderstanding their tasks. Identifying and establishing non-functional and\nfunctional requirements. Socio-technical Models and Soft Systems Methodology.\n\n<p></p></li>\n<li><b>Data gathering.</b> Data collection techniques: Observation, interviews,\ncard sorting, questionnaires, studying documentation, focus groups, contextual\ninquiry, scenarios / use cases, and researching similar products. Data\npresentation techniques for functional and non-functional requirements.\n\n<p></p></li>\n<li><b>Design and prototyping.</b> Participatory design process. Conceptual\nversus physical design. Concept development. Prototyping and different kinds\nof prototypes. Personas and storyboards.\n\n<p></p></li>\n<li><b>Principles of good design.</b> Shneiderman\u2019s golden rules of interface\ndesign. \n\n<p></p></li>\n<li><b>Human cognition for interaction design.</b> The Model human processor.\nAttention, perception/recognition, memory, context and grouping, and their\nimplications for interaction design. Gestalt Laws of perceptual organisation.\n\n<p></p></li>\n<li><b>Multimodal and emotional interaction.</b> Multimodal interaction.\nAccessibility. Emotional design framework by Don Norman. Detecting emotions\nand emotional technology: direct and indirect methods. Expressive/frustrating\ninterfaces and anthropomorphism.\n\n<p></p></li>\n<li><b>Heuristic evaluation.</b> The process of Heuristic Evaluation (HE):\nPre-evaluation training, evaluation, severity ratings, and feedback into\ndesign. Ten usability Heuristics with definitions and practical examples.\n\n<p></p></li>\n<li><b>Cognitive walkthrough.</b> The process of cognitive walkthrough:\nDefining inputs, stepping through action sequences, recording information,\nand revising the user interface.\n\n<p></p></li>\n\n\n<a name=\"SECTION02043300000000000000\">Objectives</a>\n\nBy the end of the course students should \n\n\n<li>have a thorough understanding of the iterative design process and be\nable to apply it to interaction design;\n\n<p></p></li>\n<li>be able to design new user interfaces that are informed by principles of\ngood design, and the principles of human visual and affective perception,\ncognition and communication;\n\n<p></p></li>\n<li>be able to construct user interfaces using Java with a strong emphasis\non users, usability and appearance;\n\n<p></p></li>\n<li>be able to evaluate existing or new user interfaces using multiple\ntechniques;\n\n<p></p></li>\n<li>be able to compare and contrast different design techniques and to\ncritique their applicability to new domains.\n\n<p></p></li>\n\n\n<a name=\"SECTION02043400000000000000\">Recommended reading</a>\n\n* Preece, J., Rogers, Y. &amp; Sharp, H. (2015). <em>Interaction design</em>.\nWiley (4th ed.).\n\n\n", "course_name": "Interaction Design", "course_code": "IntDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/IntDesign", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "NumMethods": {"supervisions": 3, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-NumericalMethods.html", "description": "\n\n\n<a name=\"SECTION02041100000000000000\">Aims</a>\n\n<li>an introduction to\n(IEEE) floating-point data representation and arithmetic; \n</li>\n<li>illustrations of how na\u00efve implementations of obvious mathematics can go badly wrong;\n</li>\n<li>a study of several standard numerical processes, algorithms and techniques.\n</li>\n\nAn overall implicit aim is to encourage caution when using any\nfloating-point value produced by a computer program.  A variety of code\nfragments are provided and most are available in multiple languages.\nStudents are strongly encouraged to experiment with these fragments.\n\n(Changes from last year: One fewer topics will be lectured. A full-text Learners\u2019 Guide PDF will be available as well as slide hardcopies.)\n\n<br/>\n<a name=\"SECTION02041200000000000000\">Lectures</a>\n\n<li><b>Integer and floating-point representation and arithmetic.</b>\nSigned and unsigned integers and fixed-point; arithmetic, saturating arithmetic.\nLong division and multiplication.\nFloating point I/O in ASCII.\nWhat numbers are exactly representable in bases 2 and 10.\nAccuracy in terms of significant figures.\n\n<p></p></li>\n<li><b>IEEE floating-point arithmetic.</b>\nFloating-point arithmetic, and the IEEE requirements.\nIEEE 754/854 floating point (32 and 64 bit); zeros, infinities, NaN.\nOverflow, underflow, progressive loss of significance.      Rounding modes.\nFloating-point arithmetic is non-associative, and mathematical equivalences fail.\nNonsensical results, e.g. <tt>sin(1e40)</tt>.\nDifficulty in obtaining IEEE-quality in libraries.\n\n<p></p></li>\n<li><b>How floating-point computations diverge from real-number calculations.</b>\nAbsolute Error, Relative Error, Machine epsilon, Unit in Last Place (ulp).\nFinite computation: solving a quadratic.\nSumming a finite series.\nRounding (round-off) and truncation (discretisation) error.\nNumerical differentiation; determining a good step size.\n\n<p></p></li>\n<li><b>Iteration and when to stop.</b>\nUnbounded computation may produce unbounded errors.\nSolving equations by iteration and comparison to terminate it.\nNewton\u2019s method.\nOrder of convergence. Limit cycles.\nWhy summing a Taylor series is problematic. \nCondition number, partial derivatives, backwards stability and chaos.\n\n<p></p></li>\n<li><b>Matrix Form Simultaneous Equations.</b>\nGaussian Elimination. \nStability and pivoting improvements.\nPositive-definite. L/U and Cholesky decompositions.  Doolittle/Crout method.\n\n<p></p></li>\n<li><b>Efficient and Approximate Implementations</b>\nA subset of the following topics will we be lectured/examinable as announced on the website:\nChebychev orthogonal basis (for power series economisation) \nPractical implementation of scientific (trig/log) functions. \nSplines. Comparison of Taylor, Chebychev and Cordic.\n\n<p></p></li>\n<li><b>Finite-Difference Time-Domain Simulation.</b>\nNumerical simulation of SHM, charge/discharge, waves and other various examples (such as a Moniac Simulator). \n\n<p></p></li>\n<li><b>Fluid Flow Analysis.</b>  Using a matrix representation\nof a linear flow circuit (water, electricity etc) to find steady\nstate. Extensions for non-linear and time-varying branches (as used by SPICE).\n\n<p></p></li>\n<li><b>Adaptive Methods and Custom Encodings</b> \nA subset of the following topics will we be lectured/examinable as announced on the website:\nArbitrary precision floating point, adaptive floating point, interval arithmetic.\nRounding errors in PCM. Logarithmic and other non-linear representations. Their use in a-posteriori decision algorithms.\nEg for rapid multiplication in Viterbi/Bayes and specialist ALUs (e.g. for low-density parity).\nSimulated Annealing. Non-linear spatial quantisation.\n\n<p></p></li>\n\n\n<a name=\"SECTION02041300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to convert simple decimal numbers to and from IEEE\n  floating-point format, and to perform IEEE arithmetic on them;\n\n<p></p></li>\n<li>be able to identify problems with floating-point implementations of\n      simple mathematical problems and know when incorrect solution is likely;\n\n<p></p></li>\n<li>be familiar with several key algorithms from the history of numerical analysis;\n\n<p></p></li>\n<li>decide how and when computation energy should be traded for accuracy;\n\n<p></p></li>\n<li>know to use a professionally-written package whenever possible\n      (and still to treat claims of accuracy with suspicion).\n\n<p></p></li>\n\n\n<a name=\"SECTION02041400000000000000\">Recommended reading</a>\n\nOverton, M.L. (2001). <em>Numerical computing with IEEE floating point arithmetic</em>. SIAM.\n\nFurther reading - goes far beyond the course\n\nGoldberg, D. (1991). <em>What every computer scientist should know about floating-point arithmetic</em>. ACM Computing Surveys, vol. 23, pp. 5-48.\n\n\n", "course_name": "Numerical Methods", "course_code": "NumMethods", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/NumMethods", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWSecEng": {"supervisions": 3, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandSecurityEngineering.html", "description": "\n\n\n<a name=\"SECTION02042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02042200000000000000\">Lectures</a>\n\n\n<li><b>The software crisis.</b> Examples of large-scale project failure, \nsuch as the London Ambulance Service system and the NHS National \nProgramme for IT. Intrinsic difficulties with software.\n\n<p></p></li>\n<li><b>The software life cycle.</b> The software life cycle. Getting the\nspecification right; requirements analysis methods; modular design; the role of \nprototyping; the waterfall and spiral models.\n\n<p></p></li>\n<li><b>Guest lecture.</b> A guest lecture from an industry speaker about the \nrealities of managing software development in a commercial environment.\n\n<p></p></li>\n<li><b>Modern integrated development environments.</b> Tools to support code \nmanagement, code review and test case generation; git and Jenkins.\nContinuous integration, refactoring, release engineering, patch \nstrategies.\n\n<p></p></li>\n<li><b>Critical systems:</b> where real-time performance, safety or security \nis critical. Examples of catastrophic failure; problems with \nusability and human error for safety engineering and security\nengineering.\n\n<p></p></li>\n<li><b>Predicting user behaviour:</b> expected utility, prospect theory, \nframing, status quo bias, gender. Measuring human behaviour. The \ncharacteristics of human memory; forgetting passwords versus guessing \nthem.\n\n<p></p></li>\n<li><b>What is a security policy or a safety case?</b> How to enforce policy \nby structured design; one-way flows, redundancy. Protection profiles; \nmaintaining a security rating (or a safety case).\n\n<p></p></li>\n<li><b>Security protocols;</b> how to enforce policy using cryptography and \nstructured human interaction. The role of verification and validation.\n\n<p></p></li>\n<li><b>Bugs of different types:</b> design errors such as protocol exploits, \nand implementation errors affecting arithmetic, logic, syntax, and \nconcurrency. Defensive programming (secure coding, exception \nhandling, contracts).\n\n<p></p></li>\n<li><b>Quality assurance.</b> The contribution of reviews and testing; \nreliability growth models; software maintenance life-cycle costs. The \nneed for code indexing, code ownership, library management and \nup-to-date design documentation.\n\n<p></p></li>\n<li><b>Real-world challenges in combining safety and security.</b> Project \nplanning tools; PERT and GANTT charts. Open source: advantages and \ndrawbacks.\n\n<p></p></li>\n\n\n<a name=\"SECTION02042300000000000000\">Objectives</a>\n\nAt the end of the course students should know how writing programs \nwith tough assurance targets, in large teams, or both, differs from \nthe programming exercises they have engaged in so far. They should \nappreciate the waterfall, spiral and evolutionary models of software \ndevelopment as well as the value of various development and \nmanagement tools. They should understand the development life cycle \nand its basic economics. They should understand the various types of \nbugs, vulnerabilities and hazards, how to find them, and how to avoid \nintroducing them. Finally, they should be prepared for the \norganizational aspects of their Part\u00a0IB group project.\n\n\n<a name=\"SECTION02042400000000000000\">Recommended reading</a>\n\nHoward, M. &amp; LeBlanc, D. (2003). <em>Writing secure code</em>. Microsoft Press.\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Part 1 and Chapters 25-26). Wiley. Available at:\n<br/><a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html5\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n<br/>Leveson, N. (1994). <i>Safeware</i>. Addison-Wesley.\n<br/>Further reading:\n\nBrooks, F.P. (1975). <i>The mythical man month</i>. Addison-Wesley.\n<br/>Reason, J. (2008). <i>The human contribution</i>. Ashgate Publishing.\n<br/>Leveson, N. (2008). <i>System safety engineering: back to the future</i>. Available at\n<br/><a href=\"http://sunnyday.mit.edu/book2.pdf\" name=\"tex2html6\"><tt>http://sunnyday.mit.edu/book2.pdf</tt></a>\n<br/>Maguire, S. (1993). <i>Writing solid code</i>. Microsoft Press.\n<i>Report of the inquiry into the London Ambulance Service</i> (SW Thames RHA, 40 Eastbourne Terrace, London W2 3QR, February 1993).\n<br/><a href=\"http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html\" name=\"tex2html7\"><tt>http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html</tt></a>\n<br/>\n", "course_name": "Software and Security Engineering", "course_code": "SWSecEng", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/SWSecEng", "lecturers": [], "year": "1617", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}