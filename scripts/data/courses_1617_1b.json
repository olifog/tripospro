{"CompDesign": {"supervisions": 5, "lectures": 18, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerDesign.html", "description": "\n\n\n<a name=\"SECTION03021100000000000000\">Aims</a>\n\nThe course starts with a web-based SystemVerilog tutor which is a\nprerequisite for the ECAD+Arch practical classes.  There are then\neighteen lectures in three six-lecture parts.  Part 1 goes from gates\nto a simple processor.  Part 2 looks at instruction set and computer\narchitecture.  Part 3 analyses the architecture of modern systems-on-chip.\n\n\n<a name=\"SECTION03021200000000000000\">Lectures</a>\n\nPart 0 - SystemVerilog Web tutor\n\n\n<li>This web tutor is a prerequisite to starting the ECAD+Arch laboratory sessions [equivalent to approximately 4 lectures]\n</li>\n\nPart 1 - Gates to processors [lecturer: Simon Moore]\n\n\n<li><b>Introduction and motivation.</b> [1 lecture]\n  Current technology, technology trends, ECAD trends, challenges.\n\n<p></p></li>\n<li><b>Logic modelling, simulation and synthesis.</b> [1 lecture]\n  Logic value and delay modelling. Discrete event and device\n  simulation. Automatic logic minimization.\n\n<p></p></li>\n<li><b>SystemVerilog FPGA design.</b> [1 lecture]\n  Practicalities of mapping SystemVerilog descriptions of hardware\n  (including a processor) onto an FPGA\n  board.  Tips and pitfalls when generating larger modular designs. \n\n<p></p></li>\n<li><b>Chip, board and system testing.</b>  [1 lecture]\n  Production testing, fault models, testability, fault coverage,\n  scan path testing, simulation models.\n\n<p></p></li>\n<li><b>Building a simple computer.</b> [2 lectures]\n</li>\n\nPart 2 - Instruction sets and introduction to computer architecture [lecturer: Simon Moore]\n\n\n<li><b>Historical perspective on computer architecture.</b> [1 lecture]\n   EDSAC <em>versus</em> Manchester Mark I.\n\n<p></p></li>\n<li><b>RISC machines.</b> [1 lecture]\n   Introduction to ARM and MIPS RISC processor designs.\n\n<p></p></li>\n<li><b>CISC and virtual machines</b> [1 lecture]\n  The Intel x86 instruction set and the Java Virtual Machine (JVM).\n\n<p></p></li>\n<li><b>Memory hierarchy.</b> [1 lecture]\n  Caching, etc.\n\n<p></p></li>\n<li><b>Hardware support for operating systems.</b> [1 lecture]\n  Memory protection, exceptions, interrupts, etc.\n\n<p></p></li>\n<li><b>Pipelining and data paths.</b> [1 lecture]\n</li>\n\nPart 3 - Systems-on-chip [lecturer: Timothy Jones]\n\n\n<li><b>Overview of Systems-on-Chip (SoCs).</b> [1 lecture]\n  What are they and how do we program  them?\n\n<p></p></li>\n<li><b>Multicore Processors.</b> [2 lectures]\n  Communication, cache coherence, barriers and synchronisation primitives\n\n<p></p></li>\n<li><b>Graphics processing units (GPUs)</b> [2 lectures]\n  Basic GPU architecture and programming\n\n<p></p></li>\n<li><b>Future Directions</b> [1 lecture]\n  Where is computer architecture heading?\n\n<p></p></li>\n\n\n<a name=\"SECTION03021300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read assembler given a guide to the instruction set\nand be able to write short pieces of assembler if given an\ninstruction set or asked to invent an instruction set;\n\n<p></p></li>\n<li>understand the differences between RISC and CISC assembler;\n\n<p></p></li>\n<li>understand what facilities a processor provides to support\noperating systems, from memory management to software interrupts;\n\n<p></p></li>\n<li>understand memory hierarchy including different cache\nstructures and coherency needed for multicore systems;\n\n<p></p></li>\n<li>understand how to implement a processor in SystemVerilog;\n\n<p></p></li>\n<li>appreciate the use of pipelining in processor design;\n\n<p></p></li>\n<li>have an appreciation of control structures used in processor design;\n\n<p></p></li>\n<li>have an appreciation of system-on-chip design.\n\n<p></p></li>\n\n\n<a name=\"SECTION03021400000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture: from gates to processors</em>. Morgan Kaufmann.\n\nRecommended further reading:\n\nHennessy, J. &amp; Patterson, D. (2006). <em>Computer architecture: a quantitative approach</em>. Elsevier (4th ed.). ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also still generally relevant.)\n<br/>Patterson, D.A. &amp; Hennessy, J.L. (2004). <em>Computer organization and design</em>. Morgan Kaufmann (3rd ed., as an alternative to the above). (2nd ed., 1998, is also good.)\n<br/>Pointers to sources of more specialist information are included in the\nlecture notes and on the associated course web page.\n\n\n", "course_name": "Computer Design", "course_code": "CompDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CompDesign", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompGraph": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerGraphicsandImageProcessing.html", "description": "\n\n\n<a name=\"SECTION03022100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03022200000000000000\">Lectures</a>\n\n\n<li><b>Background.</b>  What is an image? What are computer graphics, image processing, and computer vision?\nHow do they relate to one another?\nColour. Human vision. Resolution and quantisation. Storage of images in memory. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Rendering.</b>  Perspective.  Reflection of light from surfaces.  Geometric models.  Ray tracing. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Graphics pipeline.</b>  Polygonal mesh models.  Transformations using matrices in 2D and 3D.  Homogeneous coordinates.  Projection: orthographic and perspective.  Graphics hardware and OpenGL.  Lighting: flat shading, Gouraud shading, Phong shading. Texture mapping. [4\u00a0lectures]\n\n<p></p></li>\n<li><b>Underlying algorithms.</b>  Drawing a straight line. Drawing circles and ellipses. Cubic curves: specification and drawing. Clipping lines. Clipping polygons. Filling polygons. 3D scan conversion using the z-buffer. Anti-aliasing and the A-buffer. [4\u00a0lectures]\n\n<p></p></li>\n<li><b>Technology.</b>  Colour spaces. Output devices: brief overview of two display technologies (LCD, DMD) and two printer technologies (ink jet and laser printer). Image capture. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Image processing.</b>  Operations on images: filtering, point processing, compositing. Half-toning and dithering, error diffusion. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03022300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to:\n\n\n<li>explain the basic function of the human eye and how this impinges on resolution, quantisation, and colour representation for digital images; describe a number of colour spaces and their relative merits; explain the workings of two display technologies and two printer technologies;\n\n<p></p></li>\n<li>describe and explain the following algorithms: mid-point line drawing, mid-point circle drawing, Bezier cubic drawing, Cohen-Sutherland line clipping, scanline polygon fill, Sutherland-Hodgman polygon clipping, <i>z</i>-buffer, <i>A</i>-buffer, texture mapping, error diffusion;\n\n<p></p></li>\n<li>use matrices and homogeneous coordinates to represent and perform 2D and 3D transformations; understand and use 3D to 2D projection, the viewing volume, and 3D clipping;\n\n<p></p></li>\n<li>understand Bezier curves and patches; understand sampling and super-sampling issues; understand lighting techniques and how they are applied to <i>z</i>-buffer polygon scan conversion; understand texture mapping;\n\n<p></p></li>\n<li>explain how to use filters, point processing, and arithmetic operations in image processing and describe a number of examples of the use of each; explain how halftoning, ordered dither, and error diffusion work.\n\n<p></p></li>\n\n\n<a name=\"SECTION03022400000000000000\">Recommended reading</a>\n\nFoley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>Gonzalez, R.C. &amp; Woods, R.E. (2008). <em>Digital image processing</em>. Addison-Wesley (3rd ed). [The second edition (1992) and the first edition (Gonzalez &amp; Wintz, 1977) are as useful for this course.]\n<br/>* Shirley, P. &amp; Marschner, S. (2009). <em>Fundamentals of Computer Graphics</em>. CRC Press (3rd ed.).\n<br/>Slater, M., Steed, A. &amp; Chrysanthou, Y. (2002). <em>Computer graphics and virtual environments: from realism to real-time</em>.  Addison-Wesley.\n\n\n", "course_name": "Computer Graphics and Image Processing", "course_code": "CompGraph", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CompGraph", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompNet": {"supervisions": 6, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html", "description": "\n\n\n<a name=\"SECTION03023100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03023200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>\nOverview of networking using the Internet as an example. LANs and\nWANs. OSI reference model, Internet TCP/IP Protocol Stack.  Client/server\nparadigm, circuit-switching, packet-switching, Internet structure,\nnetworking delays and packet loss. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Link layer and local area networks.</b>\nLink layer services, error detection and correction, Multiple Access\nProtocols, link layer addressing, Ethernet, hubs and switches,\nPoint-to-Point Protocol. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Wireless and mobile networks.</b>\nWireless links and network characteristics, Wi-Fi: IEEE 802.11 wireless\nLANs, mobility management and mobile IP. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer addressing.</b>\nNetwork layer services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\n [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer routing.</b>\nRouting and forwarding, routing algorithms, routing in the Internet,\nRIP, OSPF, BGP, multicast. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Transport layer.</b>\nService models, multiplexing/demultiplexing, connection-less transport\n(UDP), principles of reliable data transfer, connection-oriented\ntransport (TCP), TCP congestion control, securing TCP (SSL), TCP variants.\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Application layer.</b>\nService requirements, WWW, HTTP, electronic mail, Domain Name System,\nP2P, socket programming API. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Multimedia networking.</b>\nNetworked multimedia applications, best-effort service and multimedia\ndelivery requirements, multimedia protocols (RTSP, RTP, RTCP, SIP),\ncontent distribution networks.  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Datacenter Networking</b>\nDatacenter introductions, architecting a datacenter, datacenter network\nand workload issues, datacenter transport issues. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03023300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse a communication system by separating out the\ndifferent functions provided by the network;\n\n<p></p></li>\n<li>understand that there are fundamental limits to any communications \nsystem;\n\n<p></p></li>\n<li>understand the general principles behind multiplexing, addressing,\nrouting, reliable transmission and other stateful protocols as well as\nspecific examples of each;\n\n<p></p></li>\n<li>understand what FEC is and how CRCs work;\n\n<p></p></li>\n<li>be able to compare communications systems in how they solve\nsimilar problems;\n\n<p></p></li>\n<li>have an informed view of both the internal workings of the\n  Internet and of a number of common Internet applications and\n  protocols.\n\n<p></p></li>\n\n\n<a name=\"SECTION03023400000000000000\">Recommended reading</a>\n\n* Peterson, L.L. &amp; Davie, B.S. (2011). <em>Computer networks: a systems approach</em>. Morgan Kaufmann (5th ed.). ISBN 9780123850591\n<br/>Kurose, J.F. &amp; Ross, K.W. (2009). <em>Computer networking: a top-down approach</em>. Addison-Wesley (5th ed.).\n<br/>Comer, D. &amp; Stevens, D. (2005). <em>Internetworking with TCP-IP, vol. </em>1<em> and </em>2. Prentice\u00a0Hall (5th ed.).\n<br/>Stevens, W.R., Fenner, B. &amp; Rudoff, A.M. (2003). <em>UNIX network programming, Vol.I: The sockets networking API</em>. Prentice\u00a0Hall (3rd ed.).\n\n\n", "course_name": "Computer Networking", "course_code": "CompNet", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CompNet", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "ConcDisSys": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html", "description": "\n\n\n<a name=\"SECTION03024100000000000000\">Aims of the Michaelmas Term part of the course</a>\n\n\n<a name=\"SECTION03024200000000000000\">Michaelmas Term Lectures (Concurrency)</a>\n\n\n<li><b>Introduction to concurrency, threads, and mutual exclusion</b>\nIntroduction to concurrent systems; threads; interleaving; preemption;\nparallelism; execution orderings; processes and threads; kernel vs. user\nthreads; M:N threads; atomicity; mutual exclusion; and mutual exclusion locks\n(mutexes).\n\n<p></p></li>\n<li><b>More mutual exclusion, semaphores, producer-consumer, and MRSW</b>\nHardware foundations for atomicity; locks and invariants; semaphores;\ncondition synchronisation; N-resource allocation; two-party and generalised\nproducer-consumer; Multi-Reader, Single-Write (MRSW) locks.\n\n<p></p></li>\n<li><b>CCR, monitors, and concurrency in practice</b>\nConditional critical regions (CCR); monitors; condition variables; signal-wait\nvs. signal-continue semantics; concurrency in practice (kernels, pthreads,\nJava).\n\n<p></p></li>\n<li><b>Safety and liveness</b>\nSafety vs. liveness; deadlock; the Dining Philosophers; resource allocation\ngraphs; deadlock prevention, avoidance, detection, and recovery; livelock;\npriority inversion; priority inheritance.\n\n<p></p></li>\n<li><b>Concurrency without shared data; transactions</b>\nActive objects; message passing; tuple spaces; CSP; and actor models.\nComposite operations; transactions; ACID; isolation; and serialisability.\n\n<p></p></li>\n<li><b>Further transactions</b>\nHistory graphs; good and bad schedules; isolation vs. strict isolation;\n2-phase locking; rollback; timestamp ordering (TSO); and optimistic\nconcurrency control (OCC).\n\n<p></p></li>\n<li><b>Crash recovery, lock-free programming, and transactional memory</b>\nWrite-ahead logging, checkpoints, and recovery.\nLock-free programming and software-transactional memory (STM).\n\n<p></p></li>\n<li><b>Concurrent systems case study.</b>\nConcurrency in the FreeBSD kernel; kernel synchronisation before parallelism;\nGiant-locked kerels; fine-grained locking; primitives and strategies; lock\norder checking; network-stack work flows; performance scalability; the impact\nof changing hardware.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the need for concurrency control in operating systems\n  and applications, both mutual exclusion and condition\n  synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the\n  implications of different approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming\n  languages for concurrency control and be able to judge the scope,\n  performance implications and possible applications of the various\n  approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock;\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of transactions,\n  how they can be implemented, and how their performance can be optimised\n  based on optimistic assumptions;\n\n<p></p></li>\n<li>understand how the persistence properties of transactions are addressed\n  through logging; and\n\n<p></p></li>\n<li>have a high-level understanding of the evolution of software use of\n  concurrency in the operating-system kernel case study.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.). \n\n\n<a name=\"SECTION03024500000000000000\">Aims of the Lent Term part of the course</a>\n\nThe aims of this course are to study the fundamental characteristics of\ndistributed systems, including their models and architectures; the\nimplications for software design; some of the techniques that have been\nused to build them; and the resulting details of good distributed\nalgorithms and applications.\n\n\n<a name=\"SECTION03024600000000000000\">Lent Term Lectures (Distributed Systems)</a>\n\n\n<li><b>Introduction to distributed systems; RPC</b>\nAvantages   and challenges of distributed systems; \u201cmiddleware\u201d;\n  transparency goals; client-server systems; failures and retry semantics\n  (all-or-nothing; at-most-once; at-least-once).\n  Remote procedure call (RPC); marshalling; interface definition languages\n  (IDLs); SunRPC; external data representation (XDR).\n\n<p></p></li>\n<li><b>Network File System and Object-Oriented Middleware</b>\n  Network File System (NFS); NFSv2; NFSv3; scoping; the implications of a\n  stateless design; performance optimisations.\n  Object-oriented middleware (OOM); Corba ORBs, IDL; DCOM.\n\n<p></p></li>\n<li><b>Practical RPC systems; clocks</b>\n  Remote method invocation (RMI); remote classes vs. serialisable classes;\n  distributed garbage collection; XML-RPC; SOAP and web services; REST.\n  Physical clocks; UTC; computer clocks; clock synchronisation.\n\n<p></p></li>\n<li><b>Clock synchronisation; logical clocks</b>\n  Clock drift and compensation; Cristian\u2019s Algorithm; Berkeley Algorithm;\n  Network Time Protocol (NTP).\n  Logical time, \u201chappens-before\u201d; Lamport clocks; vector clocks.\n\n<p></p></li>\n<li><b>Consistent cuts, process groups, and mutual exclusion</b>\n  Consistent global state; consistent cuts.\n  Process groups; FIFO ordering; receiving vs. delivering; causal ordering;\n  total ordering.\n  Distributed mutual exclusion; central lock servers; token passing; totally\n  ordered multicst.\n\n<p></p></li>\n<li><b>Elections, consensus, and distributed transactions</b>\n  Leader elections; ring-based algorithm; the Bully algorithm.\n  Consensus.\n  Distributed transactions; atomic commit protocols; 2-phase commit.\n  Replication and consistency.\n\n<p></p></li>\n<li><b>Replication in distributed systems, CAP, case studies</b>\n  Replication and consistency (cont); strong consistency; quorum systems;\n  weak consistency; FIFO consistency; eventual consistency; Amazone\u2019s Dynamo;\n  session guarantees; Consistency, Availability and Partitions (CAP);\n  Google datacentre technologies (MapReduce).\n\n<p></p></li>\n<li><b>Further case studies, PubSub, security, NASD/AFS/Coda</b>\n  Google datacentre technologies (BigTable, Spanner).\n  Access control and the access-control matrix; ACLs vs capabilities;\n  cryptographic capabilities; role-based\n  access control (RBAC); single-system sign-on.\n  NASD, AFS, and Coda.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024700000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the difference between simple concurrent systems and\n  distributed systems;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and their\n  implications for system design;\n\n<p></p></li>\n<li>understand notions of time synchronisation, including logical clocks,\n  vector clocks, and physical time;\n\n<p></p></li>\n<li>be familiar with various approaches to data and service replication, as\n  well as the concept of data consistency;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of fundamental\n  services and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>appreciate the implications of individual node and network\n  communications failures on distributed computation;\n\n<p></p></li>\n<li>be aware of a variety of tools used by distributed-system creators,\n  such as RPC and object-oriented middleware (OOM);\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms;\n\n<p></p></li>\n<li>be familiar with a number of case studies in distributed-system design\n  including: the Network File System (NFS), the Network Time Protocol (NTP),\n  Java Remote Method Invocation (RMI), CORBA, the AFS and Coda filesystems,\n  Network-Attached Secure Disks (NASD), and Google\u2019s MapReduce, BigTable, and\n  Spanner systems.\n\n<p></p></li>\n\n\n<a name=\"SECTION03024800000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.).\n\n\n", "course_name": "Concurrent and Distributed Systems", "course_code": "ConcDisSys", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/ConcDisSys", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "ECAD+Arch": {"supervisions": 0, "lectures": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "ECAD and Architecture Practical Classes", "course_code": "ECAD+Arch", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/ECAD+Arch", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FJava": {"supervisions": 0, "lectures": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Further Java", "course_code": "FJava", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/FJava", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "GroupProj": {"supervisions": 0, "lectures": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Group Project", "course_code": "GroupProj", "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "MathMforCS": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MathematicalMethodsforComputerScience.html", "description": "\n\n\n<a name=\"SECTION03028100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03028200000000000000\">Lectures</a>\n\n<li><span class=\"textbf\">Probability methods</span> (Dr R.J. Gibbens)\n\n<p>\n</p><ul><li><b>Probability generating functions.</b> Definitions and\n    properties. Use in calculating moments of random variables and for\n    finding the distribution of sums of independent random\n    variables. [2 lectures]\n\n<p></p></li>\n<li><b>Inequalities and limit theorems.</b>  Bounds on tail\n    probabilities, moment generating functions, notions of convergence,\n    laws of large numbers, the central limit theorem,\n    statistical applications, Monte Carlo simulation. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Stochastic processes.</b>  Random walks. Recurrence and\n    transience. The Gambler\u2019s Ruin problem. Discrete-time Markov\n    chains, Chapman-Kolmogorov equations, classifications of states,\n    limiting and stationary behaviour, time-reversible Markov\n    chains. Examples and applications. [5\u00a0lectures]\n  \n</li>\n</ul>\n<p></p></li>\n<li><span class=\"textbf\">Fourier and related methods</span> (Professor J. Daugman)\n\n<p>\n</p><ul><li><b>Fourier representations.</b>  Inner product spaces and orthonormal\n    systems. Periodic functions and Fourier series. Results and\n    applications. The Fourier transform and its properties. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Discrete Fourier methods.</b> The Discrete Fourier transform,\n    efficient algorithms implementing it, and applications.  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Wavelets.</b>  Introduction to wavelets, with applications in\n    signal processing, coding, communications, and computing. [1\u00a0lecture]\n  \n</li>\n</ul>\n</li>\n\n\n<a name=\"SECTION03028300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the use of probability generating functions;\n\n<p></p></li>\n<li>understand basic probabilistic inequalities and limit results\n  and be able to apply them to commonly arising models;\n\n<p></p></li>\n<li>be familiar with the fundamental properties and uses of random\n  walks and discrete-time Markov chains;\n\n<p></p></li>\n<li>understand the fundamental properties of inner product spaces\n  and orthonormal systems;\n\n<p></p></li>\n<li>grasp key properties and uses of Fourier series and transforms,\n  and wavelets;\n\n<p></p></li>\n<li>understand discrete transform techniques, algorithms, and applications;\n\n<p></p></li>\n\n\n<a name=\"SECTION03028400000000000000\">Reference books</a>\n\n* Pinkus, A. &amp; Zafrany, S. (1997). <em>Fourier series and integral transforms</em>. Cambridge University Press.\n<br/>* Ross, S.M. (2002). <em>Probability models for computer science</em>. Harcourt/Academic Press.\n<br/>Mitzenmacher, M. &amp; Upfal, E. (2005). <em>Probability and computing: randomized algorithms and probabilistic analysis</em>. Cambridge University Press.\n<br/>Oppenheim, A.V. &amp; Willsky, A.S. (1997). <em>Signals and systems</em>.  Prentice\u00a0Hall.\n\n\n", "course_name": "Mathematical Methods for Computer Science", "course_code": "MathMforCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/MathMforCS", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CandC++": {"supervisions": 3, "lectures": 10, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html", "description": "\n\n\n<a name=\"SECTION03029100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03029200000000000000\">Lectures</a>\n\n<li><b>Introduction to the C language.</b>  Background and goals of C.\n  Types and variables.  Expressions and statements.  Functions.\n  Multiple compilation units. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Further C concepts.</b>  Preprocessor. Pointers and pointer\n  arithmetic. Data structures. Dynamic memory management.  Examples.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Introduction to C++.</b>  Goals of C++. Differences between C\n  and C++. References <i>versus</i> pointers. Overloading functions.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Objects in C++.</b>  Classes and structs. Operator overloading.\n  Virtual functions. Multiple inheritance. Virtual base classes.\n  Examples. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Further C++ concepts.</b>  Exceptions. Templates, meta-programming\nand the STL. Examples. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Linkers and loaders.</b>  Executable sections. Debug symbols.\nInspecting program state. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>C semantics.</b>  Undefined vs implementation-defined behaviour.\nCommon optimisation problems. Buffer and integer overflows. Examples.\n[1\u00a0lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION03029300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read and write C and C++ programs;\n\n<p></p></li>\n<li>understand the interaction between C and C++ programs and the\n  host operating system;\n\n<p></p></li>\n<li>be familiar with the structure of C and C++ program execution in\n  machine memory;\n\n<p></p></li>\n<li>understand the object-oriented paradigm presented by C++;\n\n<p></p></li>\n<li>be able to make effective use of templates and meta-programming\n  techniques as used in the STL;\n\n<p></p></li>\n<li>understand the potential dangers of writing programs in C and C++.\n\n<p></p></li>\n\n\n<a name=\"SECTION03029400000000000000\">Recommended reading</a>\n\n* Eckel, B. (2000). <em>Thinking in C++, Vol.\u00a01: Introduction to Standard C++</em>. Prentice\u00a0Hall (2nd ed.).  Also available at\n<br/><a href=\"http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html\" name=\"tex2html12\"><tt>http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html</tt></a>\n<br/>Kernighan, B.W. &amp; Ritchie, D.M. (1988). <em>The C programming language</em>. Prentice\u00a0Hall (2nd ed.).\n<br/>Stroustrup, B. (2008). <em>Programming -- principles and practice using C++</em>. Addison-Wesley.\n<br/>Stroustrup, B. (1994). <em>The design and evolution of C++</em>. Addison-Wesley.\n<br/>Lippman, S.B. (1996). <em>Inside the C++ object model</em>. Addison-Wesley.\n\n\n", "course_name": "Programming in C and C++", "course_code": "CandC++", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CandC++", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Prolog": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Prolog.html", "description": "\n\n\n<a name=\"SECTION030210100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030210200000000000000\">Lectures</a>\n\n<li><b>Introduction to Prolog.</b>  The structure of a Prolog program\n  and how to use the Prolog interpreter.  Unification. Some simple\n  programs.\n\n<p></p></li>\n<li><b>Arithmetic and lists.</b>  Prolog\u2019s support for evaluating\n  arithmetic expressions and lists.  The space complexity of program\n  evaluation discussed with reference to last-call optimisation.\n\n<p></p></li>\n<li><b>Backtracking, cut, and negation.</b>  The <tt>cut</tt> operator\n  for controlling backtracking.\n  <span class=\"textit\">Negation as failure</span> and its uses.\n\n<p></p></li>\n<li><b>Search and cut.</b>  Prolog\u2019s search method for solving\n  problems.  Graph searching exploiting Prolog\u2019s built-in\n  search mechanisms.\n\n<p></p></li>\n<li><b>Difference structures.</b>  Difference lists: introduction and\n  application to example programs.\n\n<p></p></li>\n<li><b>Building on Prolog.</b>  How particular limitations of Prolog\n  programs can be addressed by techniques such as Constraint Logic\n  Programming (CLP) and tabled resolution.\n\n<p></p></li>\n\n\n<a name=\"SECTION030210300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to write programs in Prolog using techniques such as\n  accumulators and difference structures;\n\n<p></p></li>\n<li>know how to model the backtracking behaviour of program\n  execution;\n\n<p></p></li>\n<li>appreciate the unique perspective Prolog gives to problem\n  solving and algorithm design;\n\n<p></p></li>\n<li>understand how larger programs can be created using the basic\n  programming techniques used in this course.\n\n<p></p></li>\n\n\n<a name=\"SECTION030210400000000000000\">Recommended reading</a>\n\n* Bratko, I. (2001). <i>PROLOG programming for artificial intelligence</i>. Addison-Wesley (3rd or 4th\u00a0ed.).\n<br/>Sterling, L. &amp; Shapiro, E. (1994). <i>The art of Prolog</i>. MIT Press (2nd\u00a0ed.).\n\nFurther reading:\n\nO\u2019Keefe, R. (1990). <i>The craft of Prolog</i>. MIT Press. [This book is beyond the scope of this course, but it is very instructive. If you understand its contents, you\u2019re more than prepared for the examination.]\n\n\n", "course_name": "Prolog", "course_code": "Prolog", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Prolog", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Semantics": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SemanticsofProgrammingLanguages.html", "description": "\n\n\n<a name=\"SECTION030211100000000000000\">Aims</a>\n\n<br/>\n<a name=\"SECTION030211200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Transition systems.  \n  The idea of structural operational semantics. \n  Transition semantics of a simple imperative language. \n  Language design options. \n[2 lectures]\n\n<p></p></li>\n<li><b>Types.</b>  Introduction to formal type systems.\n  Typing for the simple imperative language.\n  Statements of desirable properties.\n[2 lectures]\n\n<p></p></li>\n<li><b>Induction.</b>  Review of mathematical induction. Abstract\n  syntax trees and structural induction. Rule-based inductive\n  definitions and proofs. Proofs of type safety\n  properties. \n[2 lectures]\n\n<p></p></li>\n<li><b>Functions.</b>  Call-by-name and call-by-value function\n application, semantics and typing. Local recursive\n definitions. \n[2 lectures]\n\n<p></p></li>\n<li><b>Data.</b> Semantics and typing for products, sums, records,\nreferences.\n[1 lecture]\n\n<p></p></li>\n<li><b>Subtyping.</b>  Record subtyping and simple object encoding.\n[1 lecture]\n\n<p></p></li>\n<li><b>Semantic equivalence.</b>  Semantic equivalence of phrases in a\nsimple imperative language, including the congruence property.\nExamples of equivalence and non-equivalence.\n[1 lecture]\n\n<p></p></li>\n<li><b>Concurrency.</b>  Shared variable interleaving. Semantics for\nsimple mutexes; a serializability property.\n[1 lecture]\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION030211300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with rule-based presentations of the operational\n  semantics and type systems for some simple imperative, functional\n  and interactive program constructs;\n\n<p></p></li>\n<li>be able to prove properties of an operational semantics using\n  various forms of induction (mathematical, structural, and\n  rule-based);\n\n<p></p></li>\n<li>be familiar with some operationally-based notions of semantic\n  equivalence of program phrases and their basic properties.\n\n<p></p></li>\n\n\n<a name=\"SECTION030211400000000000000\">Recommended reading</a>\n\n* Pierce, B.C. (2002). <em>Types and programming languages</em>. MIT Press.\n<br/>Hennessy, M. (1990). <em>The semantics of programming languages</em>. Wiley. Out of print, but available on the web at <a href=\"http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf\" name=\"tex2html13\"><tt>http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf</tt></a>\n<br/>Winskel, G. (1993). <em>The formal semantics of programming languages</em>. MIT Press.\n\n\n", "course_name": "Semantics of Programming Languages", "course_code": "Semantics", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Semantics", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "SWEng": {"supervisions": 2, "lectures": 6, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareEngineering.html", "description": "\n\n\n<a name=\"SECTION030212100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030212200000000000000\">Lectures</a>\n\n\n<li><b>The software crisis.</b>  \nExamples of large-scale project failure, such as the London Ambulance \nService system and the NHS National Programme for IT. Intrinsic \ndifficulties with software.\n\n<p></p></li>\n<li><b>The software life cycle.</b>\nGetting the requirements right; requirements analysis methods; modular \ndesign; the role of prototyping; the waterfall, spiral and evolutionary \nmodels.\n\n<p></p></li>\n<li><b>Critical systems.</b>\nExamples of catastrophic failure; particular problems with real-time\nsystems; usability and human error; verification and validation.\n\n<p></p></li>\n<li><b>Quality assurance.</b>\nThe contribution of reviews and testing; reliability growth models; software\nmaintenance and configuration management; life-cycle costs.\n\n<p></p></li>\n<li><b>Tools.</b>\nThe effect of high-level languages; object-oriented systems and \nobject reuse; an overview of formal methods with some application \nexamples; project planning tools; automated testing tools.\n\n<p></p></li>\n<li><b>Guest lecture.</b>\nA guest lecture from an industry speaker about the realities of\nmanaging software development in a commercial environment.\n\n<p></p></li>\n\n\n<a name=\"SECTION030212300000000000000\">Objectives</a>\n\nAt the end of the course students should know how writing programs\nwith tough assurance targets, in large teams, or both, differs from\nthe programming exercises they have engaged in so far. They should\nappreciate the waterfall, spiral and evolutionary models of software\ndevelopment and be able to explain which kinds of software project\nmight profitably use them. They should appreciate the value of other\ntools and the difference between incidental and intrinsic complexity.\nThey should understand the software development life cycle and its\nbasic economics. They should be prepared for the organizational\naspects of their Part\u00a0IB group project.\n\n\n<a name=\"SECTION030212400000000000000\">Recommended reading</a>\n\n* Pressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>Leveson, N. (1994). <i>Safeware</i>. Addison-Wesley.\n<br/>Maguire, S. (1993). <i>Writing solid code</i>. Microsoft Press.\n\nFurther reading:\n\nBrooks, F.P. (1975). <i>The mythical man month</i>. Addison-Wesley.\n<br/>Reason, J. (2008). <i>The human contribution</i>. Ashgate Publishing.\n<br/>Leveson, N. (2008). <i>System safety engineering: back to the future</i>, available at\n<br/><a href=\"http://sunnyday.mit.edu/book2.pdf\" name=\"tex2html14\"><tt>http://sunnyday.mit.edu/book2.pdf</tt></a>\n<br/>Neumann, P. (1994). <i>Computer-related risks</i>. ACM Press.\n<br/><i>Report of the inquiry into the London Ambulance Service</i> (SW Thames RHA, 40 Eastbourne Terrace, London W2 3QR, February 1993).\n<br/><a href=\"http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html\" name=\"tex2html15\"><tt>http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html</tt></a>\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapters 25 and 26). Wiley. Alternatively see 2001 edition, Chapters 22 and 23, available at\n<br/><a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html16\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n\n", "course_name": "Software Engineering", "course_code": "SWEng", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/SWEng", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "UnixTools": {"supervisions": 0, "lectures": 8, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION030213100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION030213200000000000000\">\nLectures</a>\n\n\n<li><b>Unix concepts.</b> Brief review of Unix history and design\n  philosophy, documentation, terminals, inter-process communication\n  mechanisms and conventions, shell, command-line arguments,\n  environment variables, file descriptors.\n\n<p>\n</p></li>\n<li><b>Shell concepts.</b> Program invocation, redirection, pipes,\n  file-system navigation, argument expansion, quoting, job control,\n  signals, process groups, variables, locale, history and alias\n  functions, security considerations.\n\n<p>\n</p></li>\n<li><b>Scripting.</b> Plain-text formats, executables, <tt>#!</tt>,\n  shell control structures and functions. Startup scripts.\n\n<p>\n</p></li>\n<li><b>Text, file and networking tools.</b> sed, grep, chmod, find,\n  ssh, rsync, tar, zip, etc.\n\n<p>\n</p></li>\n<li><b>Revision control systems.</b> diff, patch, RCS, Subversion, git.\n\n<p>\n</p></li>\n<li><b>Software development tools.</b> C compiler, linker, debugger,\n  make.\n\n<p>\n</p></li>\n<li><b>Perl.</b> Introduction to a powerful scripting and\n  text-manipulation language. [2\u00a0lectures]\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION030213300000000000000\">\nObjectives</a>\n\n\nAt the end of the course students should\n\n\n\n<li>be confident in performing routine user tasks on a POSIX system,\n  understand command-line user-interface conventions and know how to\n  find more detailed documentation;\n\n<p>\n</p></li>\n<li>appreciate how simple tools can be combined to perform a large\n  variety of tasks;\n\n<p>\n</p></li>\n<li>be familiar with the most common tools, file formats and\n  configuration practices;\n\n<p>\n</p></li>\n<li>be able to understand, write, and maintain shell scripts and\n  makefiles;\n\n<p>\n</p></li>\n<li>appreciate how using revision control systems and fully\n  automated build processes help to maintain reproducibility and\n  audit trails during software development;\n\n<p>\n</p></li>\n<li>know enough about basic development tools to be able to install,\n  modify and debug C source code;\n\n<p>\n</p></li>\n<li>have understood the main concepts of and gained initial\n  experience in writing Perl scripts (excluding the facilities for\n  object-oriented programming).\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION030213400000000000000\">\nRecommended reading</a>\n\n\nRobbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th ed.).\n<br/>\nSchwartz, R.L., Foy, B.D. &amp; Phoenix, T. (2011). <em>Learning Perl</em>. O\u2019Reilly (6th ed.).\n\n\n\n", "course_name": "Unix Tools", "course_code": "UnixTools", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/UnixTools", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompConstr": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html", "description": "\n\n\n<a name=\"SECTION03031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03031200000000000000\">Lectures</a>\n\n<li><b>Overview of compiler structure</b>\nThe spectrum of interpreters and compilers; compile-time and run-time.\nCompilation as a sequence of translations\nfrom <em>higher-level</em> to <em>lower-level</em> intermediate languages, where \neach translation preserves semantics. \nThe structure of a simple compiler: \nlexical analysis and syntax analysis, type checking, intermediate representations, optimisations, code generation. \nOverview of run-time data structures: stack and heap.  Virtual machines. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Lexical analysis and syntax analysis.</b>\nLexical analysis based on regular expressions and finite state automata. \nUsing LEX-tools. How does LEX work? \nParsing based on context-free grammars and push-down automata. \nGrammar ambiguity, left- and right-associativity and operator precedence.\nUsing YACC-like tools. How does YACC work? \nLL(k) and LR(k) parsing theory. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Compiler Correctness</b>\nRecursive functions can be transformed \ninto iterative functions using the \nContinuation-Passing Style (CPS) transformation. \nCPS applied to a (recursive) SLANG interpreter \nto derive, in a step-by-step manner, a \ncorrect stack-based compiler. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Data structures, procedures/functions</b>\nRepresenting tuples, arrays, references. \nProcedures and functions: \ncalling conventions, nested structure, non-local variables. \nFunctions as <em>first-class</em> values represented as <em>closures</em>. \nSimple optimisations: inline expansion, constant folding, \nelimination of tail recursion, peephole optimisation.\n[5\u00a0lectures]\n\n<p></p></li>\n<li><b>Advanced topics</b>\nRun-time memory management (garbage collection).  \nStatic and dynamic linking. \nObjects and inheritance; implementation of method dispatch.\nTry-catch exception mechanisms. \nCompiling a compiler via bootstrapping. \n[4\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03031300000000000000\">Objectives</a>\n\nAt the end of the course students should understand the overall\nstructure of a compiler, and will know significant details of a number\nof important techniques commonly used. They will be aware of the way\nin which language features raise challenges for compiler builders.\n\n\n<a name=\"SECTION03031400000000000000\">Recommended reading</a>\n\n* Aho, A.V., Sethi, R. &amp; Ullman, J.D. (2007). <em>Compilers: principles, techniques and tools</em>. Addison-Wesley (2nd ed.).\n<br/>Mogensen, T. \u00c6. (2011). <em>Introduction to compiler design</em>. Springer. <a href=\"http://www.diku.dk/~torbenm/Basics\" name=\"tex2html17\"><tt>http://www.diku.dk/\u00a0torbenm/Basics</tt></a>. \n\n\n\n", "course_name": "Compiler Construction", "course_code": "CompConstr", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CompConstr", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompTheory": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html", "description": "\n\n\n<a name=\"SECTION03032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03032200000000000000\">Lectures</a>\n\n<li><b>Introduction: algorithmically undecidable problems.</b>\n  Decision problems. The informal notion of algorithm, or effective\n  procedure. Examples of algorithmically undecidable problems. [1\n  lecture]\n\n<p></p></li>\n<li><b>Register machines.</b> Definition and examples; graphical\n  notation.  Register machine computable functions.  Doing arithmetic\n  with register machines. [1 lecture]\n\n<p></p></li>\n<li><b>Universal register machine.</b>  Natural number encoding of\n  pairs and lists.  Coding register machine programs as numbers.\n  Specification and implementation of a universal register\n  machine. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Undecidability of the halting problem.</b>  Statement and\n  proof. Example of an uncomputable partial function. Decidable sets\n  of numbers; examples of undecidable sets of numbers.  [1 lecture]\n\n<p></p></li>\n<li><b>Turing machines.</b> Informal description.  Definition and\n  examples.  Turing computable functions. Equivalence of register\n  machine computability and Turing computability. The Church-Turing\n  Thesis. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Primitive and partial recursive functions.</b> Definition and\n  examples.  Existence of a recursive, but not primitive recursive\n  function. A partial function is partial recursive if and only if it\n  is computable. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Lambda-Calculus.</b> Alpha and beta conversion.\n  Normalization. Encoding data. Writing recursive functions in the\n  lambda-calculus. The relationship between computable functions\n  and lambda-definable functions. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03032300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with the register machine, Turing machine and\n  lambda-calculus models of computability;\n\n<p></p></li>\n<li>understand the notion of coding programs as data, and of a universal\n  machine;\n\n<p></p></li>\n<li>be able to use diagonalisation to prove the undecidability of\n  the Halting Problem;\n\n<p></p></li>\n<li>understand the mathematical notion of partial recursive function\n  and its relationship to computability.\n\n<p></p></li>\n\n\n<a name=\"SECTION03032400000000000000\">Recommended reading</a>\n\n* Hopcroft, J.E., Motwani, R. &amp; Ullman, J.D. (2001). <em>Introduction to automata theory, languages, and computation</em>. Addison-Wesley (2nd ed.). \n<br/>* Hindley, J.R. &amp; Seldin, J.P. (2008). <em>Lambda-calculus and combinators, an introduction</em>. Cambridge University Press (2nd ed.).\n<br/>Cutland, N.J. (1980). <em>Computability: an introduction to recursive function theory</em>. Cambridge University Press.\n<br/>Davis, M.D., Sigal, R. &amp; Weyuker, E.J. (1994). <em>Computability, complexity and languages</em>. Academic Press (2nd ed.).\n<br/>Sudkamp, T.A. (2005). <em>Languages and machines</em>. Addison-Wesley (3rd ed.).\n\n\n", "course_name": "Computation Theory", "course_code": "CompTheory", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/CompTheory", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "DatabasesB": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "\n\n\n<a name=\"SECTION03033100000000000000\">Note on this transitional year</a>\n\nFor many years Databases has been a 1B course held in the Lent Term.  \nHowever, in this academic year it has been transformed into \na Michaelmas Term course for 1A students with the 75-percent option \nor (in the future) for 1B students with the 50-percent option. \nIn this transitional year the course is presented in both terms. \nThe Michaelmas Term database course is comprised of eight lectures\nand four practicals (for three \u201cticks\u201d). \nPracticals and ticks do not fit well into the current 1B pipeline, so \nDr Griffin will increase the Lent Term lectures to twelve \nby covering the material of the practical sessions \nin the lectures. \n\n<a name=\"SECTION03033200000000000000\">Aims</a>\n\nThis course introduces basic concepts for database systems as seen from \nthe perspective of application designers. \nThat is, the focus is on the abstractions supported \nby database management systems and not on how \nthose abstractions are implemented. \n\nThe database world is currently undergoing swift \nand dramatic transformations largely driven by \nInternet-oriented applications and services. \nToday many more options are available to database\napplication developers than in the past and so it \nis becoming increasingly difficult to sort fact \nfrom fiction. \nThe course attempts to cut through the fog with a \npractical approach that emphasises engineering \ntradeoffs that underpin these recent developments\nand also guide our selection of \u201cthe right \ntool for the job.\u201d \n\nThis course covers three approaches. \nFirst, the traditional mainstay of the database industry -- \nthe relational approach -- \nis described with emphasis on eliminating logical redundancy in data. \nThen two representatives of recent trends \nare presented -- graph-oriented and document-oriented databases. \nThe lectures are tightly integrated with the associated \npractical sessions where students gain hands-on experience \nwith all three of these approaches. \n\n\n<a name=\"SECTION03033300000000000000\">Lectures</a>\n\n\n<li><b>Introduction.</b>\nWhat is a database system? \nWhat is a data model? \nA central tradeoff in the choice of data representation: \noptimise for ease of updating or for fast query response. \nOn-Line Transaction Processing (OLTP) \n<span class=\"textit\">versus</span> \nOn-line Analytical Processing (OLAP). \nApplication independent <span class=\"textit\">versus</span> application specific data representations. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Conceptual modeling</b>\nThe Entity-Relationship (ER) approach as an implementation-independent \ntechnique for modeling data. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>The relational model</b>\nImplementing ER models with relational tables. \nRelational algebra and SQL. \nUpdate anomalies caused by logical redundancy. \nMinimise logical redundancy with normalised data representation. \nFunctional dependencies (FDs) as a formal means of investigating redundancy. \nWhat is transitive closure? \nWhy SQL struggles with transitive closure. \n[4\u00a0lectures]\n\n<p></p></li>\n<li><b>The graph-oriented model</b>\nThe NoSQL movement. \nImplementing ER models in a graph-oriented database. \nGraph databases: optimised for computing transitive closure. \nPath-oriented queries. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>The document-oriented model</b>\nSemi-structured data (XML, JSON). \nDocument-oriented databases. \nEmbracing data redundancy: representing data \nfor fast, application-specific, access. \nThe CAP principle for distributed database \nrelating Consistency, Availability, and Partition Tolerance. \nIntegration of relational and document-oriented approaches. \n[3\u00a0lectures]\n</li>\n\n\n<a name=\"SECTION03033400000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios\n\n<p></p></li>\n<li>know how to convert entity-relationship diagrams to relational- \nand graph-oriented implementations \n\n<p></p></li>\n<li>understand the fundamental tradeoff between the ease of updating data \nand the response time of complex queries \n\n<p></p></li>\n<li>understand that no single data architecture can be used to meet all \ndata management requirements \n\n<p></p></li>\n<li>be familiar with recent trends in the database area.\n\n<p></p></li>\n\n\n<a name=\"SECTION03033500000000000000\">Recommended reading</a>\n\nUllman, J. &amp; Widom, J. (1997) <em>A first course in database systems</em>. Prentice Hall.\n<br/>\n\n", "course_name": "Databases", "course_code": "DatabasesB", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/DatabasesB", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "LogicProof": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html", "description": "\n\n\n<a name=\"SECTION03034100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03034200000000000000\">Lectures</a>\n\n<li><b>Introduction to logic.</b>\nSchematic statements.  Interpretations and validity.  Logical\nconsequence.  Inference.\n\n<p></p></li>\n<li><b>Propositional logic.</b>\nBasic syntax and semantics.  Equivalences.  Normal forms.\nTautology checking using CNF.\n\n<p></p></li>\n<li><b>The sequent calculus.</b>\nA simple (Hilbert-style) proof system.  Natural deduction systems.\nSequent calculus rules.  Sample proofs.\n\n<p></p></li>\n<li><b>First order logic.</b>\nBasic syntax.  Quantifiers.  Semantics (truth definition).\n\n<p></p></li>\n<li><b>Formal reasoning in FOL.</b>\nFree <em>versus</em> bound variables.  Substitution. Equivalences for\nquantifiers.  Sequent calculus rules.  Examples.\n\n<p></p></li>\n<li><b>Clausal proof methods.</b>\nClause form.  A SAT-solving procedure.  The resolution rule.\nExamples.  Refinements.\n\n<p></p></li>\n<li><b>Skolem functions, Unification and Herbrand\u2019s theorem.</b>\nPrenex normal form.  Skolemisation.  Most general unifiers. A\nunification algorithm.  Herbrand models and their\nproperties.\n\n<p></p></li>\n<li><b>Resolution theorem-proving and Prolog.</b>\nBinary resolution.  Factorisation.  Example of Prolog\nexecution. Proof by model elimination.\n\n<p></p></li>\n<li><b>Satisfiability Modulo Theories.</b>\nDecision problems and procedures. How SMT solvers work.\n\n<p></p></li>\n<li><b>Binary decision diagrams.</b>\nGeneral concepts.  Fast canonical form algorithm.  Optimisations.\nApplications.\n\n<p></p></li>\n<li><b>Modal logics.</b>\nPossible worlds semantics.  Truth and validity.  A Hilbert-style\nproof system.  Sequent calculus rules.\n\n<p></p></li>\n<li><b>Tableaux methods.</b>\nSimplifying the sequent calculus.  Examples.  Adding unification.\nSkolemisation.  The world\u2019s smallest theorem prover?\n\n<p></p></li>\n\n\n<a name=\"SECTION03034300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to manipulate logical formulas accurately;\n\n<p></p></li>\n<li>be able to perform proofs using the presented formal calculi;\n\n<p></p></li>\n<li>be able to construct a small BDD;\n\n<p></p></li>\n<li>understand the relationships among the various calculi, e.g. SAT solving, resolution and Prolog;\n\n<p></p></li>\n<li>understand the concept of a decision procedure and the basic\nprinciples of \u201csatisfiability modulo theories\u201d.\n\n<p></p></li>\n<li>be able to apply the unification algorithm and to describe its uses.\n\n<p></p></li>\n\n\n<a name=\"SECTION03034400000000000000\">Recommended reading</a>\n\n* Huth, M. &amp; Ryan, M. (2004). <em>Logic in computer science: modelling and reasoning about systems</em>. Cambridge University Press (2nd ed.).\n<br/>Ben-Ari, M. (2001). <em>Mathematical logic for computer science</em>. Springer (2nd ed.).\n\n\n", "course_name": "Logic and Proof", "course_code": "LogicProof", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/LogicProof", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "ArtIntI": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligenceI.html", "description": "\n\n\n<a name=\"SECTION03041100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03041200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b> Alternate ways of thinking about\n  AI. <span class=\"textit\">Agents</span> as a unifying view of AI systems. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search I.</b> Search as a fundamental paradigm for\n  intelligent problem-solving. Simple, <span class=\"textit\">uninformed search</span>\n  algorithms. Tree search and graph search.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search II.</b> More sophisticated <span class=\"textit\">heuristic search</span>\n  algorithms. The A* algorithm and its properties. Improving memory\n  efficiency: the IDA* and recursive best first search\n  algorithms. Local search and gradient descent. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Game-playing.</b> Search in an adversarial\n  environment. The minimax algorithm and its shortcomings. Improving\n  minimax using alpha-beta pruning.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Constraint satisfaction problems (CSPs).</b> Standardising\n  search problems to a common format. The backtracking algorithm for\n  CSPs.  Heuristics for improving the search for a solution. Forward\n  checking, constraint propagation and arc consistency. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Backjumping in CSPs.</b> Backtracking, backjumping using\n  Gaschnig\u2019s algorithm, graph-based backjumping.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning I.</b> How can we\n  represent and deal with commonsense knowledge and other forms of\n  knowledge? Semantic networks, frames and rules. How can we use\n  inference in conjunction with a knowledge representation scheme to\n  perform reasoning about the world and thereby to solve problems?\n  Inheritance, forward and backward chaining. [1\u00a0lectures]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning II.</b> Knowledge\n  representation and reasoning using first order logic. The frame,\n  qualification and ramification problems.  The situation\n  calculus. [1\u00a0lectures]\n\n<p></p></li>\n<li><b>Planning I.</b> Methods for planning in advance how to solve a\n  problem. The STRIPS language. Achieving preconditions, backtracking\n  and fixing threats by promotion or demotion: the partial-order\n  planning algorithm. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Planning II.</b> Incorporating heuristics into partial-order\n  planning.  Planning graphs. The GRAPHPLAN algorithm. Planning using\n  propositional logic. Planning as a constraint satisfaction\n  problem. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Neural Networks I.</b> A brief introduction to supervised\n  learning from examples. Learning as fitting a curve to data. The\n  perceptron. Learning by gradient descent. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Neural Networks II.</b> Multilayer perceptrons and the\n  backpropagation algorithm. [1\u00a0lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION03041300000000000000\">Objectives</a>\n\nAt the end of the course students should:\n\n\n<li>appreciate the distinction between the popular view of the field\nand the actual research results;\n\n<p></p></li>\n<li>appreciate the fact that the computational complexity of most AI\n  problems requires us regularly to deal with approximate techniques;\n\n<p></p></li>\n<li>be able to design basic problem solving methods based on\n  AI-based search, knowledge representation, reasoning, planning, and\n  learning algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03041400000000000000\">Recommended reading</a>\n\nThe recommended text is:\n\n* Russell, S. &amp; Norvig, P. (2010). <em>Artificial intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd ed.).\n<br/>There are many good books available on artificial intelligence; one \nalternative is:\n\nPoole, D. L. &amp; Mackworth, A. K. (2010). <em>Artificial intelligence: foundations of computational agents</em>.  Cambridge University Press.\n\nFor some of the material you might find it useful to consult more \nspecialised texts, in particular:\n\nDechter, R. (2003). <span class=\"textit\">Constraint processing</span>. Morgan Kaufmann.\n<br/>Cawsey, A. (1998). <em>The essence of artificial intelligence</em>. Prentice\u00a0Hall.\n<br/>Ghallab, M., Nau, D. &amp; Traverso, P. (2004). <span class=\"textit\">Automated planning: theory and practice</span>. Morgan Kaufmann.\n<br/>Bishop, C.M. (2006). <em>Pattern recognition and machine learning</em>. Springer.\n<br/>\n", "course_name": "Artificial Intelligence\u00a0I", "course_code": "ArtIntI", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/ArtIntI", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Complexity": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComplexityTheory.html", "description": "\n\n\n<a name=\"SECTION03042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03042200000000000000\">Lectures</a>\n\n<li><b>Algorithms and problems.</b>\nComplexity of algorithms and of problems.  Lower and upper bounds.\nExamples: sorting and travelling salesman.\n\n<p></p></li>\n<li><b>Time and space.</b>\nModels of computation and measures of complexity.  Time and space\ncomplexity on a Turing machine. Decidability and complexity.\n\n<p></p></li>\n<li><b>Time complexity.</b>\nTime complexity classes.  Polynomial time problems and algorithms.  P\nand NP. \n\n<p></p></li>\n<li><b>Non-determinism.</b>\nNon-deterministic machines.  The class NP redefined.  Non-deterministic\nalgorithms for reachability and satisfiability.\n\n<p></p></li>\n<li><b>NP-completeness.</b>\nReductions and completeness.  NP-completeness of satisfiability.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nGraph-theoretic problems.  Hamiltonian cycle and clique.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nSets, numbers and scheduling.  Matching, set covering and bin packing.\n\n<p></p></li>\n<li><b>coNP.</b>\nValidity of boolean formulae and its\ncompleteness.  NP\u00a0\u2229\u00a0coNP.  Primality and factorisation.\n\n<p></p></li>\n<li><b>Cryptographic complexity.</b>\nOne-way functions.  The class UP.\n\n<p></p></li>\n<li><b>Space complexity.</b>\nDeterministic and non-deterministic space complexity classes.  The\nreachability method.  Savitch\u2019s theorem.\n\n<p></p></li>\n<li><b>Hierarchy.</b>\nThe time and space hierarchy theorems and complete problems.\n\n<p></p></li>\n<li><b>Descriptive complexity.</b>\nLogics capturing complexity classes.  Fagin\u2019s theorem.\n\n<p></p></li>\n\n\n<a name=\"SECTION03042300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse practical problems and classify them\naccording to their complexity;\n\n<p></p></li>\n<li>be familiar with the phenomenon of NP-completeness, and be able\nto identify problems that are NP-complete;\n\n<p></p></li>\n<li>be aware of a variety of complexity classes and their\ninterrelationships;\n\n<p></p></li>\n<li>understand the role of complexity analysis in cryptography.\n\n<p></p></li>\n\n\n<a name=\"SECTION03042400000000000000\">Recommended reading</a>\n\n* Papadimitriou, Ch.H. (1994).  <em>Computational complexity</em>. Addison-Wesley.\n<br/>Goldreich, O. (2010). <em>P, NP, and NP-Completeness: the basics of \ncomputational complexity</em>. Cambridge University Press.\nSipser, M. (1997). <em>Introduction to the theory of computation</em>. PWS.\n\n\n", "course_name": "Complexity Theory", "course_code": "Complexity", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/Complexity", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ConceptsPL": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConceptsinProgrammingLanguages.html", "description": "\n\n\n<a name=\"SECTION03043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03043200000000000000\">Lectures</a>\n\n<li><b>Introduction, motivation, and overview.</b>\nWhat is a programming language?  Application domains in language \ndesign.  Program execution models.  Theoretical foundations. \nLanguage standardization.  History.\n\n<p></p></li>\n<li><b>The ancestors: Fortran, Lisp, Algol and Pascal.</b>\nKey ideas: \n  procedural (Fortran), \n  declarative (Lisp), \n  block structured (Algol and Pascal).\nExecution models (abstract machines), \ndata types, \ncontrol structures, \nstorage, arrays and pointers, \nprocedures and forms of parameter passing,\nscope,\nstrict and lazy evaluation, \ngarbage collection.\nPrograms as data (Lisp).\n\n<p></p></li>\n<li><b>Object-oriented languages -- Concepts and origins:\nSimula\u00a0(1964-67) and Smalltalk\u00a0(1971-80).</b>\nDynamic lookup.  Abstraction.  Subtyping.  Inheritance.\nJavaScript prototypal vs Java class-based inheritance.\n\n<p></p></li>\n<li><b>Languages for parallel processing.</b>\nShared-memory concurrency with spawn/sync (OpenMP, Cilk, X10).\nDistributed-memory models (the actor model, Erlang).\nExternal vs. internal iteration.\n\n<p></p></li>\n<li><b>Types.</b>\nTypes in programming languages.\nType safety. \nType systems--static vs. dynamic.\nType checking and type inference.  Polymorphism.  Overloading.  \nType equivalence. \n\n<p></p></li>\n<li><b>Data abstraction and modularity: SML Modules\u00a0(1984-97).</b>\nInformation hiding.  Modularity.  Signatures, structures, and functors. \nSharing.\n\n<p></p></li>\n<li><b>Combining functional and object-oriented features.</b>\nScala and Java 8.\nGeneric types and methods.  Variance annotations.  The expression problem.\nValue types and deep copy.\n\n<p></p></li>\n<li><b>More-advanced concepts and idioms.</b>\nHaskell monads, type classes.\nContinuation passing style and call/cc. \nDependent types.\n\n<p></p></li>\n\n\n<a name=\"SECTION03043300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with several \nlanguage paradigms and how they relate to different application\n   domains;\n\n<p></p></li>\n<li>understand the design space of programming languages, including\n   concepts and constructs from past \nlanguages as well as those that may be used \nin the future;\n\n<p></p></li>\n<li>develop a critical understanding of the programming languages that\n   we use by being able to identify and compare the same concept as it\n   appears in different languages.\n\n<p></p></li>\n\n\n<a name=\"SECTION03043400000000000000\">Recommended reading</a>\n\n<span class=\"textbf\">Books:</span>\n<br/>* Mitchell, J.C. (2003). \n  <em>Concepts in programming languages</em>.  \n  Cambridge University Press.\n<br/>* Scott, M.L. (2009). \n  <em>Programming language pragmatics</em>.  \n  Morgan Kaufmann.\n<br/>Odersky, M. (2008). \n  <em>Scala by example</em>. \n  Programming Methods Laboratory, EPFL.\n<br/>Pratt, T.W. &amp; Zelkowitz, M.V. (2001). \n  <em>Programming languages: design and implementation</em>.  \n  Prentice Hall.\n\n<span class=\"textbf\">Papers:</span>\n<br/>Kay, A.C. (1993).  \n  The early history of Smalltalk.  \n  <em>ACM SIGPLAN Notices</em>, Vol.\u00a028, No.\u00a03.\n<br/>Kernighan, B. (1981).  \n  Why Pascal is not my favorite programming language.  \n  AT&amp;T Bell Laboratories.  \n  <em>Computing Science Technical Report</em> No.\u00a0100.\n<br/>Koenig, A. (1994).  \n  An anecdote about ML type inference.  \n  <em>USENIX Symposium on Very High Level Languages</em>.\n<br/>Landin, P.J. (1966).\n  The next 700 programming languages.\n  <em>Communications of the ACM</em>, Vol.\u00a09, Issue\u00a03.\n<br/>Odersky, M. <em>et al.</em> (2006).\n  An overview of the Scala programming language.\n  <em>Technical Report LAMP-REPORT-2006-001</em>, Second Edition.\n<br/>McCarthy, J. (1960).  \n  Recursive functions of symbolic expressions and their computation \n  by machine.  \n  <em>Communications of the ACM</em>, 3(4):184-195.\n<br/>Stroustrup, B. (1991). \n  What is Object-Oriented Programming?  (1991 revised version). \n  <em>Proceedings\u00a01st European Software Festival</em>.\n\n\n", "course_name": "Concepts in Programming Languages", "course_code": "ConceptsPL", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/ConceptsPL", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "EconLaw": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsLawandEthics.html", "description": "\n\n\n<a name=\"SECTION03044100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03044200000000000000\">Lectures</a>\n\n<li><b>Game theory.</b> The choice between cooperation and conflict. \nPrisoners\u2019 Dilemma; Nash equilibrium; hawk-dove; iterated games; \nevolution of strategies; application to biology and computer science.\n\n<p></p></li>\n<li><b>Classical economics.</b> Definitions: preference, utility, \nchoice and budget. Pareto efficiency; the discriminating monopolist;\nsupply and demand; elasticity; utility; the marginalist revolution; \ncompetitive equilibrium and the welfare theorems. Trade; monopoly \nrents; public goods; oligopoly.\n\n<p></p></li>\n<li><b>Market failure.</b> Asymmetric information: the market for \nlemons; adverse selection; moral hazard; signalling; and brands.\nTransaction costs and the theory of the firm. Real and virtual networks, \nsupply-side <em>versus</em> demand-side scale economies, Metcalfe\u2019s law, \nthe dominant firm model, price discrimination. Behavioural economics:\nbounded rationality, heuristics and biases.\n\n<p></p></li>\n<li><b>Auctions.</b> English auctions; Dutch auctions; all-pay\nauctions; Vickrey auctions. The winner\u2019s curse. The revenue\nequivalence theorem.  Mechanism design and the combinatorial\nauction. Problems with real auctions. Applicability of auction\nmechanisms in computer science.\n\n<p></p></li>\n<li><b>Principles of law.</b> Contract and tort; copyright and patent; \nbinding actions; liabilities and remedies; competition law; choice of\nlaw and jurisdiction.\n\n<p></p></li>\n<li><b>Law and the Internet.</b> EU directives including distance \nselling, electronic commerce, data protection, electronic signatures \nand copyright; their UK implementation. UK laws that specifically\naffect the Internet, including RIP.\n\n<p></p></li>\n<li><b>Ethics.</b> Philosophies of ethics: authority, intuitionist, \negoist and deontological theories. Utilitarian and Rawlsian models. \nInsights from evolutionary psychology and neorology. The Internet and \nsocial policy; current debates on privacy, surveillance, censorship\nand export control.\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION03044300000000000000\">Objectives</a>\n\nAt the end of the course students should have a basic appreciation of\neconomic and legal terminology and arguments. They should understand\nsome of the applications of economic models to systems engineering and\ntheir interest to theoretical computer science. They should also\nunderstand the main constraints that markets, legislation and ethics\nplace on firms dealing in information goods and services.\n\n<br/>\n<a name=\"SECTION03044400000000000000\">Recommended reading</a>\n\n* Shapiro, C. &amp; Varian, H. (1998). <em>Information rules</em>. Harvard Business School Press.\n<br/>Varian, H. (1999). <em>Intermediate microeconomics - a modern approach</em>. Norton.\n\nFurther reading:\n\nSmith, A. (1776). <i>An inquiry into the nature and causes of the wealth of \nnations</i>, available at\u00a0\u00a0\u00a0\u00a0<a href=\"http://www.econlib.org/library/Smith/smWN.html\" name=\"tex2html18\"><tt>http://www.econlib.org/library/Smith/smWN.html</tt></a>\n<br/>Poundstone, W. (1992). <i>Prisoner\u2019s dilemma</i>. Anchor Books.\n<br/>Levitt, S.D. &amp; Dubner, S.J. (2005). <i>Freakonomics</i>. Morrow.\n<br/>Seabright, P. (2005). <i>The company of strangers</i>. Princeton.\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapter 7). Wiley.\n<br/>Galbraith, J.K. (1991). <i>A history of economics</i>. Penguin.\n<br/>Lessig L. (2005). <i>Code and other laws of cyberspace v2</i>, available at\n<br/><a href=\"http://www.lessig.org/\" name=\"tex2html19\"><tt>http://www.lessig.org/</tt></a>\n\n", "course_name": "Economics, Law and Ethics", "course_code": "EconLaw", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/EconLaw", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "SecurityI": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SecurityI.html", "description": "\n\n\n<a name=\"SECTION03045100000000000000\">\nAims</a>\n\n\n<a name=\"SECTION03045200000000000000\">\nLectures</a>\n\n\n<li><b>Introduction.</b> Malicious intent. Security policies, targets,\n  mechanisms. Aspects of confidentiality, integrity, availability,\n  privacy. Requirements across different applications.\n\n<p>\n</p></li>\n<li><b>Cryptography.</b> Overview, private vs. public-key ciphers,\n  MACs vs. signatures, certificates, capabilities of adversary,\n  Kerckhoffs\u2019 principle.\n\n<p>\n</p></li>\n<li><b>Classic ciphers.</b> Attacks on substitution and transposition\n  ciphers, Vigen\u00e9re. Perfect secrecy: one-time pads.\n\n<p>\n</p></li>\n<li><b>Private-key encryption.</b> Stream ciphers, pseudo-random\n  generators, attacking linear-congruential RNGs and LFSRs. Semantic\n  security definitions, oracle queries, advantage, computational\n  security, security proofs.\n\n<p>\n</p></li>\n<li><b>Block ciphers.</b> Pseudo-random functions and permutations.\n  Birthday problem, random mappings. Feistel/Luby-Rackoff structure,\n  DES, TDES, AES.\n\n<p>\n</p></li>\n<li><b>Chosen-plaintext attack security.</b> Security with multiple\n  encryptions, randomized encryption. Modes of operation: ECB, CBC,\n  OFB, CNT.\n\n<p>\n</p></li>\n<li><b>Message authenticity.</b> Malleability, MACs, existential\n  unforgeability, CBC-MAC, ECBC-MAC, CMAC, birthday attacks,\n  Carter-Wegman one-time MAC.\n\n<p>\n</p></li>\n<li><b>Authenticated encryption.</b> Chosen-ciphertext attack\n  security, ciphertext integrity, encrypt-and-authenticate,\n  authenticate-then-encrypt, encrypt-then-authenticate, padding oracle\n  example, GCM.\n\n<p>\n</p></li>\n<li><b>Entity authentication.</b> Passwords, trusted path, phishing,\n  CAPTCHA. Authentication protocols: replay attacks, one-way and\n  challenge-response protocols, Needham-Schroeder, protocol failure\n  examples.\n\n<p>\n</p></li>\n<li><b>Discretionary access control.</b> Matrix model, DAC in POSIX\n  and Windows, elevated rights and setuid bits, capabilities,\n  Clark-Wilson integrity.\n\n<p>\n</p></li>\n<li><b>Operating system security.</b> Trusted computing base, domain\n  separation, reference mediation, residual information protection.\n\n<p>\n</p></li>\n<li><b>Software security.</b> Malicious software. Common\n  implementation vulnerabilities: buffer overflows, integer overflows,\n  meta characters, syntax incompatibilities, race conditions,\n  unchecked values, side channels, random-bit sources.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION03045300000000000000\">\nObjectives</a>\n\n\nBy the end of the course students should \n\n\n\n<li>be familiar with core security terms and concepts;\n\n<p>\n</p></li>\n<li>understand security definitions of modern private-key\n  cryptographic primitives;\n\n<p>\n</p></li>\n<li>understand the POSIX and Windows NTFS discretionary access\n  control system;\n\n<p>\n</p></li>\n<li>understand the most common security pitfalls in software\n  development.\n\n<p>\n</p></li>\n\n\n<a name=\"SECTION03045400000000000000\">\nRecommended reading</a>\n\n\nKatz, J., Lindell, Y. (2015). <em>Introduction to modern cryptography</em>. Chapman &amp; Hall/CRC (2nd ed.).\n<br/>\nPaar, Ch. &amp; Pelzl, J. (2010). <em>Understanding cryptography</em>. Springer.\n<br/>\nGollmann, D. (2010). <em>Computer security</em>. Wiley (3rd ed.).\n\n\n\n", "course_name": "Security\u00a0I", "course_code": "SecurityI", "course_url": "https://www.cl.cam.ac.uk/teaching/1617/SecurityI", "lecturers": [], "year": "1617", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}}