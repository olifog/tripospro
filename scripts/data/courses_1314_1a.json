{"CompFund": {"supervisions": null, "lectures": 4, "prerequisite_for": [], "past_exam_questions": null, "description": "\nLecture 1: Bits, Bytes and Number Systems\n<li>The significance of the bit and powers of 2</li>\n<li>Data quantities (B, kB, MB, GB, etc)</li>\n<li>Number systems (decimal, binary, octal , hexadecimal)</li>\n<li>Representing negative numbers (sign-magnitude, 1s' complement, 2\u2019s complement)</li>\n<li>Binary addition (carries, overflows)</li>\n<li>Binary subtraction</li>\n\nLecture 2: How Computers Work\n<li>Brief history of computers</li>\n<li>Stored program concept</li>\n<li>Fetch-execute cycle</li>\n<li>Compilers and Interpreters</li>\n\n<a href=\"Lecture2.pdf\">Click here for the annotated notes</a>\nLecture 3: Modern Computer Components\n<li>Motherboards, buses, peripherals</li>\n<li>Memory hierarchy</li>\n<li>(S)RAM cells</li>\n<li>Spinning HDDs</li>\n<li>Flash and SSDs</li>\n<li>Graphics Cards and GPUs</li>\n<li>RISC and CISC architectures</li>\n<p><a href=\"Lecture3.pdf\">Click here for the annotated notes</a>\n</p>Lecture 4: Modern Computer Components\n<li>Operating Systms</li>\n<li>Multitasking and Process Scheduling</li>\n<li>Threads</li>\n<li>Multiprocessor and Multicore systems</li>\n<li>Concurrency problems (race conditions etc)</li>\n<li>Visrtucalisation</li>\n\n<a href=\"Lecture4.pdf\">Click here for the annotated notes</a>\n", "course_name": "Computer Fundamentals", "course_code": "CompFund", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/CompFund", "lecturers": ["rkh23"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": null, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "\n\n\n<a name=\"SECTION02023100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02023200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p></p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\n\n<p></p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p></p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p></p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p></p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p></p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p></p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n\n<p></p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p></p></li>\n<li><b>Electronics, Devices and Circuits.</b>  Current and voltage, resistance, basic circuit theory, the potential divider. \n  Solving non-linear circuits. Resistor-Capacitor (RC) circuits.\n  Materials, semiconductors and the p-n junction, i.e., the diode. n and p channel MOSFETs and n-MOSFET logic, e.g., n-MOSFET inverter. \n  CMOS logic. Logic families. Noise margin. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02023300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p></p></li>\n<li>be able to design and minimise combinational logic;\n\n<p></p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p></p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p></p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p></p></li>\n<li>understand how to use MOSFETs to build digital logic circuits.\n\n<p></p></li>\n<li>understand the effect of finite load capacitance on the performance of digital logic circuits.\n\n<p></p></li>\n\n\n<a name=\"SECTION02023400000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture</em>. Morgan Kaufmann.\n<br/>Katz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>Hayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\nBooks for reference:\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>Weste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>Mead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>Crowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>Gibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/DigElec", "lecturers": ["ijw24"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "FoundsCS": {"supervisions": 4, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "\n\n\n<a name=\"SECTION02021100000000000000\">Aims</a>\n\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using O-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\nThe course will use a functional language (ML).  ML is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso introduce traditional (procedural) programming, such as\nassignments, arrays and references.\n\n\n<a name=\"SECTION02021200000000000000\">Lectures</a>\n\n<li><b>Introduction to Programming.</b>\nThe role of abstraction and representation.  Introduction to integer and floating-point arithmetic.\nDeclaring functions. Decisions and booleans. Example: integer exponentiation.\n\n<p></p></li>\n<li><b>Recursion and Efficiency.</b>\nExamples: Exponentiation and summing integers.  Overloading. Iteration <em>versus</em> recursion. \nExamples of growth rates.  Dominance and <span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$O$\" border=\"0\" height=\"21\" src=\"img1.png\" width=\"19\"/></span> Notation.  The costs\nof some representative functions.  Cost estimation.\n\n<p></p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p></p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p></p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p></p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p></p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p></p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying. \nThe \u201capply to all\u201d functional, <tt>map</tt>.  \n<span class=\"textit\">Examples</span>: matrix transpose and product.  \nThe predicate functionals <tt>filter</tt> and <tt>exists</tt>.\n\n<p></p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in ML.\nApplications, for example Newton-Raphson square roots.\n\n<p></p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p></p></li>\n<li><b>Polynomial arithmetic.</b>\nAddition, multiplication of polynomials using ideas from sorting,\netc.\n\n<p></p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not. Introduction to linked lists. \n\n<p></p></li>\n\n\n<a name=\"SECTION02021300000000000000\">Objectives</a>\n\nAt the end of the course, students should\n\n\n<li>be able to write simple ML programs;\n\n<p></p></li>\n<li>understand the fundamentals of using a data structure to represent some mathematical abstraction;\n\n<p></p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p></p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p></p></li>\n<li>understand binary search and binary search trees;\n\n<p></p></li>\n<li>know how to use currying and higher-order functions;\n\n<p></p></li>\n<li>understand how ML combines imperative and functional programming in a single language.\n\n<p></p></li>\n\n\n<a name=\"SECTION02021400000000000000\">Recommended reading</a>\n\n* Paulson, L.C. (1996). <em>ML for the working programmer</em>. Cambridge University Press (2nd\u00a0ed.).\n<br/>Okasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\nFor reference only:\n<br/>Gansner, E.R. &amp; Reppy, J.H. (2004). <em>The Standard ML Basis Library</em>. Cambridge University Press. ISBN: 0521794781\n\n\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/FoundsCS", "lecturers": ["lp15"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n<li><a href=\"hardware_13.pdf\">Notes</a> for hardware practical classes</li>\n\n<a href=\"../../1213/HW/\">Last year\u2019s course materials</a> are still available.\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/HW", "lecturers": ["ijw24"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "ML": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\nCourse Handouts and Information\n\n<p>In each of the practical slots there will be demonstrators\navailable to assist with the tick exercises. Students should aim to do\none tick per week completely within their allocated two hour slot\n(i.e. without having to work outside the Computer Lab). However, all\nof the exercises are available below, and students are free to do the\nwork wherever they choose and in their own time (it will still be\nnecessary to sign up for a ticking slot for each tick).\n\n</p><p> Computer scientists must do all of the unstarred ticks (1-5\ninclusive). Natural scientists and PBS students must do the first four\nunstarred ticks (1-4 inclusive). Starred ticks (1*, 2*,...) are\nstrictly optional and only there to challenge those who find the\nunstarred variant easy. They do not count for the exam.\n\n</p><p></p><ul> <li><a href=\"ticks.pdf\">ML exercises 1\u20135</a></li>\n</ul>\n<h2>Practical Group Timings and Allocations\n\n<p>Please see the <a href=\"http://www.cl.cam.ac.uk/teaching/1314/Registratn/\">Registration session</a> pages\n\n\n</p><h2>Ticking Sign-up sheet\n\n<p>Now that the ML practicals are over, the ticking sign up has moved\nto the <a href=\"http://www.cl.cam.ac.uk/teaching/1314/ProgJava/materials.html\">Programming in Java web pages</a>\n</p><p>Tickers on 14/11/13 will be able to tick both ML and Java\nsubmissions. Thereafter it may be possible to obtain ML ticks in the\nJava sessions, but priority is for Java ticks and this practice may be stopped. There will be extra ML ticking sessions in Lent term (in particular for the CSTs who need to complete tick 5 over the vacation)\n</p></h2></h2>", "course_name": "ML Practical Classes", "course_code": "ML", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/ML", "lecturers": ["lp15"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 4, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgrammingMethodsandJava.html", "description": "\n\n\n<a name=\"SECTION02022100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02022200000000000000\">Syllabus</a>\n\n\n<li><b>Types, Objects and Classes</b> Moving from functional to\n  imperative. Distinguishing state and behaviour. Primitive\n  types. Function prototypes. Objects and classes as custom\n  types. Introduction to parameterised types (templates/Generics).\n\n<p></p></li>\n<li><b>Pointers, References and Memory</b> Pointers and\n  references. The call stack and heap. Iteration and\n  recursion. Pass-by-value and pass-by-reference. Objects as reference\n  types in Java.\n\n<p></p></li>\n<li><b>Creating Classes</b> Modularity. Encapsulation. Information\n  hiding. Access modifiers. \u00a0Advantages of immutability. Creating\n  Generic types in Java. Static data.\n\n<p></p></li>\n<li><b>Inheritance</b> Inheritance. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.\n\n<p></p></li>\n<li><b>Polymorphism and Multiple Inheritance</b> Polymorphism in ML\n  and Java. Multiple inheritance. Interfaces in Java.  \n\n<p></p></li>\n<li><b>Lifecycle of an Object</b> Constructors and chaining. Destructors. Finalizers. Garbage Collection.  Copying Objects. Shallow and deep copies. Copy\n  constructors. Cloning in Java. Cloneable as a marker interface in\n  Java.\n\n<p></p></li>\n<li><b>Java Collections</b> Java Collection interface. Key\n  classes. Collections class. Iteration options and the use of\n  Iterator.  \n\n<p></p></li>\n<li><b>Object Comparison</b> Comparing primitive and reference\n  types. Equals. Comparable and Comparator in Java. Operator\n  Overloading.\n\n<p></p></li>\n<li><b>Error Handling</b> Limitations of return\n  values. Exceptions. Custom exceptions.\n\n<p></p></li>\n<li><b>Design Patterns</b> Introduction to design patterns. Examples\n  of Singleton, Decorator, State, Strategy, Observer.  \n\n<p></p></li>\n<li><b>Case Studies and Worked Examples</b>\n<p></p></li>\n\n\n<a name=\"SECTION02022300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the principles of OOP;\n\n<p></p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p></p></li>\n<li>understand the capabilities and limitations of Java;\n\n<p></p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p></p></li>\n<li>be familiar with common errors in Java and its associated\n  libraries.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022400000000000000\">Recommended reading</a>\n\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>Gamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>Bloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/OOProg", "lecturers": ["rkh23"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OpSystems": {"supervisions": 4, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "\n\n\n<a name=\"SECTION02025100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02025200000000000000\">Lectures</a>\n\n<li><b>Introduction to operating systems.</b> Abstract view of an operating system. OS evolution: multi-programming, time-sharing. Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels, Elementary computer architecture [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Processes and scheduling.</b> Job/process concepts. Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Memory management.</b> Processes in memory. Logical addresses. Partitions: static <em>versus</em> dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>I/O subsystem.</b> General structure. Polled mode <em>versus</em> interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking <em>versus</em> non-blocking I/O. Other issues: caching, scheduling, spooling, performance. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>File management.</b> File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Protection.</b> Requirements. Subjects and objects. Design principles. Authentication schemes. Access matrix: ACLs and capabilities. Combined scheme. Covert channels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Unix case study. History.</b> General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection, pipes, signals. Character and block I/O. Process scheduling. [2\u00a0lectures]\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION02025300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>describe the general structure and purpose of an operating\n  system; \n\n<p></p></li>\n<li>explain the concepts of process, address space, and file;\n\n<p></p></li>\n<li>compare and contrast various CPU scheduling algorithms;\n\n<p></p></li>\n<li>understand the differences between segmented and paged memories,\n  and be able to describe the advantages and disadvantages of each;\n\n<p></p></li>\n<li>compare and contrast polled, interrupt-driven and DMA-based\n  access to I/O devices.\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION02025400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>.  Addison-Wesley (3rd ed.).\n<br/>Silberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <i>Operating systems concepts</i>. Wiley (8th ed.).\n<br/>Leffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>Solomon, D. &amp; Russinovich, M. (2000). <em>Inside Windows 2000</em>. Microsoft Press (3rd ed.).\n\n\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/OpSystems", "lecturers": ["iml1"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "ProgJava": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Programming in Java", "course_code": "ProgJava", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/ProgJava", "lecturers": ["arb33", "acr31"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Registratn": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\nTiming and Location\nSlides from the Registration Talk\n<li> <a href=\"intro.pdf\">Introduction</a> by Professor Ann Copestake\n</li><li> <a href=\"CLRegistration1314.pdf\">Course details</a> by Dr Robert Harle\n</li><li> <a href=\"StudentAdminPresentation.pptx\">Student Admin slides</a>\n</li><li> <a href=\"MCS.pdf\">MCS slides</a>\n</li><li> <a href=\"CLRegistration1314srcf.pdf\">CourseSRCF slides</a>\n</li>\nPractical Group Allocations\n<li> Group A has ML/Java practicals 4-6pm on Thursdays starting 17 October\n</li><li> Group B has ML/Java practicals 2-4pm on Thursdays starting 17 October\n</li>\nCST students also have hardware practicals every second week, starting in week 3 (October 24). These are arranged in subgroups of A and B base don whether the week number is odd or even:\n\n<li> Group AO (A, odd) Hardware practicals 1.30-4pm on Thursdays of weeks 3,5,7\n</li><li> Group AE (A, even) Hardware practicals 1.30-4pm on Thursdays of weeks 4,6,8\n</li><li> Group BO (B, odd) Hardware practicals 10.30-1pm on Thursdays of weeks 3,5,7\n</li><li> Group BE (B, even) Hardware practicals 10.30-1pm on Thursdays of weeks 4,6,8\n</li>\nFor absolute clarity, here are the dates:\n\n<li> Week 1: October 10\n</li><li> Week 2: October 17 [ML practicals start]\n</li><li> Week 3: October 24 [Hardware practicals start]\n</li><li> Week 4: October 31\n</li><li> Week 5: November 7\n</li><li> Week 6: November 14\n</li><li> Week 7: November 21\n</li><li> Week 8: November 28\n</li>\nUseful links\n<li> <a href=\"http://www.cl.cam.ac.uk/teaching/1314/part1a-cst.html\">Course web pages for CST</a>\n</li><li> <a href=\"http://www.cl.cam.ac.uk/teaching/1314/part1a-other.html\">Course web pages for NST or PBST</a>\n</li><li> <a href=\"http://www.amazon.co.uk/Cambridge-Computing-The-First-Years/dp/190650783X\">Cambridge Computing: The First 75 Years</a> by Haroon Ahmed\n</li>\nProfessional Bodies\nYou are eligible to join one or both of the UK's professional bodies covering Computer Science. These are the Institute of Engineering and Technology (IET) and the British Computing Society (BCS). Both of these entities have provided brief slides to introduce themselves, and both offer highly reduced fees for students\n\n<li> Download the <a href=\"iet.pdf\"> IET presentation</a> or <a href=\"http://www.theiet.org/join\">join online</a> (\u00a320 p.a. or \u00a350 entire course)\n</li><li>  Download the <a href=\"bcs.pdf\"> BCS presentation</a> or <a href=\"http://www.bcs.org/student\">join online</a> (\u00a332 p.a. or \u00a352 entire course)\n</li>\n", "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/Registratn", "lecturers": ["rkh23"], "year": "1314", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Algorithms": {"supervisions": 8, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms.html", "description": "\n\n\n<a name=\"SECTION02031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02031200000000000000\">Lectures</a>\n\n<li><b>Sorting.</b>  Review of complexity and O-notation. Trivial\n  sorting algorithms of quadratic complexity. Review of merge sort and\n  quicksort, understanding their memory behaviour on statically\n  allocated arrays. Heapsort. Stability. Other sorting methods\n  including sorting in linear time. Median and order statistics.\n  [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9] [about 4 lectures] \n<p></p></li>\n<li><b>Strategies for algorithm design.</b>\nDynamic programming, divide and conquer, greedy algorithms and other \nuseful paradigms.\n[Ref: CLRS3 chapters 4, 15, 16] [about 3 lectures] \n<p></p></li>\n<li><b>Data structures.</b>  Primitive data structures. Abstract data\n  types. Pointers, stacks, queues, lists, trees. Binary search\n  trees. Red-black trees. B-trees. Hash tables. Priority queues and\n  heaps.  [Ref: CLRS3 chapters 6, 10, 11, 12, 13, 18] [about 5 lectures] \n<p></p></li>\n<li><b>Advanced data structures.</b>  Amortized analysis: aggregate\n  analysis, potential method. Fibonacci heaps. Van Emde Boas\n  trees. Disjoint sets.  [Ref: CLRS3 chapters 17, 19, 20, 21] [about 5\n    lectures]\n\n<p></p></li>\n<li><b>Graph algorithms.</b>  Graph representations. Breadth-first and\n  depth-first search. Topological sort. Minimum spanning tree. Kruskal\n  and Prim algorithms. Single-source shortest paths: Bellman-Ford and\n  Dijkstra algorithms.  All-pairs shortest paths: matrix\n  multiplication and Johnson\u2019s algorithms. Maximum flow:\n  Ford-Fulkerson method. Matchings in bipartite graphs.  [Ref: CLRS3\n    chapters 22, 23, 24, 25, 26] [about 5 lectures]\n\n<p></p></li>\n<li><b>Multithreaded algorithms.</b>  Dynamic\n  multithreading. Modelling framework: work and span. Greedy\n  scheduler. Determinacy races.  [Ref: CLRS3 chapter 27] [about 1\n    lecture]\n\n<p></p></li>\n<li><b>Geometric algorithms.</b>  Intersection of segments. Convex\n  hull: Graham\u2019s scan, Jarvis\u2019s march.  [Ref: CLRS3 chapter 33] [about\n    1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION02031300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>have a thorough understanding of several classical algorithms\n  and data structures;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p></p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\n\n<a name=\"SECTION02031400000000000000\">Recommended reading</a>\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein,\nC. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN\n978-0-262-53305-8\n<br/>Sedgewick, R., Wayne, K. (2011). <em>Algorithms</em> Addison-Wesley. ISBN\n978-0-321-57351-3.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.\n<br/>Knuth, D.A. (2011). <em>The Art of Computer\n  Programming</em>. Addison-Wesley. ISBN 978-0-321-75104-1.\n<br/>\n<br/>\nStudents hoping to receive a computer science degree from Cambridge\nare expected to buy, make extensive use of, and keep as reference for\ntheir future career, one of the above fundamental textbooks: those not\ndoing so will be severely disadvantaged. The recommended choice is\nCormen, Leiserson, Rivest and Stein (CLRS3, starred in the above list)\nwhich covers all topics listed and, in spite of its superb quality, is\nthe cheapest: about 35 GBP new for over 1300 pages. The references in\nthe syllabus are to this textbook. The other textbooks listed are\nexcellent additions for further study but might cost more and yet not\ncover the entire syllabus.\n\n\n", "course_name": "Algorithms", "course_code": "Algorithms", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/Algorithms", "lecturers": ["fms27", "tms41"], "year": "1314", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "DiscMath": {"supervisions": 8, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "\n\n\n<a name=\"SECTION02032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02032200000000000000\">Lectures</a>\n\n\n<li><b>Mathematical argument [3\u00a0lectures].</b>\n<p>Proofs in practice.  Propositional statements: conjunction, disjunction,\n  implication, equivalence, negation.  Universal and existential\n  statements: predicates and quantification.  Logical notation and\n  inference. \n  \n</p><p></p></li>\n<li><b>Numbers [4\u00a0lectures].</b>\n<p>Inductive definitions and induction principles (mathematical induction,\n  course-of-values induction, least-number principle).\n  \n</p><p>Divisibility and prime numbers.  The fundamental theorem of arithmetic.\n  The greatest common divisor and Euclid\u2019s algorithm.\n  \n</p><p>Modular arithmetic: the Chinese remainder theorem, Wilson\u2019s theorem,\n  Fermat\u2019s theorem, Euler\u2019s theorem.  \n  \n</p><p>Public key cryptography: Diffie-Hellman, RSA.\n  \n</p><p></p></li>\n<li><b>Mathematical structure [10\u00a0lectures].</b>\n<p>Sets: membership, extensionality, comprehension, Russell\u2019s paradox.\n  Finite and infinite sets. Cardinality.\n  \n</p><p>Mathematical data types: product, sum (or disjoint union), powerset.\n  Finite constructions and counting.  \n  \n</p><p>The boolean algebra of sets: intersection, union, complement,\n  difference, symmetric difference.  Venn and Hasse diagrams.\n  \n</p><p>More mathematical data types: relations, partial functions, (total)\n  functions.  Finite constructions and counting.  Characteristic (or\n  indicator) functions.\n  \n</p><p>The algebra of relations and matrices.  Directed graphs (or digraphs):\n  reflexivity, symmetry, transitivity.  Transitive closure.  Weighted\n  digraphs and shortest paths.\n  \n</p><p>Functions: bijections, injections, surjections.  Finite constructions and\n  counting.  Inverse and direct images.\n  \n</p><p>Combinatorial identities and bijective proofs.  Partitions, equivalence\n  relations, Stirling and Bell numbers.\n  \n\n</p><p>The lattice of partitions and information theory.  Discrete Shannon\n  entropy for partitions of finite sample spaces.  The\n  equipartition-maximises-information lemma.  \n  \n</p><p>Countable and uncountable sets.  Infinite sets: indexed sets, big\n  intersections and unions, indexed sums and products, finite sequences.\n  Calculus of bijections.  \n  \n</p><p>Set cardinality increase.  Diagonalisation:  Russell\u2019s paradox, Cantor\u2019s\n  diagonalisation argument, Lawvere\u2019s fixed-point theorem.\n  \n</p><p></p></li>\n<li><b>Formal languages and automata [7\u00a0lectures].</b>\n<p>Introduction to inductive definitions using rules and proof by rule\n  induction. Abstract syntax trees.\n  \n</p><p>Regular expressions and their algebra.  \n  \n</p><p>Finite automata and regular languages: Kleene\u2019s theorem and the Pumping\n  Lemma.\n  </p></li>\n\n\n<a name=\"SECTION02032300000000000000\">Objectives</a>\n\nOn completing the course, students should be able to\n\n\n<li>prove and disprove mathematical statements using a variety of\n  techniques; \n\n<p></p></li>\n<li>apply the mathematical principle of induction;\n\n<p></p></li>\n<li>know the basics of modular arithmetic and appreciate its role in\n  cryptography; \n\n<p></p></li>\n<li>understand and use the language of set theory in applications to\n  computer science;\n\n<p></p></li>\n<li>define sets inductively using rules and prove properties about them; \n\n<p></p></li>\n<li>convert between regular expressions and finite automata; \n\n<p></p></li>\n<li>use the Pumping Lemma to prove that a language is not regular.\n\n<p></p></li>\n\n\n<a name=\"SECTION02032400000000000000\">Recommended reading</a>\n\nBiggs, N.L. (2002). \n  <em>Discrete mathematics.</em> \n  Oxford University Press (Second Edition).\n<br/>Bloch, E.D. (2011).\n  <em>Proofs and fundamentals: a first course in abstract mathematics.</em>\n  Springer (Second Edition).\n<br/>Devlin, K. (2003). \n  <em>Sets, functions, and logic: an introduction to abstract mathematics.</em> \n  Chapman and Hall/CRC Mathematics (Third Edition).\n<br/>Eccles, P.J. (1997)\n  <em>An introduction to mathematical reasoning</em>\n  Cambridge University Press.\n<br/>* Houston, K. (2009).\n  <em>How to think like a mathematician: a companion to undergraduate\n    mathematics.</em>\n  Cambridge University Press.\n<br/>* Kozen, D.C. (1997). \n  <em>Automata and computability</em>. \n  Springer.\n<br/>* Lehman, E.; Leighton, F.T.; Meyer, A.R. (2012).\n  <em>Mathematics for computer science, Revised edition.</em>\nP\u00f3lya, G. (1980). \n  <em>How to solve it.</em> \n  Penguin. \nVelleman, D.J. (2006).\n  <em>How to prove it: a structured approach.</em>\n  Cambridge University Press (Second Edition).\n\n\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/DiscMath", "lecturers": ["mpf23", "amp12"], "year": "1314", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "FJavaBrfg": {"supervisions": null, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION02043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02043200000000000000\">Lecture</a>\n\nThe lecture describes the requirements for the first assessed\nexercise of the Part\u00a0IB Further Java course.\n\n\n<a name=\"SECTION02043300000000000000\">Objectives</a>\n\nOn completing the exercise students should\n\n\n<li>be prepared for the Part\u00a0IB Further Java course;\n\n<p></p></li>\n<li>have developed their practical Java programming skills further.\n\n<p></p></li>\n\n\n\n", "course_name": "Further Java Briefing", "course_code": "FJavaBrfg", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/FJavaBrfg", "lecturers": ["arb33"], "year": "1314", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "NumMethods": {"supervisions": 4, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Floating-PointComputation.html", "description": "\n\n\n<a name=\"SECTION02041100000000000000\">Aims</a>\n\n<li>an introduction to\n(IEEE) floating-point data representation and arithmetic; \n</li>\n<li>illustrations of how na\u00efve implementations of obvious mathematics can go badly wrong;\n</li>\n<li>a study of several standard numerical algorithms.\n</li>\n\nAn overall implicit aim is to encourage caution when using any\nfloating-point value produced by a computer program.\n\n\n<a name=\"SECTION02041200000000000000\">Lectures</a>\n\n<li><b>Integer and floating-point representation and arithmetic.</b>\nSigned and unsigned integers and fixed-point; arithmetic, saturating arithmetic.\nIEEE 754/854 floating point (32 and 64 bit); zeros, infinities, NaN.\nWhat numbers are exactly representable in bases 2 and 10.\nAccuracy in terms of significant figures.\nFloating-point arithmetic is non-associative, and mathematical equivalences fail.\nNonsensical results, e.g. <tt>sin(1e40)</tt>.\n\n<p></p></li>\n<li><b>IEEE floating-point arithmetic.</b>\nFloating-point arithmetic, and the IEEE requirements.\nWhy the IEEE standard has endured.\nOverflow, underflow, progressive loss of significance.\n      Rounding modes.\nDifficulty in obtaining IEEE-quality in libraries.\nThe java.lang.Math trigonometric library promises.\n\n<p></p></li>\n<li><b>How floating-point computations diverge from real-number calculations.</b>\nAbsolute Error, Relative Error, Machine epsilon, Unit in Last Place (ulp).\nFinite computation: solving a quadratic.\nSumming a finite series.\nRounding (round-off) and truncation (discretisation) error.\nNumerical differentiation; determining a good step size.\n\n<p></p></li>\n<li><b>Iteration and when to stop.</b>\nUnbounded computation may produce unbounded errors.\nSolving equations by iteration and comparison to terminate it.\nNewton\u2019s method.\nOrder of convergence.\nWhy summing a Taylor series is problematic.\n\n<p></p></li>\n<li><b>Custom Encodings</b> \nArbitrary precision floating point, adaptive floating point, interval\narithmetic.\nLogarithmic and other non-linear representations. Their use in a-posteriori decision algorithms.\nEg for rapid multiplication in Viterbi/Bayes and specialist ALUs (e.g. for low-density parity).\n\n<p></p></li>\n<li><b>Matrix Methods</b> \nGaussian Elimination. L/U and Cholesky decompositions.  Doolittle, Crout methods.\nTheir stability and usefulness.\n\n<p></p></li>\n<li><b>Efficient Implementation</b>\nChebychev orthogonal basis (for power series economisation) \nPractical implementation of scientific (trig/log) functions. \nComparison of Taylor, Chebychev and Cordic.\n\n<p></p></li>\n<li><b>Ill Conditioning and Chaotic Simulations.</b>\nRole of partial derivatives and backwards stability.\nCondition number when amenable to mathematical analysis;\nMonte-Carlo exploration when not.\nFinite-difference simulation and chaos in weather forecasting and Mandelbrot.\n\n<p></p></li>\n<li><b>Adaptive methods</b>\nLinear approximations.\nWave propagation simulation.\nNon-linear spatial quantisation.\nDynamic temporal quantisation and its use in SPICE.\n\n<p></p></li>\n<li><b>Miscellaneous Topics</b>\nDiscussion on the problems of exact real arithmetic.\nRemark on the x86 implementations of IEEE arithmetic, interaction of coding style and compiler\n\u201coptimisations\u201d.\nFinal Remarks. \n\n<p></p></li>\n\n\n<a name=\"SECTION02041300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to convert simple decimal numbers to and from IEEE\n  floating-point format, and to perform IEEE arithmetic on them;\n\n<p></p></li>\n<li>be able to identify problems with floating-point implementations of\n      simple mathematical problems and know when incorrect solution is likely;\n\n<p></p></li>\n<li>be familiar with several key algorithms from the history of numerical analysis;\n\n<p></p></li>\n<li>decide how and when computation energy should be traded for accuracy;\n\n<p></p></li>\n<li>know to use a professionally-written package whenever possible\n      (and still to treat claims of accuracy with suspicion).\n\n<p></p></li>\n\n\n<a name=\"SECTION02041400000000000000\">Recommended reading</a>\n\nOverton, M.L. (2001). <em>Numerical computing with IEEE floating point arithmetic</em>. SIAM.\n\nFurther reading - goes far beyond the course\n\nGoldberg, D. (1991). <em>What every computer scientist should know about floating-point arithmetic</em>. ACM Computing Surveys, vol. 23, pp. 5-48.\n\n\n", "course_name": "Numerical Methods", "course_code": "NumMethods", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/NumMethods", "lecturers": ["djg11"], "year": "1314", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWIDesign": {"supervisions": 4, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandInterfaceDesign.html", "description": "\n\n\n<a name=\"SECTION02042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02042200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Design process overview: Inception phase,\r\n  Elaboration phase, Construction phase, Transition phase (1 lecture).\n\n<p></p></li>\n<li><b>Inception.</b>  Structured description of system usage\r\n  and function (2 lectures).\n\n<p></p></li>\n<li><b>Elaboration.</b> Development and evaluation of\r\n  interactive prototypes (2 lectures).\n\n<p></p></li>\n<li><b>Construction.</b> Use of source code as a design model (1 lecture).\n\n<p></p></li>\n<li><b>Transition.</b> Testing and debugging techniques (2 lectures).\n\n<p></p></li>\n<li><b>Evaluation.</b> Measurement with respect to design objectives (2 lectures).\n\n<p></p></li>\n<li><b>Iteration.</b> Design process responses to uncertainty and\r\n  requirements change (1 lecture).\n\n<p></p></li>\n\n\n<a name=\"SECTION02042300000000000000\">Objectives</a>\n\nAt the end of the course, students should be able to undertake design of an\ninteractive system in a methodical manner, starting from a general requirement, analysing user needs, developing a design model, approaching iterative model\r\nrefinement and implementation in a manner that minimises risk, and\r\nusing appropriate methods to identify and prevent faults.\n\n\n<a name=\"SECTION02042400000000000000\">Recommended reading</a>\n\nPressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>Sharp, H., Rogers, Y. &amp; Preece, J. (2007). <i>Interaction design: beyond \r\nhuman-computer interaction</i>. Wiley (2nd ed.).\n<br/>Further reading\n\nMcConnell, S. (2004). <i>Code complete: a practical handbook of software construction</i>. Microsoft Press (2nd ed.).\n<br/>Broy, M. &amp; Denert, E. (ed.) (2002). <i>Software pioneers: contributions to software engineering</i>. Springer-Verlag.\n<br/>Schon, D.A. (1990). <i>Educating the reflective practitioner</i>. Jossey-Bass.\n<br/>\n\n", "course_name": "Software and Interface Design", "course_code": "SWIDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1314/SWIDesign", "lecturers": ["afb21"], "year": "1314", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}