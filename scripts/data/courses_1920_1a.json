{"Databases": {"supervisions": 3, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "\n\n\nAims\nThe database world is currently undergoing swift \nand dramatic transformations largely driven by \nInternet-oriented applications and services. \nToday many more options are available to database\napplication developers than in the past and so it \nis becoming increasingly difficult to sort fact \nfrom fiction. \nThe course attempts to cut through the fog with a \npractical approach that emphasises engineering \ntradeoffs that underpin these recent developments\nand also guide our selection of \u201cthe right \ntool for the job.\u201d \n\nThis course covers three approaches. \nFirst, the traditional mainstay of the database industry -- \nthe relational approach -- \nis described with emphasis on eliminating logical redundancy in data. \nThen two representatives of recent trends \nare presented -- graph-oriented and document-oriented databases. \nThe lectures are tightly integrated with the associated \npractical sessions where students gain hands-on experience \nwith all three of these approaches. \n\nLectures\n\n<li><b>Introduction.</b>\nWhat is a database system? \nWhat is a data model? \nA central tradeoff in the choice of data representation: \noptimise for ease of updating or for fast query response. \nOn-Line Transaction Processing (OLTP) \n<span class=\"textit\">versus</span> \nOn-line Analytical Processing (OLAP). \nApplication independent <span class=\"textit\">versus</span> application specific data representations. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Conceptual modeling</b>\nThe Entity-Relationship (ER) approach as an implementation-independent \ntechnique for modeling data. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>The relational model</b>\nImplementing ER models with relational tables. \nRelational algebra and SQL. \nUpdate anomalies caused by logical redundancy. \nMinimise logical redundancy with normalised data representation. \nWhat is transitive closure? \nWhy SQL struggles with transitive closure. \n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>The graph-oriented model</b>\nThe NoSQL movement. \nImplementing ER models in a graph-oriented database. \nGraph databases: optimised for computing transitive closure. \nPath-oriented queries. \n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>The document-oriented model</b>\nSemi-structured data (XML, JSON). \nDocument-oriented databases. \nEmbracing data redundancy: representing data \nfor fast, application-specific, access. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>The multi-dimensional model</b>.\nData cubes, star schema, data warehouse.\n[1\u00a0lecture]\n</li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios\n\n<p></p></li>\n<li>know how to convert entity-relationship diagrams to relational- \nand graph-oriented implementations \n\n<p></p></li>\n<li>understand the fundamental tradeoff between the ease of updating data \nand the response time of complex queries \n\n<p></p></li>\n<li>understand that no single data architecture can be used to meet all \ndata management requirements \n\n<p></p></li>\n<li>be familiar with recent trends in the database area.\n\n<p></p></li>\n\nRecommended reading\nLemahieu, W., Broucke, S. van den &amp; Baesens, B. (2018) <em>Principles of database management</em>. Cambridge University Press.\n\n\n\n", "course_name": "Databases", "course_code": "Databases", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Databases", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p></p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\nQuine-McCluskey method.\n\n<p></p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p></p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p></p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p></p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p></p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p></p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n  Elimination of redundant states.\n\n<p></p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p></p></li>\n<li><b>Introduction to microprocessors.</b> Microarchitecture, fetch,\n  register access, memory access, branching, execution time.\n\n<p></p></li>\n<li><b>Electronics, Devices and Circuits.</b> Current and voltage, resistance,\n  basic circuit theory, the potential divider. Solving non-linear circuits.\n  N and p channel MOSFETs and n-MOSFET logic, e.g., n-MOSFET inverter.\n  Switching speed and power consumption problems in n-MOSFET logic. CMOS logic.\n  Logic families. Noise margin. Analogue interfacing and operational\n  amplifiers.  [3\u00a0lectures]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p></p></li>\n<li>be able to design and minimise combinational logic;\n\n<p></p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p></p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p></p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p></p></li>\n<li>understand how to use MOSFETs to build digital logic circuits.\n\n<p></p></li>\n<li>understand the effect of finite load capacitance on the performance of\n  digital logic circuits.\n\n<p></p></li>\n<li>understand basic analogue interfacing.\n\n<p></p></li>\n\nRecommended reading\n* Harris, D.M. &amp; Harris, S.L. (2013). <em>Digital design and computer architecture</em>. Morgan Kaufmann (2nd ed.). The first edition is still relevant.\n<br/>Katz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>Hayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\nBooks for reference:\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>Weste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>Mead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>Crowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>Gibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/DigElec", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMath": {"supervisions": 6, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Proof [5\u00a0lectures].</b>\n<p>Proofs in practice and mathematical jargon. Mathematical statements:\n  implication, bi-implication, universal quantification, conjunction,\n  existential quantification, disjunction, negation.  Logical deduction: proof\n  strategies and patterns, scratch work, logical equivalences.  Proof by\n  contradiction.  Divisibility and congruences.  Fermat\u2019s Little Theorem.\n\n</p><p></p></li>\n<li><b>Numbers [5\u00a0lectures].</b>\n<p>Number systems: natural numbers, integers, rationals, modular integers.  The\n  Division Theorem and Algorithm.  Modular arithmetic.  Sets: membership and\n  comprehension.  The greatest common divisor, and Euclid\u2019s Algorithm and\n  Theorem. The Extended Euclid\u2019s Algorithm and multiplicative inverses in\n  modular arithmetic.  The Diffie-Hellman cryptographic method.  Mathematical\n  induction: Binomial Theorem, Pascal\u2019s Triangle, Fundamental Theorem of\n  Arithmetic, Euclid\u2019s infinity of primes.\n\n</p><p></p></li>\n<li><b>Sets [9\u00a0lectures].</b>\n<p>Extensionality Axiom: subsets and supersets.  Separation Principle:\n  Russell\u2019s Paradox, the empty set.  Powerset Axiom: the powerset Boolean\n  algebra, Venn and Hasse diagrams.  Pairing Axiom: singletons, ordered pairs,\n  products.  Union axiom: big unions, big intersections, disjoint unions.\n  Relations: composition, matrices, directed graphs, preorders and partial\n  orders.  Partial and (total) functions.  Bijections: sections and\n  retractions.  \n  Equivalence relations and set partitions. Calculus of bijections: characteristic (or indicator) functions.  Finite\n  cardinality and counting.  Infinity axiom.  \n  Surjections. \nEnumerable and countable sets.  Axiom of choice.  \n  Injections. \nImages:  direct and inverse images.  Replacement Axiom: set-indexed\n  constructions.  Set cardinality: Cantor-Schoeder-Bernstein Theorem,\n  unbounded cardinality, diagonalisation, fixed-points.  Foundation Axiom.\n\n</p><p></p></li>\n<li><b>Formal languages and automata [5\u00a0lectures].</b>\n<p>Introduction to inductive definitions using rules and proof by rule\n  induction. Abstract syntax trees.\n  \n\n</p><p>Regular expressions and their algebra.  \n  \n\n</p><p>Finite automata and regular languages: Kleene\u2019s theorem and the Pumping\n  Lemma.\n  \n</p></li>\n\nObjectives\nOn completing the course, students should be able to\n\n\n<li>prove and disprove mathematical statements using a variety of\n  techniques; \n\n<p></p></li>\n<li>apply the mathematical principle of induction;\n\n<p></p></li>\n<li>know the basics of modular arithmetic and appreciate its role in\n  \ncryptography; \n\n<p></p></li>\n<li>understand and use the language of set theory in applications to\n  computer science;\n\n<p></p></li>\n<li>define sets inductively using rules and prove properties about them; \n\n<p></p></li>\n<li>convert between regular expressions and finite automata; \n\n<p></p></li>\n<li>use the Pumping Lemma to prove that a language is not regular.\n\n<p></p></li>\n\nRecommended reading\nBiggs, N.L. (2002). \n  <em>Discrete mathematics.</em> \n  Oxford University Press (Second Edition).\n<br/>Davenport, H. (2008).\n  <em>The higher arithmetic: an introduction to the theory of numbers.</em>\n  Cambridge University Press.\n<br/>Hammack, R. (2013).\n  <em>Book of proof.</em>\n  Privately published (Second edition). Available at:\n<br/> <a href=\"http://www.people.vcu.edu/~rhammack/BookOfProof/index.html\" name=\"tex2html4\"><tt>http://www.people.vcu.edu/\u00a0rhammack/BookOfProof/index.html</tt></a>\n<br/>Houston, K. (2009).\n\n<em>How to think like a mathematician: a companion to undergraduate\n    mathematics.</em>\n  Cambridge University Press.\n<br/>Kozen, D.C. (1997). \n  <em>Automata and computability</em>. \n  Springer.\n<br/>Lehman, E.; Leighton, F.T.; Meyer, A.R. (2014).\n  <em>Mathematics for computer science.</em> \n  Available on-line.\n<br/>Velleman, D.J. (2006).\n  <em>How to prove it: a structured approach.</em>\n  Cambridge University Press (Second Edition).\n\n\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/DiscMath", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "\n\n\nAims\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using <span class=\"MATH\"><i>O</i></span>-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\nThe course will use a functional language (OCaml).  OCaml is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash and OCaml\u2019s unobtrusive type system captures many program faults\nbefore execution.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso introduce traditional (procedural) programming, such as\nassignments, arrays and references.\n\nLectures\n<li><b>Introduction to Programming.</b>\nThe role of abstraction and representation.  Introduction to integer and floating-point arithmetic.\nDeclaring functions. Decisions and booleans. Example: integer exponentiation.\n\n<p></p></li>\n<li><b>Recursion and Efficiency.</b>\nExamples: Exponentiation and summing integers. Iteration <em>versus</em>\nrecursion. Examples of growth rates.  Dominance and <span class=\"MATH\"><i>O</i></span>-Notation.  The costs\nof some representative functions.  Cost estimation.\n\n<p></p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p></p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p></p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p></p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p></p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p></p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying. The \u201capply to all\u201d functional, <tt>map</tt>.  \n<span class=\"textit\">Examples</span>: The predicate functionals <tt>filter</tt> and <tt>exists</tt>.\n\n<p></p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in OCaml.\nApplications, for example Newton-Raphson square roots.\n\n<p></p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p></p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not. Introduction to linked lists. \n\n<p></p></li>\n\nObjectives\nAt the end of the course, students should\n\n\n<li>be able to write simple OCaml programs;\n\n<p></p></li>\n<li>understand the fundamentals of using a data structure to represent some mathematical abstraction;\n\n<p></p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p></p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p></p></li>\n<li>understand binary search and binary search trees;\n\n<p></p></li>\n<li>know how to use currying and higher-order functions;\n\n<p></p></li>\n<li>understand how OCaml combines imperative and functional programming in a single language.\n\n<p></p></li>\n\nRecommended reading\nJohn Whitington. <em>OCaml from the Very Beginning</em>. (http://ocaml-book.com).\n<br/>Okasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\n\n\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/FoundsCS", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n <li><a href=\"Hardware_19.pdf\">Notes</a> for hardware practical classes</li>\n\n<a href=\"../../1819/HW/\">Last year\u2019s course materials</a> are still available.\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/HW", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Graphics": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoGraphics.html", "description": "\n\n\nAims\nLectures\n<li><b>Background.</b> What is an image? Resolution and quantisation. Storage of\nimages in memory. [1 lecture]\n\n<p></p></li>\n<li><b>Rendering.</b> Perspective. Reflection of light from surfaces and shading.\nGeometric models. Ray tracing. [2 lectures]\n\n<p></p></li>\n<li><b>Graphics pipeline.</b> Polygonal mesh models. Transformations using\nmatrices in 2D and 3D. Homogeneous coordinates. Projection: orthographic\nand perspective. [1 lecture]\n\n<p></p></li>\n<li><b>Graphics hardware and modern OpenGL.</b> GPU rendering. GPU frameworks and APIs. Vertex processing.\nRasterisation. Fragment processing. Working with meshes and textures. Z-buffer. Double-buffering and frame synchronization. [3 lectures]\n\n<p></p></li>\n<li><b>Colour</b>. Perception of colour. Colour spaces. [1 lecture]\n\n<p></p></li>\n\nObjectives\nBy the end of the course students should be able to:\n\n\n<li>understand and apply in practice basic concepts of ray-tracing: ray-object intersection, reflections, refraction, shadow rays, distributed ray-tracing, direct and indirect illumination;\n\n<p></p></li>\n<li>describe and explain the following algorithms:  Gouraud and Phong shading, z-buffer, texture mapping, double buffering, mip-map, bump- and normal-mapping;\n\n<p></p></li>\n<li>use matrices and homogeneous coordinates to represent and perform 2D and 3D transformations; understand and use 3D to 2D projection, the viewing volume, and 3D clipping;\n\n<p></p></li>\n<li>implement OpenGL code for rendering of polygonal objects, control camera and lighting, work with vertex and fragment shaders;\n\n<p></p></li>\n<li>describe a number of colour spaces and their relative merits.\n\n<p></p></li>\n\nRecommended reading\n* Shirley, P. &amp; Marschner, S. (2009). <em>Fundamentals of Computer Graphics</em>. CRC Press (3rd ed.).\n<br/>Foley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>Kessenich, J.M., Sellers, G. and  Shreiner, D (2016). <em>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.5 with SPIR-V</em>, [seventh edition and later]\n\n\n", "course_name": "Introduction to Graphics", "course_code": "Graphics", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Graphics", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OCaml": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\nAssessment\n<li>A new ML tick is set each Thursday, for five consecutive weeks, starting October 10th.</li>\n<li>For each tick you must check it out and submit it via the <a href=\"https://hub.cl.cam.ac.uk/\">hub.cl.cam.ac.uk</a> assessment site. The site will automatically assess the solution and tell you whether the solution is sufficient to pass. (See instructions <a href=\"#jup\">below</a> on how to use this site and access the ticks).</li>\n<li>Initially you will be awarded a score of 0.5. When you have a tick you will be upgraded to 1.0 (which signifies awarding the tick).</li>\n<li>Each tick must pass the automated checker by 1700 on the completion date.</li>\n<li>Every two weeks on a Thursday afternoon you will be assigned a ticking slot where you will meet with a ticker who will go over your solutions from the past fortnight with you.</li>\n\nThe Role of Tickers\n\n<li>to check you understand your solution (and didn\u2019t just have some lucky guesses or copy code from elsewhere)</li>\n<li>to give you general feedback on ways to improve your code.</li>\n\nTo those ends a Ticker will typically ask you questions related to the core material of the tick and discuss your code directly.\nDeadline Extensions\nDeadline extensions can be granted for illness or similar reasons. To obtain an extension please email Anil Madhavapeddy and Amanda Prorok in the first instance, clearly stating your justification for an extension and CCing your Director of Studies, who will need to support your request.\nErrata and Problems\nPlease make use of the Help Forum (on the Moodle site for this course) if you spot any errors in these ticks or you have any difficulties submitting your work.\nHow to Submit a Tick\nTicks are conducted via the <a href=\"https://hub.cl.cam.ac.uk/\">interactive FoCS notebook site</a>.  When you first\nlog in there, you will see a directory and some tabs.\n<img alt=\"tick1\" src=\"focs-ticks-1.png\" width=\"600px\"/>\n\nClick on the <tt>Assignments</tt> tab to find your ticks.\n<img alt=\"tick2\" src=\"focs-ticks-2.png\" width=\"600px\"/>\n\nThe ticks that have been released will be available there for you.  The next step is to expand them to find the assignment:\n<img alt=\"tick3\" src=\"focs-ticks-3.png\" width=\"600px\"/>\n\nClick on <tt>Fetch</tt> on the assignment to clone it over to your notebook.\n<img alt=\"tick4\" src=\"focs-ticks-4.png\" width=\"600px\"/>\n\nOnce the assignment is fetched, it is available for you to view and edit it.\n<img alt=\"tick5\" src=\"focs-ticks-5.png\" width=\"600px\"/>\n\nAt this point, you need to edit the notebook and execute the cells (via the <tt>Cell</tt> menu) to validate\nyour answers.  Once you are happy with your answers, go back to the directory page and click on <tt>Validate</tt>\nto run it through the automatic checker, and then <tt>Submit</tt> when you want to hand it in.\n<img alt=\"tick6\" src=\"focs-ticks-6.png\" width=\"600px\"/>\n\nGood luck, and we hope your enjoy your foray into functional programming!\n", "course_name": "OCaml Practical Classes", "course_code": "OCaml", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/OCaml", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html", "description": "\n\n\nAims\nLecture syllabus\n\n<li><b>Types, Objects and Classes</b> Moving from functional to\n  imperative. Functions, methods. Control flow. values, variables and\n  types. Primitive Types. Classes as custom types. Objects vs\n  Classes. Class definition, constructors. Static data and methods.\n\n<p></p></li>\n<li><b>Designing Classes</b> Identifying classes. UML class\n  diagrams. Modularity. Encapsulation/data\n  hiding. Immutability. Access modifiers. Parameterised types\n  (Generics).\n\n<p></p></li>\n<li><b>Pointers, References and Memory</b> Pointers and\n  references. Reference types in Java. The call stack. The\n  heap. Iteration and recursion. Pass-by-value and\n  pass-by-reference.\n\n<p></p></li>\n<li><b>Inheritance</b> Inheritance. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.\n\n<p></p></li>\n<li><b>Polymorphism and Multiple Inheritance</b> Polymorphism in ML\n  and Java. Multiple inheritance. Interfaces in Java.  \n\n<p></p></li>\n<li><b>Lifecycle of an Object</b> Constructors and\n  chaining. Destructors. Finalizers. Garbage Collection: reference\n  counting, tracing.\n\n<p></p></li>\n<li><b>Java Collections and Object Comparison</b> Java Collection\n  interface. Key classes. Collections class. Iteration options and the\n  use of Iterator. Comparing primitives and objects. Operator\n  overloading.\n\n<p></p></li>\n<li><b>Error Handling</b> Types of errors. Limitations of return\n  values. Deferred error handling. Exceptions. Custom\n  exceptions. Checked vs unchecked. Inappropriate use of\n  exceptions. Assertions.\n\n<p></p></li>\n<li><b>Copying Objects</b>. Shallow and deep copies. Copy\n  constructors. Cloning in Java. Cloneable as a marker interface in\n  Java.\n\n<p></p></li>\n<li><b>DesignLanguage evolution</b> Need for languages to\n   evolve. Generics in Java. Type erasure. Introduction to Java 8:\n   Lambda functions, functions as values, method references, streams.\n\n<p></p></li>\n<li><b>Design Patterns</b> Introduction to design\n  patterns. Open-closed principle. Examples of Singleton, Decorator,\n  State, Composite, Strategy, Observer.  [2 lectures]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be familiar with the main features and limitations of the Java\n  language;\n\n<p></p></li>\n<li>be able to write a Java program to solve a well specified problem;\n\n<p></p></li>\n<li>understand the principles of OOP;\n\n<p></p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p></p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p></p></li>\n<li>be familiar with common errors in Java and its associated\n    libraries;\n\n<p></p></li>\n<li>understand a Java program written by someone else;\n\n<p></p></li>\n<li>be able to debug and test Java programs;\n\n<p></p></li>\n<li>be familiar with major parts of Java 8 SE libraries;\n\n<p></p></li>\n<li>understand how to read Javadoc library documentation and reuse\n    library code.\n\n<p></p></li>\n\nRecommended reading\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, Python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>Gamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>Bloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/OOProg", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n", "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Registratn", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "SciComp": {"supervisions": 0, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\nAims\nSyllabus\n\n<li>Python notebooks.\nOverview of the Python programming language. Use of notebooks for scientific computing.\n\n<p></p></li>\n<li>Numerical computation.\nWriting fast vectorized code in <tt>numpy</tt>. Optimization and fitting. Simulation.\n\n<p></p></li>\n<li>Working with data.\nData import. Common ways to summarize and plot data, for univariate and multivariate analysis.\n</li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to import data, plot it, and summarize it appropriately\n\n<p></p></li>\n<li>be able to write fast vectorized code for scientific / data work\n</li>\n\n\n", "course_name": "Scientific Computing Practical Course", "course_code": "SciComp", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/SciComp", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Algorithms": {"supervisions": 6, "lectures": 24, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms.html", "description": "\n\n\nAims\nLectures\n<li><b>Sorting.</b>  Review of complexity and O-notation. Trivial\n  sorting algorithms of quadratic complexity. Review of merge sort and\n  quicksort, understanding their memory behaviour on statically\n  allocated arrays. Heapsort. Stability. Other sorting methods\n  including sorting in linear time. Median and order statistics.\n  [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9] [about 4 lectures]\n\n<p></p></li>\n<li><b>Strategies for algorithm design.</b>  Dynamic programming,\n  divide and conquer, greedy algorithms and other useful paradigms.\n  [Ref: CLRS3 chapters 4, 15, 16] [about 3 lectures]\n\n<p></p></li>\n<li><b>Data structures.</b>  Elementary data structures: pointers,\n  objects, stacks, queues, lists, trees. Binary search\n  trees. Red-black trees. B-trees. Hash tables. Priority queues and\n  heaps.  [Ref: CLRS3 chapters 6, 10, 11, 12, 13, 18] [about 5\n    lectures]\n\n<p></p></li>\n<li><b>Graph algorithms.</b>  Graph representations. Breadth-first and\n  depth-first search. Topological sort. Minimum spanning tree. Kruskal\n  and Prim algorithms. Single-source shortest paths: Bellman-Ford and\n  Dijkstra algorithms.  All-pairs shortest paths: matrix\n  multiplication and Johnson\u2019s algorithms. Maximum flow:\n  Ford-Fulkerson method, Max-Flow Min-Cut Theorem. Matchings in\n  bipartite graphs.  [Ref: CLRS3 chapters 22, 23, 24, 25, 26] [about 7\n    lectures]\n\n<p></p></li>\n<li><b>Advanced data structures.</b>  Binomial heap. Amortized\n  analysis: aggregate analysis, potential method. Fibonacci\n  heaps. Disjoint sets.  [Ref: CLRS3 chapters 17, 19, 20, 21] [about 4\n    lectures]\n\n<p></p></li>\n<li><b>Geometric algorithms.</b>  Intersection of segments. Convex\n  hull: Graham\u2019s scan, Jarvis\u2019s march.  [Ref: CLRS3 chapter 33] [about\n    1 lecture]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should:\n\n\n<li>have a thorough understanding of several classical algorithms\n  and data structures;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p></p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\nRecommended reading\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein,\nC. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN\n978-0-262-53305-8\n<br/>Sedgewick, R., Wayne, K. (2011). <em>  Algorithms</em>. Addison-Wesley. ISBN 978-0-321-57351-3.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.\n<br/>Knuth, D.A. (2011). <em>The Art of Computer\n  Programming</em>. Addison-Wesley. ISBN 978-0-321-75104-1.\n<br/>\n", "course_name": "Algorithms", "course_code": "Algorithms", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Algorithms", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "MLRD": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MachineLearningandReal-worldData.html", "description": "\n\n\nAims\n\n<li>Statistical classification: Determining movie review\n  sentiment using Naive Bayes (7 sessions);\n</li>\n<li>Sequence Analysis: Hidden Markov Modelling and its application to a task from biology (predicting protein interactions with a cell membrane) (4 sessions);\n</li>\n<li>Analysis of social networks, including detection of\n  cliques and central nodes (5 sessions).\n</li>\n\nSyllabus\n\n<li><b>Topic One: Statistical Classification [7 sessions].</b>\n<br/>Introduction to sentiment classification.\n<br/>Naive Bayes parameter estimation.\n<br/>Statistical laws of language.\n<br/>Statistical tests for classification tasks.\n<br/>Cross-validation and test sets.\n<br/>Uncertainty and human agreement.\n<br/><p></p></li>\n<li><b>Topic Two: Sequence Analysis [4 sessions].</b>\n<br/>Hidden Markov Models (HMM) and HMM training.\n<br/>The Viterbi algorithm.\n<br/>Using an HMM in a biological application.\n<br/><p></p></li>\n<li><b>Topic Three: Social Networks [5 sessions].</b>\n<br/>Properties of networks: Degree, Diameter.\n<br/>Betweenness Centrality.\n<br/>Clustering using betweenness centrality.\n<br/></li>\n\nObjectives\nBy the end of the course students should be able to:\n\n\n<li>understand and program two simple\nsupervised machine learning algorithms;\n</li>\n<li>use these algorithms in statistically valid experiments,\nincluding the design of baselines, evaluation\nmetrics, statistical testing of results, and provision against\novertraining;\n</li>\n<li>visualise the connectivity and centrality in large\nnetworks;\n</li>\n<li>use clustering (i.e., a type of unsupervised machine learning) for\ndetection of cliques in unstructured networks.\n</li>\n\nRecommended reading\nJurafsky, D. &amp; Martin, J. (2008). <i>Speech and language\nprocessing</i>. Prentice Hall.\n<br/>Easley, D. and Kleinberg, J. (2010). <i>Networks, crowds, and markets:\nreasoning about a highly connected world</i>. Cambridge University\nPress.\n\n\n", "course_name": "Machine Learning and Real-world Data", "course_code": "MLRD", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/MLRD", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OpSystems": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction to operating systems.</b> Abstract view of an operating system. Elementary computer architecture. OS evolution: multi-programming, time-sharing. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Protection.</b> Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels. Virtual machines and containers. Subjects and objects. Authentication. Access matrix: ACLs and capabilities. Combined scheme. Covert channels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Processes.</b> Job/process concepts. Lifecycle. Process management. Inter-process communication. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Scheduling.</b> Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Memory management.</b> Processes in memory. Logical addresses. Partitions: static <em>versus</em> dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>I/O subsystem.</b> General structure. Polled mode <em>versus</em> interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking <em>versus</em> non-blocking I/O. Other issues: caching, scheduling, spooling, performance. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>File management.</b> File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Unix case study.</b> History. General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection, pipes, signals. Character and block I/O. Process scheduling. [2\u00a0lectures]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should be able to\n\n\n<li>describe the general structure and purpose of an operating system;\n</li>\n<li>explain the concepts of process, address space, and file;\n</li>\n<li>compare and contrast various CPU scheduling algorithms;\n</li>\n<li>understand various mechanisms involved in memory management, and be able\n  to describe the advantages and disadvantages of each;\n</li>\n<li>compare and contrast polled, interrupt-driven and DMA-based access to I/O\n  devices.\n</li>\n\nRecommended reading\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>. Addison-Wesley (3rd ed.).\n<br/>Silberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <em>Operating systems concepts</em>. Wiley (8th ed.).\n<br/>Anderson, T. &amp; Dahlin, M. (2014). <em>Operating Systems: Principles &amp; Practice</em>. Recursive Books (2nd ed.).\n<br/>Leffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>McKusick, M.K., Neville-Neil, G.N. &amp; Watson, R.N.M. (2014) <em>The Design and Implementation of the FreeBSD Operating System</em>. Pearson Education. (2nd ed.).\n\n\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/OpSystems", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "IntDesign": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-InteractionDesign.html", "description": "\n\n\nAims\nLectures\n<li><b>Course overview and requirements analysis.</b> Introduction to the\ncourse and the practicals. Identifying potential users and understanding\ntheir tasks. Identifying and establishing non-functional and\nfunctional requirements.\n\n<p></p></li>\n<li><b>Data gathering.</b> Data collection and quantitative/qualitative\nanalysis techniques.\n\n<p></p></li>\n<li><b>Design and prototyping.</b> Participatory design process. Conceptual\nversus physical design. Concept development. Prototyping and different kinds\nof prototypes. Personas and storyboards.\n\n<p></p></li>\n<li><b>Case studies from the industry.</b> Guest lecture (the schedule of this\nlecture is subject to change).\n\n<p></p></li>\n<li><b>Cognitive aspects.</b> Attention, perception/recognition, memory,\ncontext and grouping, and their implications for interaction design.\nCognitive frameworks.\n\n<p></p></li>\n<li><b>Evaluation.</b> Introduction, evaluation techniques, and an evaluation\ncase study. \n\n<p></p></li>\n<li><b>Student (group) presentations</b>\n</li>\n\nObjectives\nBy the end of the course students should \n\n\n<li>have a thorough understanding of the iterative design process and be\nable to apply it to interaction design;\n\n<p></p></li>\n<li>be able to design new user interfaces that are informed by principles of\nhuman visual perception and cognition;\n\n<p></p></li>\n<li>be able to construct user interfaces using Java with a strong emphasis\non users, usability and appearance;\n\n<p></p></li>\n<li>be able to evaluate existing or new user interfaces using multiple\ntechniques;\n\n<p></p></li>\n<li>be able to compare and contrast different design techniques and to\ncritique their applicability to new domains.\n\n<p></p></li>\n\nRecommended reading\n* Preece, J., Rogers, Y. &amp; Sharp, H. (2015). <em>Interaction design</em>.\nWiley (4th ed.).\n\n\n", "course_name": "Interaction Design", "course_code": "IntDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/IntDesign", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "IntroProb": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoProbability.html", "description": "\n\n\nAims\nLectures\nPart 1 - Introduction to Probability\n\n\n<li><b>Introduction.</b>\nCounting/Combinatorics (revision), Probability Space, Axioms, Union Bound.\n\n<p></p></li>\n<li><b>Conditional probability.</b> Conditional Probabilities and Independence,\nBayes\u2019Theorem, Partition Theorem\n</li>\n\nPart 2 - Discrete Random Variables\n\n\n<li><b>Random variables.</b>\nDefinition of a Random Variable, Probability Mass Function, Cumulative\nDistribution, Expectation.\n\n<p></p></li>\n<li><b>Probability distributions.</b>\n  Definition and Properties of Expectation, Variance, different ways of\n  computing them, Examples of important Distributions (Bernoulli, Binomial,\n  Geometric, Poisson), Primer on Continuous Distributions including Normal and\n  Exponential Distributions.\n\n<p></p></li>\n<li><b>Multivariate distributions.</b>\n  Multiple Random Variables, Joint and Marginal Distributions, Independence of\n  Random Variables, Covariance.\n</li>\n\nPart 3 - Moments and Limit Theorems\n\n\n<li><b>Introduction.</b> Law of Average, Useful inequalities\n(Markov and Chebyshef), Weak Law of Large Numbers (including Proof\nusing Chebyshef\u2019s inequality), Examples.\n\n<p></p></li>\n<li><b>Moments and Central Limit Theorem.</b>\n  Introduction to Moments of Random Variables, Central Limit Theorem (Proof\n  using Moment Generating functions), Example.\n</li>\n\nPart 4 - Applications/Statistics\n\n\n<li><b>Statistics.</b>\n  Classical Parameter Estimation (Maximum-Likelihood-Estimation), bias,\n  sample mean, sample variance), Examples (Collision-Sampling, Estimating\n  Population Size).\n\n<p></p></li>\n<li><b>Algorithms.</b>\nOnline Algorithms (Secretary Problem, Odd\u2019s Algorithm).\n</li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>understand the basic principles of probability spaces and random variables\n\n<p></p></li>\n<li>be able to formulate problems using concepts from probability theory and\n  compute or estimate probabilities\n\n<p></p></li>\n<li>be familiar with more advanced concepts such as moments, limit theorems\n  and applications such as parameter estimation\n\n<p></p></li>\n\nRecommended reading\n* Ross, S.M. (2014). <em>A First course in probability</em>. Pearson (9th ed.).\n<br/>Bertsekas, D.P. &amp; Tsitsiklis, J.N. (2008). <em>Introduction to probability</em>.\nAthena Scientific.\n<br/>Grimmett, G. &amp; Welsh, D. (2014). <em>Probability: an Introduction</em>. Oxford\nUniversity Press (2nd ed.).\n<br/>Dekking, F.M., et. al. (2005) <em>A modern introduction to probability and\nstatistics</em>. Springer.\n\n\n", "course_name": "Introduction to Probability", "course_code": "IntroProb", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/IntroProb", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWSecEng": {"supervisions": 3, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandSecurityEngineering.html", "description": "\n\n\nAims\nLectures\n\n<li><b>What is a security policy or a safety case?</b> Definitions and\nexamples; one-way flows for both confidentiality and safety properties;\nseparation of duties. Top-down and bottom-up analysis methods. What\narchitecture can do, versus benefits of decoupling policy from mechanism.\n\n<p></p></li>\n<li><b>Examples of safety and security policies.</b> Safety and security \nusability; the pyramid of harms. Predicting and mitigating user \nerrors. The prevention of fraud and error in accounting systems; the \nsafety usability of medical devices.\n\n<p></p></li>\n<li><b>Attitudes to risk:</b> expected utility, prospect theory, framing, \nstatus quo bias. Authority, conformity and gender; mental models, \naffordances and defaults. The characteristics of human memory; \nforgetting passwords versus guessing them.\n\n<p></p></li>\n<li><b>Security protocols;</b> how to enforce policy using structured\nhuman interaction, cryptography or both. Middleperson attacks. The role of\nverification and its limitations.\n\n<p></p></li>\n<li><b>Attacks on TLS,</b> from rogue CAs through side channels to Heartbleed.\nOther types of software bugs: syntactic, timing, concurrency, code \ninjection, buffer overflows. Defensive programming: secure coding,\ncontracts. Fuzzing.\n\n<p></p></li>\n<li><b>The software crisis.</b> Examples of large-scale project failure,\nsuch as the London Ambulance Service system and the NHS National\nProgramme for IT. Intrinsic difficulties with complex software.\n\n<p></p></li>\n<li><b>Software engineering as the management of complexity.</b>\nThe software life cycle; requirements analysis methods; modular \ndesign; the role of prototyping; the waterfall, spiral and agile models.\n\n<p></p></li>\n<li><b>The economics of software as a Service (SaaS);</b> the impact SaaS has \non software engineering. Continuous integration, release engineering, \nbehavioural analytics and experiment frameworks, rearchitecting \nsystems while in operation.\n\n<p></p></li>\n<li><b>Critical systems:</b> safety as an emergent system property.\nExamples of catastrophic failure: from Therac-25 to the Boeing 737Max.\nThe problems of managing redundancy. The overall process of safety engineering.\n\n<p></p></li>\n<li><b>Managing the development of critical systems:</b> tools and methods, \nindividual versus group productivity, economics of testing and agile \ndevelopment, measuring outcomes versus process, the technical and \nhuman aspects of management, post-market surveillance and coordinated \ndisclosure. The sustainability of products with software components.\n</li>\n\nObjectives\nAt the end of the course students should know how writing programs\nwith tough assurance targets, in large teams, or both, differs from\nthe programming exercises they have engaged in so far. They should\nunderstand the different models of software development\ndescribed in the course as well as the value of various development and\nmanagement tools. They should understand the development life cycle\nand its basic economics. They should understand the various types of\nbugs, vulnerabilities and hazards, how to find them, and how to avoid\nintroducing them. Finally, they should be prepared for the\norganizational aspects of their Part\u00a0IB group project.\n\nRecommended reading\nAnderson, R. (2020). <em>Security engineering</em> (Part 1 and Chapters 27-28). Wiley. Available at: <a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html5\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n<br/>\n", "course_name": "Software and Security Engineering", "course_code": "SWSecEng", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/SWSecEng", "lecturers": [], "year": "1920", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}