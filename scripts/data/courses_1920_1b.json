{"CompDesign": {"supervisions": 5, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerDesign.html", "description": "\n\n\nAims\nLectures\nPart 1 - Gates to processors [lecturer: Professor Simon Moore]\n\n\n<li><b>Technology trends and design challenges.</b> \n  Current technology, technology trends, ECAD trends, challenges. [1 lecture]\n\n<p></p></li>\n<li><b>Digital system design.</b> \n  Practicalities of mapping SystemVerilog descriptions of hardware\n  (including a processor) onto an FPGA board. Tips and pitfalls when\n  generating larger modular designs. [1 lecture]\n\n<p></p></li>\n<li><b>Eight great ideas in computer architecture.</b> \n   [1 lecture]\n\n<p></p></li>\n<li><b>Reduced instruction set computers and RISC-V.</b> \n   Introduction to the RISC-V processor design. [1 lecture]\n\n<p></p></li>\n<li><b>Executable and synthesisable models.</b> [1 lecture]\n\n<p></p></li>\n<li><b>Pipelining.</b> [2 lectures]\n\n<p></p></li>\n<li><b>Memory hierarchy and caching.</b> \n  Caching, etc. [1 lecture]\n\n<p></p></li>\n<li><b>Support for operating systems.</b> \n  Memory protection, exceptions, interrupts, etc. [1 lecture]\n\n<p></p></li>\n<li><b>Other instruction set architectures.</b>\n  CISC, stack, accumulator. [1 lecture]\n</li>\n\nPart 2 - Lecturer Dr Timothy Jones\n\n\n<li><b>Overview of Systems-on-Chip (SoCs) and DRAM.</b> [1 lecture]\n  High-level SoCs, DRAM storage and accessing.\n\n<p></p></li>\n<li><b>Multicore Processors.</b> [2 lectures]\n  Communication, cache coherence, barriers and synchronisation primitives.\n\n<p></p></li>\n<li><b>Graphics processing units (GPUs)</b> [2 lectures]\n  Basic GPU architecture and programming.\n\n<p></p></li>\n<li><b>Future Directions</b> [1 lecture]\n  Where is computer architecture heading?\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to read assembler given a guide to the instruction set\nand be able to write short pieces of assembler if given an\ninstruction set or asked to invent an instruction set;\n\n<p></p></li>\n<li>understand the differences between RISC and CISC assembler;\n\n<p></p></li>\n<li>understand what facilities a processor provides to support\noperating systems, from memory management to software interrupts;\n\n<p></p></li>\n<li>understand memory hierarchy including different cache\nstructures and coherency needed for multicore systems;\n\n<p></p></li>\n<li>understand how to implement a processor in SystemVerilog;\n\n<p></p></li>\n<li>appreciate the use of pipelining in processor design;\n\n<p></p></li>\n<li>have an appreciation of control structures used in processor design;\n\n<p></p></li>\n<li>have an appreciation of system-on-chips and their components;\n\n<p></p></li>\n<li>understand how DRAM stores data;\n\n<p></p></li>\n<li>understand how multicore processors communicate;\n\n<p></p></li>\n<li>understand how GPUs work and have an appreciation of how to program them.\n\n<p></p></li>\n\nRecommended reading\n* Patterson, D.A. &amp; Hennessy, J.L. (2017). <em>Computer organization and design: The hardware/software interface RISC-V edition</em>. Morgan Kaufmann.  ISBN\u00a0978-0-12-812275-4.\n\nRecommended further reading:\n\nHarris, D.M. &amp; Harris, S.L. (2012). <em>Digital design and computer architecture</em>. Morgan Kaufmann.  ISBN\u00a0978-0-12-394424-5.\n<br/>Hennessy, J. &amp; Patterson, D. (2006). <em>Computer architecture: a quantitative approach</em>. Elsevier (4th ed.). ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also still generally relevant.)\n<br/>Pointers to sources of more specialist information are included in the\nlecture notes and on the associated course web page.\n\n\n", "course_name": "Computer Design", "course_code": "CompDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/CompDesign", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ConcDisSys": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html", "description": "\n\n\nAims\nLectures: Concurrency\n\n<li><b>Introduction to concurrency, threads, and mutual exclusion</b>\nIntroduction to concurrent systems; threads; interleaving; preemption;\nparallelism; execution orderings; processes and threads; kernel vs. user\nthreads; M:N threads; atomicity; mutual exclusion; and mutual exclusion locks\n(mutexes).\n\n<p></p></li>\n<li><b>Automata Composition</b>\nSynchronous and asynchronous parallelism; sequential consistency; rendezvous. \nSafety, liveness and deadlock; the Dining Philosophers;\nHardware foundations for atomicity: test-and-set, load-linked/store-conditional\nand fence instructions.\n\n<p></p></li>\n<li><b>Common design patterns: semaphores, producer-consumer, and MRSW</b>\nLocks and invariants; semaphores;\ncondition synchronisation; N-resource allocation; two-party and generalised\nproducer-consumer; Multi-Reader, Single-Write (MRSW) locks.\n\n<p></p></li>\n<li><b>CCR, monitors, and concurrency in practice</b>\nConditional critical regions (CCR); monitors; condition variables; signal-wait\nvs. signal-continue semantics; concurrency in practice (kernels, pthreads,\nJava).\n\n<p></p></li>\n<li><b>Deadlock and liveness guarantees</b>\nOffline vs. online; model checking; resource allocation graphs; lock order\nchecking; deadlock prevention, avoidance, detection, and recovery; livelock;\npriority inversion; priority inheritance.\n\n<p></p></li>\n<li><b>Concurrency without shared data; transactions</b>\nActive objects; message passing; tuple spaces; CSP; and actor models.\nComposite operations; transactions; ACID; isolation; and serialisability.\n\n<p></p></li>\n<li><b>Further transactions</b>\nHistory graphs; good and bad schedules; isolation vs. strict isolation;\n2-phase locking; rollback; timestamp ordering (TSO); and optimistic\nconcurrency control (OCC).\n\n<p></p></li>\n<li><b>Crash recovery, lock-free programming, and transactional memory</b>\nWrite-ahead logging, checkpoints, and recovery.\nLock-free programming. Hardware and software transactional memories.\n\n<p></p></li>\n\nLectures: Distributed Systems\n\n<li><b>Introduction to distributed systems; RPC</b>\n  Avantages and challenges of distributed systems; \u201cmiddleware\u201d;\n  transparency goals; client-server systems; failures and retry semantics\n  (all-or-nothing; at-most-once; at-least-once).\n  Remote procedure call (RPC); marshalling; interface definition languages\n  (IDLs); SunRPC; external data representation (XDR).\n\n<p></p></li>\n<li><b>Network File System and Object-Oriented Middleware</b>\n  Network File System (NFS); NFSv2; NFSv3; scoping; the implications of a\n  stateless design; performance optimisations.\n  Object-oriented middleware (OOM); Corba ORBs, IDL; DCOM.\n\n<p></p></li>\n<li><b>Practical RPC systems; clocks</b>\n  Remote method invocation (RMI); remote classes vs. serialisable classes;\n  distributed garbage collection; XML-RPC; SOAP and web services; REST.\n  Physical clocks; UTC; computer clocks; clock synchronisation.\n\n<p></p></li>\n<li><b>Clock synchronisation; logical clocks</b>\n  Clock drift and compensation; Cristian\u2019s Algorithm; Berkeley Algorithm;\n  Network Time Protocol (NTP).\n  Logical time, \u201chappens-before\u201d; Lamport clocks; vector clocks.\n\n<p></p></li>\n<li><b>Consistent cuts, process groups, and mutual exclusion</b>\n  Consistent global state; consistent cuts.\n  Process groups; FIFO ordering; receiving vs. delivering; causal ordering;\n  total ordering.\n  Distributed mutual exclusion; central lock servers; token passing; totally\n  ordered multicast.\n\n<p></p></li>\n<li><b>Elections, consensus, and distributed transactions</b>\n  Leader elections; ring-based algorithm; the Bully algorithm.\n  Consensus.\n  Distributed transactions; atomic commit protocols; 2-phase commit.\n  Replication and consistency.\n\n<p></p></li>\n<li><b>Replication in distributed systems, CAP, case studies</b>\n  Replication and consistency (cont); strong consistency; quorum systems;\n  weak consistency; FIFO consistency; eventual consistency; Amazone\u2019s Dynamo;\n  session guarantees; Consistency, Availability and Partitions (CAP);\n  Google datacentre technologies (MapReduce).\n\n<p></p></li>\n<li><b>Further case studies, PubSub, security, NASD/AFS/Coda</b>\n  Google datacentre technologies (BigTable, Spanner).\n  Access control and the access-control matrix; ACLs vs capabilities;\n  cryptographic capabilities; role-based\n  access control (RBAC); single-system sign-on.\n  NASD, AFS, and Coda.\n\n<p></p></li>\n\nObjectives\nAt the end of Concurrent Systems portion of the course, students should:\n\n\n<li>understand the need for concurrency control in operating systems\n  and applications, both mutual exclusion and condition\n  synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the\n  implications of different approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming\n  languages for concurrency control and be able to judge the scope,\n  performance implications and possible applications of the various\n  approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock;\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of transactions,\n  how they can be implemented, and how their performance can be optimised\n  based on optimistic assumptions;\n\n<p></p></li>\n<li>understand how the persistence properties of transactions are addressed\n  through logging; and\n\n<p></p></li>\n<li>have a high-level understanding of the evolution of software use of\n  concurrency in the operating-system kernel case study.\n\n<p></p></li>\n\nAt the end of the Distributed Systems portion of the course, students\nshould:\n\n\n<li>understand the difference between simple concurrent systems and\n  distributed systems;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and their\n  implications for system design;\n\n<p></p></li>\n<li>understand notions of time synchronisation, including logical clocks,\n  vector clocks, and physical time;\n\n<p></p></li>\n<li>be familiar with various approaches to data and service replication, as\n  well as the concept of data consistency;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of fundamental\n  services and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>appreciate the implications of individual node and network\n  communications failures on distributed computation;\n\n<p></p></li>\n<li>be aware of a variety of tools used by distributed-system creators,\n  such as RPC and object-oriented middleware (OOM);\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms;\n\n<p></p></li>\n<li>be familiar with a number of case studies in distributed-system design\n  including: the Network File System (NFS), the Network Time Protocol (NTP),\n  Java Remote Method Invocation (RMI), CORBA, the AFS and Coda filesystems,\n  Network-Attached Secure Disks (NASD), and Google\u2019s MapReduce, BigTable, and\n  Spanner systems.\n\n<p></p></li>\n\nRecommended reading\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent systems</em>. Addison-Wesley.\n<br/>Kleppmann, M. (2017). <em>Designing data-intensive applications</em>. O\u2019Reilly.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.). \n\n\n", "course_name": "Concurrent and Distributed Systems", "course_code": "ConcDisSys", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ConcDisSys", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ECAD+Arch": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\nAims\nPractical Classes\n\n<li><b>Web tutor</b>\nThe first class uses a web based tutor to rapidly teach the SystemVerilog\nlanguage.\n\n<p></p></li>\n<li><b>FPGA design flow</b>\nTest driven hardware development for FPGA including an embedded processor\nand peripherals [3\u00a0classes]\n\n<p></p></li>\n<li><b>Embedded system implementation</b>\nEmbedded system implementation on FPGA [3-4\u00a0classes]\n\n<p></p></li>\n\nObjectives\n\n<li>Gain experience in electronic computer aided design (ECAD) through\nlearning a design-flow for field programmable gate arrays (FPGAs).\n\n<p></p></li>\n<li>Learn how to interface to peripherals like a touch screen.\n\n<p></p></li>\n<li>Learn how to debug hardware and software systems in simulation.\n\n<p></p></li>\n<li>Understand how to construct and program a heterogeneous embedded\nsystem.\n\n<p></p></li>\n\nRecommended reading\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture: from gates to processors</em>. Morgan Kaufmann.\n\nPointers to sources of more specialist information are included on the\nassociated course web page.\n\n\n", "course_name": "ECAD and Architecture Practical Classes", "course_code": "ECAD+Arch", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ECAD+Arch", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "EconLaw": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsLawandEthics.html", "description": "\n\n\nAims\nLectures\n<li><b>Game theory.</b> The choice between cooperation and conflict. \nPrisoners\u2019 Dilemma; Nash equilibrium; hawk-dove; iterated games; \nevolution of strategies; application to biology and computer science.\n\n<p></p></li>\n<li><b>Classical economics.</b> Definitions: preference, utility, \nchoice and budget. Pareto efficiency; the discriminating monopolist;\nsupply and demand; elasticity; utility; the marginalist revolution; \ncompetitive equilibrium and the welfare theorems. Trade; monopoly \nrents; public goods; oligopoly.\n\n<p></p></li>\n<li><b>Market failure.</b> Asymmetric information: the market for \nlemons; adverse selection; moral hazard; signalling; and brands.\nTransaction costs and the theory of the firm. Real and virtual networks, \nsupply-side <em>versus</em> demand-side scale economies, Metcalfe\u2019s law, \nthe dominant firm model, price discrimination. Behavioural economics:\nbounded rationality, heuristics and biases.\n\n<p></p></li>\n<li><b>Auctions.</b> English auctions; Dutch auctions; all-pay\nauctions; Vickrey auctions. The winner\u2019s curse. The revenue\nequivalence theorem.  Mechanism design and the combinatorial\nauction. Problems with real auctions. Applicability of auction\nmechanisms in computer science.\n\n<p></p></li>\n<li><b>Principles of law.</b> Contract and tort; copyright and patent; \nbinding actions; liabilities and remedies; competition law; choice of\nlaw and jurisdiction.\n\n<p></p></li>\n<li><b>Law and the Internet.</b> EU directives including distance \nselling, electronic commerce, data protection, electronic signatures \nand copyright; their UK implementation. UK laws that specifically\naffect the Internet.\n\n<p></p></li>\n<li><b>Ethics.</b> Philosophies of ethics: authority, intuitionist, \negoist and deontological theories. Utilitarian and Rawlsian models. \nInsights from evolutionary psychology and neorology. The Internet and \nsocial policy; current debates on privacy, surveillance, censorship\nand export control.\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should have a basic appreciation of\neconomic and legal terminology and arguments. They should understand\nsome of the applications of economic models to systems engineering and\ntheir interest to theoretical computer science. They should also\nunderstand the main constraints that markets, legislation and ethics\nplace on firms dealing in information goods and services.\n\nRecommended reading\n* Shapiro, C. &amp; Varian, H. (1998). <em>Information rules</em>. Harvard Business School Press.\n<br/>Varian, H. (1999). <em>Intermediate microeconomics - a modern approach</em>. Norton.\n\nFurther reading:\n\nSmith, A. (1776). <i>An inquiry into the nature and causes of the wealth of \nnations</i>, available at\u00a0\u00a0\u00a0\u00a0<a href=\"http://www.econlib.org/library/Smith/smWN.html\" name=\"tex2html19\"><tt>http://www.econlib.org/library/Smith/smWN.html</tt></a>\n<br/>Thaler, R.H. (2016). <i>Misbehaving</i>. Penguin.\n<br/>Galbraith, J.K. (1991). <i>A history of economics</i>. Penguin.\n<br/>Poundstone, W. (1992). <i>Prisoner\u2019s dilemma</i>. Anchor Books.\n<br/>Pinker, S (2011). <i>The Better Angels of our Nature</i>. Penguin.\n<br/>Anderson, R. (2008). <i>Security engineering</i> (Chapter 7). Wiley.\n<br/>Nuffield Council on Bioethics (2015) <i>The collection, linking and use of data in biomedical research and health care</i>.\n<br/>\n", "course_name": "Economics, Law and Ethics", "course_code": "EconLaw", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/EconLaw", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "DataSci": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofDataScience.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Likelihood.</b>\nRandom variables. Random samples.\nMaximum likelihood estimation, likelihood profile.\n\n<p></p></li>\n<li><b>Random variables.</b>\nRules for expectation and variance.\nGenerating random variables. Empirical distribution. \nMonte Carlo estimation; law of large numbers. Central limit theorem.\n\n<p></p></li>\n<li><b>Inference.</b>\nEstimation, confidence intervals, hypothesis testing, prediction.\nBootstrap. Bayesianism. Logistic regression, natural parameters.\n\n<p></p></li>\n<li><b>Feature spaces.</b>\nVector spaces, bases, inner products, projection. \nModel fitting as projection. Linear modeling. \nChoice of features.\n<p></p></li>\n<li><b>Random processes.</b>\nMarkov chains.\nStationarity and convergence.\nDrift models. \nExamples, including estimation and memory.\n\n<p></p></li>\n<li><b>Probabilistic modelling.</b>\nIndependence; joint distributions.\nDescriptive, discriminative, and causal models. Latent variable models. Random fields.\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to formulate basic probabilistic models, including discrete\ntime Markov chains and linear models\n\n<p></p></li>\n<li>be familiar with common random variables and their uses, and with the\nuse of empirical distributions rather than formulae\n\n<p></p></li>\n<li>be able to use expectation and conditional expectation, \nlimit theorems, equilibrium distributions\n\n<p></p></li>\n<li>understand different types of inference about noisy data, including\nmodel fitting, hypothesis testing, and making predictions\n\n<p></p></li>\n<li>understand the fundamental properties of inner product spaces and\northonormal systems, and their application to model representation\n</li>\n\nRecommended reading\n* F.M. Dekking, C. Kraaikamp, H.P. Lopuha\u00e4, L.E. Meester (2005). \n<em>A modern introduction to probability and statistics: understanding why and how.</em>\nSpringer.\n\nS.M. Ross (2002).\n<em>Probability models for computer science.</em> \nHarcourt / Academic Press.\n\nM. Mitzenmacher &amp; E. Upfal (2005). \n<em>Probability and computing: randomized algorithms and probabilistic analysis.</em>\nCambridge University Press.\n\n\n\n", "course_name": "Foundations of Data Science", "course_code": "DataSci", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/DataSci", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FGraphics": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherGraphics.html", "description": "\n\n\nAims\nLectures\nThe order and content of lectures is provisional and subject to change.\n\n\n<li><b>Ray Marching.</b> Signed distance fields and GPU-based realtime\nrendering. [1 lecture]\n</li>\n<li><b>Implicit surfaces.</b> Organic and soft surface modelling. [1 lecture]\n</li>\n<li><b>Computational Geometry.</b> Mathematics of surfaces. [1 lecture]\n</li>\n<li><b>Bezier curves and NURBS.</b> These points of data make a beautiful line.\n[2 lectures]\n</li>\n<li><b>Subdivision Surfaces.</b> Smooth modeling of continuous surfaces.\n[1 lecture]\n</li>\n<li><b>Global Illumination.</b> Realistic global lighting techniques.\n[1 lecture]\n</li>\n<li><b>Virtual Reality.</b> Technology and best practices for an emerging\nmedium. [1 lecture]\n</li>\n\nObjectives\nOn completing the course, students should be able to\n\n\n<li>use graphics hardware to render interactive images, both polygonal and implicit;\n</li>\n<li>understand the core technologies of ray tracing, rendering, and implicit surfaces;\n</li>\n<li>learn techniques of computational geometry and their applications to visualization;\n</li>\n<li>describe the underlying theory of splines and subdivision and define the Catmull-Clark and Doo-Sabin subdivision methods;\n</li>\n<li>understand several global illumination technologies such as radiosity and ambient occlusion;\n</li>\n\nRecommended reading\nStudents should expect to refer to one or more of these books, but should not find it necessary to purchase any of them. \n\n* Shirley, P. &amp; Marschner, S. (2009). <span class=\"textit\">Fundamentals of Computer Graphics</span>. CRC Press (3rd ed.). \n\nWatt, A. (2000). <span class=\"textit\">3D Computer Graphics</span>. Addison-Wesley (3rd ed). \n\nHughes, van Dam, McGuire, Skalar, Foley, Feiner &amp; Akeley (2013).  <span class=\"textit\">Computer Graphics: Principles &amp; Practice</span>.  Addison-Wesley (3rd edition)\n\nAkenine-M\u00f6ller, et. al. (2018). <span class=\"textit\">Real-time rendering</span>. CRC Press (4th ed.).\n\n\n", "course_name": "Further Graphics", "course_code": "FGraphics", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/FGraphics", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FJava": {"supervisions": 2, "lectures": 5, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherJava.html", "description": "\n\n\nAims\nPractical classes\n<li><b>Communication and client applications.</b> \nThis class will introduce an integrated development environment. \nStudents will write a simple client to send and receive data to a\nserver via TCP.\n\n<p></p></li>\n<li><b>Serialisation, reflection and class loaders.</b>\nThis class will introduce object serialisation. Students will\nuse a class loader and reflection to inspect an object which \nis only available at run-time.\n\n<p></p></li>\n<li><b>Concurrency and synchronisation.</b>\nThis class introduces the concurrency and synchronisation primitives\nfound in Java. Students will implement a thread-safe \nfirst-in-first-out queue and learn about Java generics.\n\n<p></p></li>\n<li><b>Server applications</b>.\nStudents implement a server in Java which is capable of communicating \nconcurrently with mulitple clients.\n\n<p></p></li>\n<li><b>Vector clocks</b>.\nThis week students will use the concept of vector clocks to make their\nclient and server robust to message delays and reordering.\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>understand different mechanisms for communication between \ndistributed applications and be able to evaluate their trade-offs;\n\n<p></p></li>\n<li>be able to use Java generics and annotations to improve software\nusability, readability and safety;\n\n<p></p></li>\n<li>understand and be able to exploit the Java class-loading mechansim;\n\n<p></p></li>\n<li>understand and be able to use concurrency control correctly;\n\n<p></p></li>\n<li>be able to implement a vector clock algorithm and the happens-before\nrelation.\n\n<p></p></li>\n\nRecommended reading\n* Goetz, B. (2006). <em>Java concurrency in practice</em>. Addison-Wesley.\n<br/>Gosling, J., Joy, B., Steele, G., Bracha, G. &amp; Buckley, A. (2014). <em>The Java language specification, Java SE 8 Edition</em>. Addison-Wesley.\n<br/><a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/\" name=\"tex2html10\"><tt>http://docs.oracle.com/javase/specs/jls/se8/html/</tt></a>\n<br/>\n", "course_name": "Further Java", "course_code": "FJava", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/FJava", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "GroupProj": {"supervisions": 0, "lectures": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Group Project", "course_code": "GroupProj", "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "ProgC": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction to the C language.</b>  Background and goals of C.\n  Types and variables.  Expressions and statements.  Functions.\n  Multiple compilation units. Tooling for C programming. [2 lectures]\n\n<p></p></li>\n<li><b>Further C concepts.</b>  Preprocessor. Pointers and pointer\n  arithmetic. Data structures. Dynamic memory management.  Examples.\n  [2 lectures]\n\n<p></p></li>\n<li><b>Memory Management</b> Unique ownership. Object graphs and graph\n  traversals. Aliasing and deallocation. Mark and sweep algorithms.\n  Reference counting. Arenas. Stack allocation. Handles and\n  compaction. [3 lectures]\n\n<p></p></li>\n<li><b>Memory Hierarchy and Cache Optimization</b> Cache\n  hierarchy. Data structure layouts.  Intrusive\n  lists. Array-of-structs vs struct-of-array representations. [1 lecture]\n\n<p></p></li>\n<li><b>Linkers, loaders and debugging.</b>  Executable sections. Debug\n  symbols.  Inspecting program state. [1 lecture]\n\n<p></p></li>\n<li><b>C semantics.</b>  Undefined vs implementation-defined\n  behaviour.  Common optimisation problems. Buffer and integer\n  overflows. Examples.  [1 lecture]\n\n<p></p></li>\n<li><b>Introduction to C++.</b> Goals of C++. Differences between C\n  and C++. References versus pointers. Overloading functions. [1 lecture]\n\n<p></p></li>\n<li><b>Objects in C++</b> Classes and\n  structs. Exceptions. Destructors. Operator overloading. Virtual\n  functions. Casting. Multiple inheritance. Virtual base\n  classes. Templates and meta-programming. [1 lecture] \n</li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to read and write C programs;\n\n<p></p></li>\n<li>understand the interaction between C programs and the\n  host operating system;\n\n<p></p></li>\n<li>be familiar with the structure of C program execution in\n  machine memory;\n\n<p></p></li>\n<li>understand the potential dangers of writing programs in C;\n\n<p></p></li>\n<li>understand the main differences between C and C++. \n</li>\n\nRecommended reading\n* Kernighan, B.W. &amp; Ritchie, D.M. (1988). <em>The C programming language</em>. Prentice\u00a0Hall (2nd ed.).\n\n\n", "course_name": "Programming in C and C++", "course_code": "ProgC", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ProgC", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Semantics": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SemanticsofProgrammingLanguages.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction.</b>  Transition systems.  \n  The idea of structural operational semantics. \n  Transition semantics of a simple imperative language. \n  Language design options. \n[2 lectures]\n\n<p></p></li>\n<li><b>Types.</b>  Introduction to formal type systems.\n  Typing for the simple imperative language.\n  Statements of desirable properties.\n[2 lectures]\n\n<p></p></li>\n<li><b>Induction.</b>  Review of mathematical induction. Abstract\n  syntax trees and structural induction. Rule-based inductive\n  definitions and proofs. Proofs of type safety\n  properties. \n[2 lectures]\n\n<p></p></li>\n<li><b>Functions.</b>  Call-by-name and call-by-value function\n application, semantics and typing. Local recursive\n definitions. \n[2 lectures]\n\n<p></p></li>\n<li><b>Data.</b> Semantics and typing for products, sums, records,\nreferences.\n[1 lecture]\n\n<p></p></li>\n<li><b>Subtyping.</b>  Record subtyping and simple object encoding.\n[1 lecture]\n\n<p></p></li>\n<li><b>Semantic equivalence.</b>  Semantic equivalence of phrases in a\nsimple imperative language, including the congruence property.\nExamples of equivalence and non-equivalence.\n[1 lecture]\n\n<p></p></li>\n<li><b>Concurrency.</b>  Shared variable interleaving. Semantics for\nsimple mutexes; a serializability property.\n[1 lecture]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be familiar with rule-based presentations of the operational\n  semantics and type systems for some simple imperative, functional\n  and interactive program constructs;\n\n<p></p></li>\n<li>be able to prove properties of an operational semantics using\n  various forms of induction (mathematical, structural, and\n  rule-based);\n\n<p></p></li>\n<li>be familiar with some operationally-based notions of semantic\n  equivalence of program phrases and their basic properties.\n\n<p></p></li>\n\nRecommended reading\n* Pierce, B.C. (2002). <em>Types and programming languages</em>. MIT Press.\n<br/>Hennessy, M. (1990). <em>The semantics of programming languages</em>. Wiley. Out of print, but available on the web at <a href=\"http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf\" name=\"tex2html11\"><tt>http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf</tt></a>\n<br/>Winskel, G. (1993). <em>The formal semantics of programming languages</em>. MIT Press.\n\n\n", "course_name": "Semantics of Programming Languages", "course_code": "Semantics", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Semantics", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "UnixTools": {"supervisions": 1, "lectures": 8, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\nAims\nLectures\n\n<li><b>Unix concepts.</b> Brief review of Unix history and design\n  philosophy, documentation, terminals, inter-process communication\n  mechanisms and conventions, shell, command-line arguments,\n  environment variables, file descriptors.\n\n<p>\n</p></li>\n<li><b>Shell concepts.</b> Program invocation, redirection, pipes,\n  file-system navigation, argument expansion, quoting, job control,\n  signals, process groups, variables, locale, history and alias\n  functions, security considerations.\n\n<p>\n</p></li>\n<li><b>Scripting.</b> Plain-text formats, executables, <tt>#!</tt>,\n  shell control structures and functions. Startup scripts.\n\n<p>\n</p></li>\n<li><b>Text, file and networking tools.</b> sed, grep, chmod, find,\n  ssh, rsync, tar, zip, etc.\n\n<p>\n</p></li>\n<li><b>Version control.</b> diff, patch, RCS, Subversion, git.\n\n<p>\n</p></li>\n<li><b>Software development tools.</b> C compiler, linker, debugger,\n  make.\n\n<p>\n</p></li>\n<li><b>Perl.</b> Introduction to a powerful scripting and\n  text-manipulation language. [2\u00a0lectures]\n\n<p>\n</p></li>\n\nObjectives\n\nAt the end of the course students should\n\n\n\n<li>be confident in performing routine user tasks on a POSIX system,\n  understand command-line user-interface conventions and know how to\n  find more detailed documentation;\n\n<p>\n</p></li>\n<li>appreciate how simple tools can be combined to perform a large\n  variety of tasks;\n\n<p>\n</p></li>\n<li>be familiar with the most common tools, file formats and\n  configuration practices;\n\n<p>\n</p></li>\n<li>be able to understand, write, and maintain shell scripts and\n  makefiles;\n\n<p>\n</p></li>\n<li>appreciate how using a version-control system and fully\n  automated build processes help to maintain reproducibility and\n  audit trails during software development;\n\n<p>\n</p></li>\n<li>know enough about basic development tools to be able to install,\n  modify and debug C source code;\n\n<p>\n</p></li>\n<li>have understood the main concepts of, and gained initial\n  experience in, writing Perl scripts (excluding the facilities for\n  object-oriented programming).\n\n<p>\n</p></li>\n\nRecommended reading\n\nRobbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th ed.).\n<br/>\nSchwartz, R.L., Foy, B.D. &amp; Phoenix, T. (2011). <em>Learning Perl</em>. O\u2019Reilly (6th ed.).\n\n\n\n", "course_name": "Unix Tools", "course_code": "UnixTools", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/UnixTools", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompConstr": {"supervisions": 4, "lectures": 16, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html", "description": "\n\n\nAims\nLectures\n<li><b>Overview of compiler structure</b>\nThe spectrum of interpreters and compilers; compile-time and run-time.\nCompilation as a sequence of translations\nfrom <em>higher-level</em> to <em>lower-level</em> intermediate languages, where \neach translation preserves semantics. \nThe structure of a simple compiler: \nlexical analysis and syntax analysis, type checking, intermediate representations, optimisations, code generation. \nOverview of run-time data structures: stack and heap.  Virtual machines. \n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Lexical analysis and syntax analysis.</b>\nLexical analysis based on regular expressions and finite state automata. \nUsing LEX-tools. How does LEX work? \nParsing based on context-free grammars and push-down automata. \nGrammar ambiguity, left- and right-associativity and operator precedence.\nUsing YACC-like tools. How does YACC work? \nLL(k) and LR(k) parsing theory. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Compiler Correctness</b>\nRecursive functions can be transformed \ninto iterative functions using the \nContinuation-Passing Style (CPS) transformation. \nCPS applied to a (recursive) SLANG interpreter \nto derive, in a step-by-step manner, a \ncorrect stack-based compiler. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Data structures, procedures/functions</b>\nRepresenting tuples, arrays, references. \nProcedures and functions: \ncalling conventions, nested structure, non-local variables. \nFunctions as <em>first-class</em> values represented as <em>closures</em>. \nSimple optimisations: inline expansion, constant folding, \nelimination of tail recursion, peephole optimisation.\n[5\u00a0lectures]\n\n<p></p></li>\n<li><b>Advanced topics</b>\nRun-time memory management (garbage collection).  \nStatic and dynamic linking. \nObjects and inheritance; implementation of method dispatch.\nTry-catch exception mechanisms. \nCompiling a compiler via bootstrapping. \n[4\u00a0lectures]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should understand the overall\nstructure of a compiler, and will know significant details of a number\nof important techniques commonly used. They will be aware of the way\nin which language features raise challenges for compiler builders.\n\nRecommended reading\n* Aho, A.V., Sethi, R. &amp; Ullman, J.D. (2007). <em>Compilers: principles, techniques and tools</em>. Addison-Wesley (2nd ed.).\n<br/>Mogensen, T. \u00c6. (2011). <em>Introduction to compiler design</em>. Springer. <a href=\"http://www.diku.dk/~torbenm/Basics\" name=\"tex2html12\"><tt>http://www.diku.dk/\u00a0torbenm/Basics</tt></a>. \n\n\n\n", "course_name": "Compiler Construction", "course_code": "CompConstr", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/CompConstr", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompTheory": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction: algorithmically undecidable problems.</b>\n  Decision problems. The informal notion of algorithm, or effective\n  procedure. Examples of algorithmically undecidable problems. [1\n  lecture]\n\n<p></p></li>\n<li><b>Register machines.</b> Definition and examples; graphical\n  notation.  Register machine computable functions.  Doing arithmetic\n  with register machines. [1 lecture]\n\n<p></p></li>\n<li><b>Universal register machine.</b>  Natural number encoding of\n  pairs and lists.  Coding register machine programs as numbers.\n  Specification and implementation of a universal register\n  machine. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Undecidability of the halting problem.</b>  Statement and\n  proof. Example of an uncomputable partial function. Decidable sets\n  of numbers; examples of undecidable sets of numbers.  [1 lecture]\n\n<p></p></li>\n<li><b>Turing machines.</b> Informal description.  Definition and\n  examples.  Turing computable functions. Equivalence of register\n  machine computability and Turing computability. The Church-Turing\n  Thesis. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Primitive and partial recursive functions.</b> Definition and\n  examples.  Existence of a recursive, but not primitive recursive\n  function. A partial function is partial recursive if and only if it\n  is computable. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Lambda-Calculus.</b> Alpha and beta conversion.\n  Normalization. Encoding data. Writing recursive functions in the\n  lambda-calculus. The relationship between computable functions\n  and lambda-definable functions. [3\u00a0lectures]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be familiar with the register machine, Turing machine and\n  lambda-calculus models of computability;\n\n<p></p></li>\n<li>understand the notion of coding programs as data, and of a universal\n  machine;\n\n<p></p></li>\n<li>be able to use diagonalisation to prove the undecidability of\n  the Halting Problem;\n\n<p></p></li>\n<li>understand the mathematical notion of partial recursive function\n  and its relationship to computability.\n\n<p></p></li>\n\nRecommended reading\n* Hopcroft, J.E., Motwani, R. &amp; Ullman, J.D. (2001). <em>Introduction to automata theory, languages, and computation</em>. Addison-Wesley (2nd ed.). \n<br/>* Hindley, J.R. &amp; Seldin, J.P. (2008). <em>Lambda-calculus and combinators, an introduction</em>. Cambridge University Press (2nd ed.).\n<br/>Cutland, N.J. (1980). <em>Computability: an introduction to recursive function theory</em>. Cambridge University Press.\n<br/>Davis, M.D., Sigal, R. &amp; Weyuker, E.J. (1994). <em>Computability, complexity and languages</em>. Academic Press (2nd ed.).\n<br/>Sudkamp, T.A. (2005). <em>Languages and machines</em>. Addison-Wesley (3rd ed.).\n\n\n", "course_name": "Computation Theory", "course_code": "CompTheory", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/CompTheory", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompNet": {"supervisions": 5, "lectures": 20, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction.</b>\n  Overview of networking using the Internet as\n  an example. LANs and WANs. OSI reference model, Internet TCP/IP\n  Protocol Stack. Circuit-switching, packet-switching, Internet\n  structure, networking delays and packet loss. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Link layer and local area networks.</b>\nLink layer services, error detection and correction, Multiple Access\nProtocols, link layer addressing, Ethernet, hubs and switches,\nPoint-to-Point Protocol. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Wireless and mobile networks.</b>\nWireless links and network characteristics, Wi-Fi: IEEE 802.11 wireless\nLANs. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Network layer addressing.</b>\nNetwork layer services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\n [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer routing.</b>\nRouting and forwarding, routing algorithms, routing in the Internet,\nmulticast. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Transport layer.</b>\nService models, multiplexing/demultiplexing, connection-less transport\n(UDP), principles of reliable data transfer, connection-oriented\ntransport (TCP), TCP congestion control, TCP variants.\n[6\u00a0lectures]\n\n<p></p></li>\n<li><b>Application layer.</b>\nClient/server paradigm, WWW, HTTP, Domain Name System, P2P. [1.5\u00a0lectures]\n\n<p></p></li>\n<li><b>Multimedia networking.</b>\nNetworked multimedia applications, multimedia delivery requirements,\nmultimedia protocols (SIP), content distribution networks.  [0.5\u00a0lecture]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to analyse a communication system by separating out the\ndifferent functions provided by the network;\n\n<p></p></li>\n<li>understand that there are fundamental limits to any communications \nsystem;\n\n<p></p></li>\n<li>understand the general principles behind multiplexing, addressing,\nrouting, reliable transmission and other stateful protocols as well as\nspecific examples of each;\n\n<p></p></li>\n<li>understand what FEC is;\n\n<p></p></li>\n<li>be able to compare communications systems in how they solve\nsimilar problems;\n\n<p></p></li>\n<li>have an informed view of both the internal workings of the\n  Internet and of a number of common Internet applications and\n  protocols.\n\n<p></p></li>\n\nRecommended reading\n* Peterson, L.L. &amp; Davie, B.S. (2011). <em>Computer networks: a systems approach</em>. Morgan Kaufmann (5th ed.). ISBN 9780123850591\n<br/>Kurose, J.F. &amp; Ross, K.W. (2009). <em>Computer networking: a top-down approach</em>. Addison-Wesley (5th ed.).\n<br/>Comer, D. &amp; Stevens, D. (2005). <em>Internetworking with TCP-IP, vol. </em>1<em> and </em>2. Prentice\u00a0Hall (5th ed.).\n<br/>Stevens, W.R., Fenner, B. &amp; Rudoff, A.M. (2003). <em>UNIX network programming, Vol.I: The sockets networking API</em>. Prentice\u00a0Hall (3rd ed.).\n\n\n", "course_name": "Computer Networking", "course_code": "CompNet", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/CompNet", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "FHCI": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherHuman-ComputerInteraction.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Theory driven approaches to HCI. </b> What is a theory in HCI?\n  Why take a theory driven approach to HCI?\n\n<p></p></li>\n<li><b>Design of visual displays. </b> Segmentation and variables of\n  the display plane. Modes of correspondence.\n\n<p></p></li>\n<li><b>Goal-oriented interaction. </b> Using cognitive theories of\n  planning, learning and understanding to understand user behaviour,\n  and what they find hard.\n\n<p></p></li>\n<li><b>Designing smart systems. </b> Using statistical methods to\n  anticipate user needs and actions with Bayesian strategies.\n\n<p></p></li>\n<li><b>Designing efficient systems. </b> Measuring and optimising\n  human performance through quantitative experimental methods.\n\n<p></p></li>\n<li><b>Designing meaningful systems. </b> Qualitative research\n  methods to understand social context and requirements of user\n  experience. \n\n<p></p></li>\n<li><b>Evaluating interactive system designs. </b> Approaches to\n  evaluation in systems research and engineering, including Part II\n  Projects.\n\n<p></p></li>\n<li><b>Designing complex systems. </b> Worked case \n  studies of applying the theories to a hard HCI problem. Research \n  directions in HCI. \n\n<p></p></li>\n\nObjectives\nAt the end of the course students should be able to apply theories of\nhuman performance and cognition to system design, including selection\nof appropriate techniques to analyse, observe and improve the\nusability of a wide range of technologies.\n\nRecommended reading\n* Preece, J., Sharp, H. &amp; Rogers, Y. (2015). <i>Interaction\n  design: beyond human-computer interaction</i>. Wiley (Currently in 4th edition, but\nearlier editions will suffice).\n\nFurther reading:\n\nCarroll, J.M. (ed.) (2003). <i>HCI models, theories and frameworks: toward a multi-disciplinary science</i>. Morgan Kaufmann.\n\n\n", "course_name": "Further Human\u2013Computer Interaction", "course_code": "FHCI", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/FHCI", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "LogicProof": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction to logic.</b>\nSchematic statements.  Interpretations and validity.  Logical\nconsequence.  Inference.\n\n<p></p></li>\n<li><b>Propositional logic.</b>\nBasic syntax and semantics.  Equivalences.  Normal forms.\nTautology checking using CNF.\n\n<p></p></li>\n<li><b>The sequent calculus.</b>\nA simple (Hilbert-style) proof system.  Natural deduction systems.\nSequent calculus rules.  Sample proofs.\n\n<p></p></li>\n<li><b>First order logic.</b>\nBasic syntax.  Quantifiers.  Semantics (truth definition).\n\n<p></p></li>\n<li><b>Formal reasoning in FOL.</b>\nFree <em>versus</em> bound variables.  Substitution. Equivalences for\nquantifiers.  Sequent calculus rules.  Examples.\n\n<p></p></li>\n<li><b>Clausal proof methods.</b>\nClause form.  A SAT-solving procedure.  The resolution rule.\nExamples.  Refinements.\n\n<p></p></li>\n<li><b>Skolem functions, Unification and Herbrand\u2019s theorem.</b>\nPrenex normal form.  Skolemisation.  Most general unifiers. A\nunification algorithm.  Herbrand models and their\nproperties.\n\n<p></p></li>\n<li><b>Resolution theorem-proving and Prolog.</b>\nBinary resolution.  Factorisation.  Example of Prolog\nexecution. Proof by model elimination.\n\n<p></p></li>\n<li><b>Satisfiability Modulo Theories.</b>\nDecision problems and procedures. How SMT solvers work.\n\n<p></p></li>\n<li><b>Binary decision diagrams.</b>\nGeneral concepts.  Fast canonical form algorithm.  Optimisations.\nApplications.\n\n<p></p></li>\n<li><b>Modal logics.</b>\nPossible worlds semantics.  Truth and validity.  A Hilbert-style\nproof system.  Sequent calculus rules.\n\n<p></p></li>\n<li><b>Tableaux methods.</b>\nSimplifying the sequent calculus.  Examples.  Adding unification.\nSkolemisation.  The world\u2019s smallest theorem prover?\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to manipulate logical formulas accurately;\n\n<p></p></li>\n<li>be able to perform proofs using the presented formal calculi;\n\n<p></p></li>\n<li>be able to construct a small BDD;\n\n<p></p></li>\n<li>understand the relationships among the various calculi, e.g. SAT solving, resolution and Prolog;\n\n<p></p></li>\n<li>understand the concept of a decision procedure and the basic\nprinciples of \u201csatisfiability modulo theories\u201d.\n\n<p></p></li>\n<li>be able to apply the unification algorithm and to describe its uses.\n\n<p></p></li>\n\nRecommended reading\n* Huth, M. &amp; Ryan, M. (2004). <em>Logic in computer science: modelling and reasoning about systems</em>. Cambridge University Press (2nd ed.).\n<br/>Ben-Ari, M. (2001). <em>Mathematical logic for computer science</em>. Springer (2nd ed.).\n\n\n", "course_name": "Logic and Proof", "course_code": "LogicProof", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/LogicProof", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "Prolog": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Prolog.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction to Prolog.</b>  The structure of a Prolog program\n  and how to use the Prolog interpreter.  Unification. Some simple\n  programs.\n\n<p></p></li>\n<li><b>Arithmetic and lists.</b>  Prolog\u2019s support for evaluating\n  arithmetic expressions and lists.  The space complexity of program\n  evaluation discussed with reference to last-call optimisation.\n\n<p></p></li>\n<li><b>Backtracking, cut, and negation.</b>  The <tt>cut</tt> operator\n  for controlling backtracking.\n  <span class=\"textit\">Negation as failure</span> and its uses.\n\n<p></p></li>\n<li><b>Search and cut.</b>  Prolog\u2019s search method for solving\n  problems.  Graph searching exploiting Prolog\u2019s built-in\n  search mechanisms.\n\n<p></p></li>\n<li><b>Difference structures.</b>  Difference lists: introduction and\n  application to example programs.\n\n<p></p></li>\n<li><b>Building on Prolog.</b>  How particular limitations of Prolog\n  programs can be addressed by techniques such as Constraint Logic\n  Programming (CLP) and tabled resolution.\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be able to write programs in Prolog using techniques such as\n  accumulators and difference structures;\n\n<p></p></li>\n<li>know how to model the backtracking behaviour of program\n  execution;\n\n<p></p></li>\n<li>appreciate the unique perspective Prolog gives to problem\n  solving and algorithm design;\n\n<p></p></li>\n<li>understand how larger programs can be created using the basic\n  programming techniques used in this course.\n\n<p></p></li>\n\nRecommended reading\n* Bratko, I. (2001). <i>PROLOG programming for artificial intelligence</i>. Addison-Wesley (3rd or 4th\u00a0ed.).\n<br/>Sterling, L. &amp; Shapiro, E. (1994). <i>The art of Prolog</i>. MIT Press (2nd\u00a0ed.).\n\nFurther reading:\n\nO\u2019Keefe, R. (1990). <i>The craft of Prolog</i>. MIT Press. [This book is beyond the scope of this course, but it is very instructive. If you understand its contents, you\u2019re more than prepared for the examination.]\n\n\n", "course_name": "Prolog", "course_code": "Prolog", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Prolog", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "ArtInt": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligence.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction.</b> Alternate ways of thinking about\n  AI. <span class=\"textit\">Agents</span> as a unifying view of AI systems. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search I.</b> Search as a fundamental paradigm for\n  intelligent problem-solving. Simple, <span class=\"textit\">uninformed search</span>\n  algorithms. Tree search and graph search.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search II.</b> More sophisticated <span class=\"textit\">heuristic search</span>\n  algorithms. The A* algorithm and its properties. Improving memory\n  efficiency: the IDA* and recursive best first search\n  algorithms. Local search and gradient descent. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Game-playing.</b> Search in an adversarial\n  environment. The minimax algorithm and its shortcomings. Improving\n  minimax using alpha-beta pruning.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Constraint satisfaction problems (CSPs).</b> Standardising\n  search problems to a common format. The backtracking algorithm for\n  CSPs.  Heuristics for improving the search for a solution. Forward\n  checking, constraint propagation and arc consistency. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Backjumping in CSPs.</b> Backtracking, backjumping using\n  Gaschnig\u2019s algorithm, graph-based backjumping.  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning I.</b> How can we\n  represent and deal with commonsense knowledge and other forms of\n  knowledge? Semantic networks, frames and rules. How can we use\n  inference in conjunction with a knowledge representation scheme to\n  perform reasoning about the world and thereby to solve problems?\n  Inheritance, forward and backward chaining. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning II.</b> Knowledge\n  representation and reasoning using first order logic. The frame,\n  qualification and ramification problems.  The situation\n  calculus. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Planning I.</b> Methods for planning in advance how to solve a\n  problem. The STRIPS language. Achieving preconditions, backtracking\n  and fixing threats by promotion or demotion: the partial-order\n  planning algorithm. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Planning II.</b> Incorporating heuristics into partial-order\n  planning.  Planning graphs. The GRAPHPLAN algorithm. Planning using\n  propositional logic. Planning as a constraint satisfaction\n  problem. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Neural Networks I.</b> A brief introduction to supervised\n  learning from examples. Learning as fitting a curve to data. The\n  perceptron. Learning by gradient descent. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Neural Networks II.</b> Multilayer perceptrons and the\n  backpropagation algorithm. [1\u00a0lecture]\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should:\n\n\n<li>appreciate the distinction between the popular view of the field\nand the actual research results;\n\n<p></p></li>\n<li>appreciate the fact that the computational complexity of most AI\n  problems requires us regularly to deal with approximate techniques;\n\n<p></p></li>\n<li>be able to design basic problem solving methods based on\n  AI-based search, knowledge representation, reasoning, planning, and\n  learning algorithms.\n\n<p></p></li>\n\nRecommended reading\nThe recommended text is:\n\n* Russell, S. &amp; Norvig, P. (2010). <em>Artificial intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd ed.).\n<br/>There are many good books available on artificial intelligence; one \nalternative is:\n\nPoole, D. L. &amp; Mackworth, A. K. (2017). <em>Artificial intelligence: foundations of computational agents</em>.  Cambridge University Press (2nd ed.).\n\nFor some of the material you might find it useful to consult more \nspecialised texts, in particular:\n\nDechter, R. (2003). <span class=\"textit\">Constraint processing</span>. Morgan Kaufmann.\n<br/>Cawsey, A. (1998). <em>The essence of artificial intelligence</em>. Prentice\u00a0Hall.\n<br/>Ghallab, M., Nau, D. &amp; Traverso, P. (2004). <span class=\"textit\">Automated planning: theory and practice</span>. Morgan Kaufmann.\n<br/>Bishop, C.M. (2006). <em>Pattern recognition and machine learning</em>. Springer.\n<br/>Brachman, R.J &amp; Levesque, H.J. (2004). <em>Knowledge Representation and\nReasoning</em>. Morgan Kaufmann.\n<br/>\n", "course_name": "Artificial Intelligence", "course_code": "ArtInt", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ArtInt", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Complexity": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComplexityTheory.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Algorithms and problems.</b>\nComplexity of algorithms and of problems.  Lower and upper bounds.\nExamples: sorting and travelling salesman.\n\n<p>\n</p></li>\n<li><b>Time and space.</b>\nModels of computation and measures of complexity.  Time and space\ncomplexity on a Turing machine. Decidability and complexity.\n\n<p>\n</p></li>\n<li><b>Time complexity.</b>\nTime complexity classes.  Polynomial time problems and algorithms.\nProblems on numbers, graphs and formulas.\n\n<p>\n</p></li>\n<li><b>Non-determinism.</b>\nNon-deterministic machines.  The complexity class NP and its various\ncharacterizations.  Non-deterministic algorithms for satisfiability\nand other problems in NP.\n\n<p>\n</p></li>\n<li><b>NP-completeness.</b>\nReductions and completeness.  NP-completeness of satisfiability.\n\n<p>\n</p></li>\n<li><b>More NP-complete problems.</b>\nGraph-theoretic problems.  Independent set, clique and 3-colourability.\n\n<p>\n</p></li>\n<li><b>More NP-complete problems.</b>\nSets, numbers and scheduling.  Matching, set covering and knapsack.\n\n<p>\n</p></li>\n<li><b>coNP.</b>\nValidity of boolean formulae and its\ncompleteness.  NP\u00a0\u2229\u00a0coNP.  Primality and factorisation.\n\n<p>\n</p></li>\n<li><b>Cryptographic complexity.</b>\nOne-way functions.  The class UP.\n\n<p>\n</p></li>\n<li><b>Space complexity.</b>\nDeterministic and non-deterministic space complexity classes.  The\nreachability method.  Savitch\u2019s theorem.\n\n<p>\n</p></li>\n<li><b>Hierarchy.</b>\nThe time and space hierarchy theorems and complete problems.\n\n<p>\n</p></li>\n<li><b>Descriptive complexity.</b>\nLogics capturing complexity classes.  Fagin\u2019s theorem.\n\n<p>\n</p></li>\n\nObjectives\n\nAt the end of the course students should\n\n\n\n<li>be able to analyse practical problems and classify them\naccording to their complexity;\n\n<p>\n</p></li>\n<li>be familiar with the phenomenon of NP-completeness, and be able\nto identify problems that are NP-complete;\n\n<p>\n</p></li>\n<li>be aware of a variety of complexity classes and their\ninterrelationships;\n\n<p>\n</p></li>\n<li>understand the role of complexity analysis in cryptography.\n\n<p>\n</p></li>\n\nRecommended reading\n\n* Papadimitriou, Ch.H. (1994).  <em>Computational complexity</em>. Addison-Wesley.\n<br/>\nGoldreich, O. (2010). <em>P, NP, and NP-Completeness: the basics of \ncomputational complexity</em>. Cambridge University Press.\nSipser, M. (1997). <em>Introduction to the theory of computation</em>. PWS.\n\n\n\n", "course_name": "Complexity Theory", "course_code": "Complexity", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Complexity", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ConceptsPL": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConceptsinProgrammingLanguages.html", "description": "\n\n\nAims\nLectures\n<li><b>Introduction, motivation, and overview.</b>\nWhat is a programming language?  Application domains in language \ndesign.  Program execution models.  Theoretical foundations. \nLanguage standardization.  History.\n\n<p></p></li>\n<li><b>The ancestors: Fortran, Lisp, Algol and Pascal.</b>\nKey ideas: \n  procedural (Fortran), \n  declarative (Lisp), \n  block structured (Algol and Pascal).\nExecution models (abstract machines), \ndata types, \ncontrol structures, \nstorage, arrays and pointers, \nprocedures and forms of parameter passing,\nscope,\nstrict and lazy evaluation, \ngarbage collection.\nPrograms as data (Lisp).\n\n<p></p></li>\n<li><b>Object-oriented languages -- Concepts and origins:\nSimula\u00a0(1964-67) and Smalltalk\u00a0(1971-80).</b>\nDynamic lookup.  Abstraction.  Subtyping.  Inheritance.\nJavaScript prototypal vs Java class-based inheritance.\n\n<p></p></li>\n<li><b>Languages for parallel processing.</b>\nShared-memory concurrency with spawn/sync (OpenMP, Cilk, X10).\nDistributed-memory models (the actor model, Erlang).\nExternal vs. internal iteration.\n\n<p></p></li>\n<li><b>Types.</b>\nTypes in programming languages.\nType safety. \nType systems--static vs. dynamic.\nType checking and type inference.  Polymorphism.  Overloading.  \nType equivalence. \n\n<p></p></li>\n<li><b>Data abstraction and modularity: SML Modules\u00a0(1984-97).</b>\nInformation hiding.  Modularity.  Signatures, structures, and functors. \nSharing.\n\n<p></p></li>\n<li><b>Combining functional and object-oriented features.</b>\nScala and Java 8.\nGeneric types and methods.  Variance annotations.  The expression problem.\nValue types and deep copy.\n\n<p></p></li>\n<li><b>More-advanced concepts and idioms.</b>\nHaskell monads, type classes.\nContinuation passing style and call/cc. \nDependent types.\n\n<p></p></li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>be familiar with several \nlanguage paradigms and how they relate to different application\n   domains;\n\n<p></p></li>\n<li>understand the design space of programming languages, including\n   concepts and constructs from past \nlanguages as well as those that may be used \nin the future;\n\n<p></p></li>\n<li>develop a critical understanding of the programming languages that\n   we use by being able to identify and compare the same concept as it\n   appears in different languages.\n\n<p></p></li>\n\nRecommended reading\n<span class=\"textbf\">Books:</span>\n<br/>* Mitchell, J.C. (2003). \n  <em>Concepts in programming languages</em>.  \n  Cambridge University Press.\n<br/>* Scott, M.L. (2009). \n  <em>Programming language pragmatics</em>.  \n  Morgan Kaufmann.\n<br/>Odersky, M. (2008). \n  <em>Scala by example</em>. \n  Programming Methods Laboratory, EPFL.\n<br/>Pratt, T.W. &amp; Zelkowitz, M.V. (2001). \n  <em>Programming languages: design and implementation</em>.  \n  Prentice Hall.\n\n<span class=\"textbf\">Papers:</span>\n<br/>Kay, A.C. (1993).  \n  The early history of Smalltalk.  \n  <em>ACM SIGPLAN Notices</em>, Vol.\u00a028, No.\u00a03.\n<br/>Kernighan, B. (1981).  \n  Why Pascal is not my favorite programming language.  \n  AT&amp;T Bell Laboratories.  \n  <em>Computing Science Technical Report</em> No.\u00a0100.\n<br/>Koenig, A. (1994).  \n  An anecdote about ML type inference.  \n  <em>USENIX Symposium on Very High Level Languages</em>.\n<br/>Landin, P.J. (1966).\n  The next 700 programming languages.\n  <em>Communications of the ACM</em>, Vol.\u00a09, Issue\u00a03.\n<br/>Odersky, M. <em>et al.</em> (2006).\n  An overview of the Scala programming language.\n  <em>Technical Report LAMP-REPORT-2006-001</em>, Second Edition.\n<br/>McCarthy, J. (1960).  \n  Recursive functions of symbolic expressions and their computation \n  by machine.  \n  <em>Communications of the ACM</em>, 3(4):184-195.\n<br/>Stroustrup, B. (1991). \n  What is Object-Oriented Programming?  (1991 revised version). \n  <em>Proceedings\u00a01st European Software Festival</em>.\n\n\n", "course_name": "Concepts in Programming Languages", "course_code": "ConceptsPL", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ConceptsPL", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ForModLang": {"supervisions": 2, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FormalModelsofLanguage.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Natural language and the Chomsky hierarchy 1.</b> Recap classes of language. Closure properties of language classes. Recap pumping lemma for regular languages. Discussion of relevance (or not) to natural languages (example embedded clauses in English).\n</li>\n<li><b>Natural language and the Chomsky hierarchy 2.</b> Pumping lemma for context free languages. Discussion of relevance (or not) to natural languages (example Swiss-German cross serial dependancies). Properties of minimally context sensitive languages. Introduction to tree adjoining grammars.\n</li>\n<li><b>Language processing and context free grammar parsing 1.</b> Recap of context free grammar parsing. Language processing predictions based on top down parsing models (example Yngve\u2019s language processing predictions). Language processing predictions based on probabilistic parsing (example Halle\u2019s language processing predictions).\n</li>\n<li><b>Language processing and context free grammar parsing 2.</b> Introduction to context free grammar equivalent dependancy grammars. Language processing predictions based on Shift-Reduce parsing (examples prosodic look-ahead parsers, Parsey McParseface).\n</li>\n<li><b>Grammar induction of language classes.</b> Introduction to\n  grammar induction. Discussion of relevance (or not) to natural\n  language acquisition. Gold\u2019s theorem. Introduction to context free\n  grammar equivalent categorial grammars and their learnable classes.\n</li>\n<li><b>Natural language and information theory 1.</b> Entropy and natural language typology. Uniform information density as a predictor for language processing.\n</li>\n<li><b>Natural language and information theory 2.</b> Noisy channel encoding as a model for spelling error, translation and language processing.\n</li>\n<li><b>Vector space models and word vectors.</b> Introduction to\n  word vectors (example Word2Vec). Word vectors as predictors for  semantic language processing. \n</li>\n\nObjectives\nAt the end of the course students should\n\n\n<li>understand how known natural languages relate to formal languages in the Chomsky hierarchy;\n</li>\n<li>have knowledge of several context free grammars equivalents;\n</li>\n<li>understand how we might make predictions about language processing and language acquisition from formal models; \n</li>\n<li>know how to use information theoretic concepts to describe aspects of natural language.\n</li>\n\nRecommended reading\n* Jurafsky, D. &amp; Martin, J. (2008). <i>Speech and language\nprocessing</i>. Prentice Hall.\n<br/>Manning, C.D. &amp; Schutze, H. (1999) <em>Foundations of statistical natural\n  language processing</em>. MIT Press.\n<br/>Ruslan, M. (2003) <em>The Oxford handbook of computational linguistics</em>.\nOxford University Press.\n<br/>Clark, A., Fox, C. &amp; Lappin, S. (2010) <em>The handbook of computational\n  linguistics and natural language processing</em>. Wiley-Blackwell.\n<br/>Kozen, D. (1997) <em>Automata and computibility</em>. Springer.\n\n\n", "course_name": "Formal Models of Language", "course_code": "ForModLang", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/ForModLang", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Security": {"supervisions": 3, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Security.html", "description": "\n\n\nAims\nLectures\n\n<li><b>Introduction.</b> Malicious intent: safety vs. security\n  engineering. Security policies, targets, mechanisms. Aspects of\n  confidentiality, integrity, availability, privacy. Requirements\n  across different applications.\n\n<p>\n</p></li>\n<li><b>Operating-system security overview.</b> Access-control matrix,\n  trusted computing base, domain separation, CPU modes, system calls,\n  residual information protection, virtual machines.\n\n<p>\n</p></li>\n<li><b>POSIX discretionary access control.</b> User and group databases\n  and identifiers, file permission modes, ownership rights, sticky\n  bit, group inheritance, set-uid, elevation of privileges, root user,\n  NFS root squash, chroot, POSIX.1e ACLs.\n\n<p>\n</p></li>\n<li><b>Windows discretionary access control.</b> NTFS access rights,\n  security identifiers, access-control entries and lists, inheritance,\n  services, auditing, NFSv4 ACLs.\n\n<p>\n</p></li>\n<li><b>Linux-specific mechanisms.</b>\nLSM, Linux capabilities,\n  AppArmor, seccomp,namespaces, containers.\n\n<p>\n</p></li>\n<li><b>Running untrusted code.</b> Mandatory access control, covert\n  channels, SELinux, type enforcement, iOS/macOS/Android app-store\n  sandboxes, capabilities.\n\n<p>\n</p></li>\n<li><b>Software vulnerabilities.</b> buffer/integer\n  overflows, ASLR, metacharacter vulnerabilities: shell and SQL\n  injection, side channels, race conditions, environmental exploits,\n  fuzzing.\n\n<p>\n</p></li>\n<li><b>Cryptography overview.</b> Private/public-key encryption, MACs,\n  digital signatures, certificates, key revocation, secure hash\n  functions, key-establishment schemes, key generation.\n\n<p>\n</p></li>\n<li><b>Entity authentication.</b> Password verification, guessing\n  user-generated secrets, biometric identification, hardware tokens,\n  challenge-response authentication protocols, Kerberos, ssh, TLS.\n\n<p>\n</p></li>\n<li><b>Internet protocols.</b> TCP vs UDP, firewalls, iptables,\n  IPSEC/IKE, VPNs, IP options/fragmentation, DDoS.\n\n<p>\n</p></li>\n<li><b>Web security.</b> HTTP basics,HTTP authentication,\n  cookies, single sign-on (Ucam WebAuth, SAML),\n  delegation (OAuth2),\n  JavaScript, cross-site scripting, cross-site request forgery,\n  same-origin policy, CORS.\n\n<p>\n</p></li>\n\nObjectives\n\nBy the end of the course, students should appreciate the importance of\nadversarial thinking in systems design and have a good overview of the\nsecurity mechanisms and attributes of some of the most commonly used\noperating systems, networking infrastructure and Internet\napplications. They should also understand commonly exploited\nvulnerabilities of authentication mechanisms and know how to avoid some\ncommon security pitfalls in software development.\n\nRecommended reading\n\nGollmann, D. (2010). <em>Computer security</em>. Wiley (3rd ed.).\n<br/>\nDowd, M.; McDonald, J.; Schuh, J. (2007). <em>The art of software security assessment</em>. Addison-Wesley.\n\n\n\n", "course_name": "Security", "course_code": "Security", "course_url": "https://www.cl.cam.ac.uk/teaching/1920/Security", "lecturers": [], "year": "1920", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}}