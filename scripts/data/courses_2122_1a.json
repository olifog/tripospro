{"Databases": {"supervisions": 3, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "<h2>Aims</h2>\n<p>This course introduces basic concepts for database systems as\n  seen from the perspective of application designers. That is, the\n  focus is on the abstractions supported by database management\n  systems and not on how those abstractions are implemented.</p>\n<p>The database world is currently undergoing swift and dramatic\n  transformations largely driven by Internet-oriented applications\n  and services. Today many more options are available to database\n  application developers than in the past and so it is becoming\n  increasingly difficult to sort fact from fiction. The course\n  attempts to cut through the fog with a practical approach that\n  emphasises engineering tradeoffs that underpin these recent\n  developments and also guide our selection of \u201cthe right tool for\n  the job.\u201d</p>\n<p>This course covers three approaches. First, the traditional\n  mainstay of the database industry -- the relational approach --\n  is described with emphasis on eliminating logical redundancy in\n  data. Then two representatives of recent trends are presented --\n  graph-oriented and document-oriented databases. The lectures are\n  tightly integrated with the associated practical sessions where\n  students gain hands-on experience with all three of these\n  approaches.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> What is a database system?\n    What is a data model? A central tradeoff in the choice of data\n    representation: optimise for ease of updating or for fast query\n    response. On-Line Transaction Processing (OLTP) versus On-line\n    Analytical Processing (OLAP). Application independent versus\n    application specific data representations.\n    [1\u00a0lecture]</li>\n<li><strong>Conceptual modeling</strong> The\n    Entity-Relationship (ER) approach as an\n    implementation-independent technique for modeling data.\n    [1\u00a0lecture]</li>\n<li><strong>The relational model</strong> Implementing ER\n    models with relational tables. Relational algebra and SQL.\n    Update anomalies caused by logical redundancy. Minimise logical\n    redundancy with normalised data representation. What is\n    transitive closure? Why SQL struggles with transitive closure.\n    [2\u00a0lectures]</li>\n<li><strong>The graph-oriented model</strong> The NoSQL\n    movement. Implementing ER models in a graph-oriented database.\n    Graph databases: optimised for computing transitive closure.\n    Path-oriented queries. [2\u00a0lectures]</li>\n<li><strong>The document-oriented model</strong>\n    Semi-structured data (XML, JSON). Document-oriented databases.\n    Embracing data redundancy: representing data for fast,\n    application-specific, access. [1\u00a0lecture]</li>\n<li><strong>The multi-dimensional model</strong>. Data cubes,\n    star schema, data warehouse. [1\u00a0lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to design entity-relationship diagrams to represent\n    simple database application scenarios</li>\n<li>know how to convert entity-relationship diagrams to\n    relational- and graph-oriented implementations</li>\n<li>understand the fundamental tradeoff between the ease of\n    updating data and the response time of complex queries</li>\n<li>understand that no single data architecture can be used to\n    meet all data management requirements</li>\n<li>be familiar with recent trends in the database area.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Lemahieu, W., Broucke, S. van den and Baesens, B. (2018)\n  <em>Principles of database management</em>. Cambridge University\n  Press.</p>\n", "course_name": "Databases", "course_code": "Databases", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/Databases", "lecturers": ["tgg22"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": 3, "prerequisite_for": ["ECAD+Arch", "IntComArch", "OpSystems"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "<h2>Aims</h2>\n<p>The aims of this course are to present the principles of\n  combinational and sequential digital logic design and\n  optimisation at a gate level. The use of n and p channel MOSFETs\n  for building logic gates is also introduced.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Semiconductors to computers.\n    Logic variables. Examples of simple logic. Logic gates. Boolean\n    algebra. De Morgan\u2019s theorem.</li>\n<li><strong>Logic minimisation.</strong> Truth tables and\n    normal forms. Karnaugh maps. Quine-McCluskey method.</li>\n<li><strong>Binary adders.</strong> Half adder, full adder,\n    ripple carry adder, fast carry generation.</li>\n<li><strong>Combinational logic design: further\n    considerations.</strong> Multilevel logic. Gate propagation\n    delay. An introduction to timing diagrams. Hazards and hazard\n    elimination. Other ways to implement combinational logic.</li>\n<li><strong>Introduction to practical classes.</strong>\n    Prototyping box. Breadboard and Dual in line (DIL) packages.\n    Wiring. Use of oscilloscope.</li>\n<li><strong>Sequential logic.</strong> Memory elements. RS\n    latch. Transparent D latch. Master-slave D flip-flop. T and JK\n    flip-flops. Setup and hold times.</li>\n<li><strong>Sequential logic.</strong> Counters: Ripple and\n    synchronous. Shift registers.</li>\n<li><strong>Synchronous State Machines.</strong> Moore and\n    Mealy finite state machines (FSMs). Reset and self starting.\n    State transition diagrams. Elimination of redundant\n    states.</li>\n<li><strong>Further state machines.</strong> State assignment:\n    sequential, sliding, shift register, one hot. Implementation of\n    FSMs.</li>\n<li><strong>Introduction to microprocessors.</strong>\n    Microarchitecture, fetch, register access, memory access,\n    branching, execution time.</li>\n<li><strong>Electronics, Devices and Circuits.</strong> Current\n    and voltage, resistance, basic circuit theory, the potential\n    divider. Solving non-linear circuits. N and p channel MOSFETs\n    and n-MOSFET logic, e.g., n-MOSFET inverter. Switching speed\n    and power consumption problems in n-MOSFET logic. CMOS logic.\n    Logic families. Noise margin. Analogue interfacing and\n    operational amplifiers. [3\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand the relationships between combination logic and\n    boolean algebra, and between sequential logic and finite state\n    machines;</li>\n<li>be able to design and minimise combinational logic;</li>\n<li>appreciate tradeoffs in complexity and speed of\n    combinational designs;</li>\n<li>understand how state can be stored in a digital logic\n    circuit;</li>\n<li>know how to design a simple finite state machine from a\n    specification and be able to implement this in gates and edge\n    triggered flip-flops;</li>\n<li>understand how to use MOSFETs to build digital logic\n    circuits.</li>\n<li>understand the effect of finite load capacitance on the\n    performance of digital logic circuits.</li>\n<li>understand basic analogue interfacing.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Harris, D.M. and Harris, S.L. (2013). <em>Digital design and\n  computer architecture</em>. Morgan Kaufmann (2nd ed.). The first\n  edition is still relevant.<br/>\n  Katz, R.H. (2004). <em>Contemporary logic design</em>.\n  Benjamin/Cummings. The 1994 edition is more than sufficient.<br/>\n  Hayes, J.P. (1993). <em>Introduction to digital logic\n  design</em>. Addison-Wesley.</p>\n<p>Books for reference:</p>\n<p>Horowitz, P. and Hill, W. (1989). <em>The art of\n  electronics</em>. Cambridge University Press (2nd\u00a0ed.) (more\n  analog).<br/>\n  Weste, N.H.E. and Harris, D. (2005). <em>CMOS VLSI Design - a\n  circuits and systems perspective</em>. Addison-Wesley (3rd\n  ed.).<br/>\n  Mead, C. and Conway, L. (1980). <em>Introduction to VLSI\n  systems</em>. Addison-Wesley.<br/>\n  Crowe, J. and Hayes-Gill, B. (1998). <em>Introduction to digital\n  electronics</em>. Butterworth-Heinemann.<br/>\n  Gibson, J.R. (1992). <em>Electronic logic circuits</em>.\n  Butterworth-Heinemann.</p>\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/DigElec", "lecturers": ["ijw24"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMath": {"supervisions": 6, "prerequisite_for": ["CAT", "CompConstr", "CompTheory", "Crypto", "ForModLang", "IntroProb", "MLBayInfer", "MSP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "<h2>Aims</h2>\n<p>The course aims to introduce the mathematics of discrete\n  structures, showing it as an essential tool for computer science\n  that can be clever and beautiful.</p>\n<h2>Lectures</h2>\n<ul>\n<li>\n<strong>Proof [5\u00a0lectures].</strong>\n<p>Proofs in practice and mathematical jargon. Mathematical\n      statements: implication, bi-implication, universal\n      quantification, conjunction, existential quantification,\n      disjunction, negation. Logical deduction: proof strategies\n      and patterns, scratch work, logical equivalences. Proof by\n      contradiction. Divisibility and congruences. Fermat\u2019s Little\n      Theorem.</p>\n</li>\n<li>\n<strong>Numbers [5\u00a0lectures].</strong>\n<p>Number systems: natural numbers, integers, rationals,\n      modular integers. The Division Theorem and Algorithm. Modular\n      arithmetic. Sets: membership and comprehension. The greatest\n      common divisor, and Euclid\u2019s Algorithm and Theorem. The\n      Extended Euclid\u2019s Algorithm and multiplicative inverses in\n      modular arithmetic. The Diffie-Hellman cryptographic method.\n      Mathematical induction: Binomial Theorem, Pascal\u2019s Triangle,\n      Fundamental Theorem of Arithmetic, Euclid\u2019s infinity of\n      primes.</p>\n</li>\n<li>\n<strong>Sets [9\u00a0lectures].</strong>\n<p>Extensionality Axiom: subsets and supersets. Separation\n      Principle: Russell\u2019s Paradox, the empty set. Powerset Axiom:\n      the powerset Boolean algebra, Venn and Hasse diagrams.\n      Pairing Axiom: singletons, ordered pairs, products. Union\n      axiom: big unions, big intersections, disjoint unions.\n      Relations: composition, matrices, directed graphs, preorders\n      and partial orders. Partial and (total) functions.\n      Bijections: sections and retractions. Equivalence relations\n      and set partitions. Calculus of bijections: characteristic\n      (or indicator) functions. Finite cardinality and counting.\n      Infinity axiom. Surjections. Enumerable and countable sets.\n      Axiom of choice. Injections. Images: direct and inverse\n      images. Replacement Axiom: set-indexed constructions. Set\n      cardinality: Cantor-Schoeder-Bernstein Theorem, unbounded\n      cardinality, diagonalisation, fixed-points. Foundation\n      Axiom.</p>\n</li>\n<li>\n<strong>Formal languages and automata\n      [5\u00a0lectures].</strong>\n<p>Introduction to inductive definitions using rules and\n      proof by rule induction. Abstract syntax trees. Regular\n      expressions and their algebra. Finite automata and regular\n      languages: Kleene\u2019s theorem and the Pumping Lemma.</p>\n</li>\n</ul>\n<h2>Objectives</h2>\n<p>On completing the course, students should be able to</p>\n<ul>\n<li>prove and disprove mathematical statements using a variety\n    of techniques;</li>\n<li>apply the mathematical principle of induction;</li>\n<li>know the basics of modular arithmetic and appreciate its\n    role in cryptography;</li>\n<li>understand and use the language of set theory in\n    applications to computer science;</li>\n<li>define sets inductively using rules and prove properties\n    about them;</li>\n<li>convert between regular expressions and finite\n    automata;</li>\n<li>use the Pumping Lemma to prove that a language is not\n    regular.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Biggs, N.L. (2002). <em>Discrete mathematics.</em> Oxford\n  University Press (Second Edition).<br/>\n  Davenport, H. (2008). <em>The higher arithmetic: an introduction\n  to the theory of numbers.</em> Cambridge University Press.<br/>\n  Hammack, R. (2013). <em>Book of proof.</em> Privately published\n  (Second edition). Available at:<br/>\n<a href=\"http://www.people.vcu.edu/~rhammack/BookOfProof/index.html\" id=\"tex2html4\" name=\"tex2html4\">http://www.people.vcu.edu/\u00a0rhammack/BookOfProof/index.html</a><br/>\n  Houston, K. (2009). <em>How to think like a mathematician: a\n  companion to undergraduate mathematics.</em> Cambridge University\n  Press.<br/>\n  Kozen, D.C. (1997). <em>Automata and computability</em>.\n  Springer.<br/>\n  Lehman, E.; Leighton, F.T.; Meyer, A.R. (2014). <em>Mathematics\n  for computer science.</em> Available on-line.<br/>\n  Velleman, D.J. (2006). <em>How to prove it: a structured\n  approach.</em> Cambridge University Press (Second Edition).</p>\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/DiscMath", "lecturers": ["mpf23", "fms27"], "lectures": 24, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 3, "prerequisite_for": ["CAT", "NLP", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "<h2>Aims</h2>\n<p>The main aim of this course is to present the basic principles\n  of programming. As the introductory course of the Computer\n  Science Tripos, it caters for students from all backgrounds. To\n  those who have had no programming experience, it will be\n  comprehensible; to those experienced in languages such as C, it\n  will attempt to correct any bad habits that they have learnt.</p>\n<p>A further aim is to introduce the principles of data\n  structures and algorithms. The course will emphasise the\n  algorithmic side of programming, focusing on problem-solving\n  rather than on hardware-level bits and bytes. Accordingly it will\n  present basic algorithms for sorting, searching, etc., and\n  discuss their efficiency using <em>O</em>-notation. Worked\n  examples (such as polynomial arithmetic) will demonstrate how\n  algorithmic ideas can be used to build efficient\n  applications.</p>\n<p>The course will use a functional language (OCaml). OCaml is\n  particularly appropriate for inexperienced programmers, since a\n  faulty program cannot crash and OCaml\u2019s unobtrusive type system\n  captures many program faults before execution. The course will\n  present the elements of functional programming, such as curried\n  and higher-order functions. But it will also introduce\n  traditional (procedural) programming, such as assignments, arrays\n  and references.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to Programming.</strong> The role of\n    abstraction and representation. Introduction to integer and\n    floating-point arithmetic. Declaring functions. Decisions and\n    booleans. Example: integer exponentiation.</li>\n<li><strong>Recursion and Efficiency.</strong> Examples:\n    Exponentiation and summing integers. Iteration <em>versus</em>\n    recursion. Examples of growth rates. Dominance and\n    <em>O</em>-Notation. The costs of some representative\n    functions. Cost estimation.</li>\n<li><strong>Lists.</strong> Basic list operations. Append.\n    Na\u00efve <em>versus</em> efficient functions for length and\n    reverse. Strings.</li>\n<li><strong>More on lists.</strong> The utilities take and\n    drop. Pattern-matching: zip, unzip. A word on polymorphism. The\n    \u201cmaking change\u201d example.</li>\n<li><strong>Sorting.</strong> A random number generator.\n    Insertion sort, mergesort, quicksort. Their efficiency.</li>\n<li><strong>Datatypes and trees.</strong> Pattern-matching and\n    case expressions. Exceptions. Binary tree traversal (conversion\n    to lists): preorder, inorder, postorder.</li>\n<li><strong>Dictionaries and functional arrays.</strong>\n    Functional arrays. Dictionaries: association lists (slow)\n    <em>versus</em> binary search trees. Problems with unbalanced\n    trees.</li>\n<li><strong>Functions as values.</strong> Nameless functions.\n    Currying. The \u201capply to all\u201d functional, map. Examples: The\n    predicate functionals filter and exists.</li>\n<li><strong>Sequences, or lazy lists.</strong> Non-strict\n    functions such as <em>IF</em>. Call-by-need <em>versus</em>\n    call-by-name. Lazy lists. Their implementation in OCaml.\n    Applications, for example Newton-Raphson square roots.</li>\n<li><strong>Queues and search strategies.</strong> Depth-first\n    search and its limitations. Breadth-first search (BFS).\n    Implementing BFS using lists. An efficient representation of\n    queues. Importance of efficient data representation.</li>\n<li><strong>Elements of procedural programming.</strong>\n    Address <em>versus</em> contents. Assignment <em>versus</em>\n    binding. Own variables. Arrays, mutable or not. Introduction to\n    linked lists.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course, students should</p>\n<ul>\n<li>be able to write simple OCaml programs;</li>\n<li>understand the fundamentals of using a data structure to\n    represent some mathematical abstraction;</li>\n<li>be able to estimate the efficiency of simple algorithms,\n    using the notions of average-case, worse-case and amortised\n    costs;</li>\n<li>know the comparative advantages of insertion sort, quick\n    sort and merge sort;</li>\n<li>understand binary search and binary search trees;</li>\n<li>know how to use currying and higher-order functions;</li>\n<li>understand how OCaml combines imperative and functional\n    programming in a single language.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>John Whitington. <em>OCaml from the Very Beginning</em>.\n  (http://ocaml-book.com).</p>\n<p>Okasaki, C. (1998). <em>Purely functional data\n  structures</em>. Cambridge University Press.</p>\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/FoundsCS", "lecturers": ["avsm2"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": "\n<p>The Hardware Practical Classes accompany the Digital\n  Electronics series of lectures. The aim of the Practical Classes\n  is to enable students to get hands-on experience of designing,\n  building, and testing and debugging of digital electronic\n  circuits. The intention is to hold the labs face-to-face using\n  actual hardware in the Intel Lab. located in the William Gates\n  Building (WGB). However, if this is not possible, alternative\n  simulation based labs will be substituted to replace either all\n  or some of the face-to-face labs.</p>\n<p>The Digital Electronics lecture series occupies 12 lectures in\n  the first 4 weeks of the Michaelmas Term, while the Practical\n  Classes occupy the latter 6 weeks of the Michaelmas Term and all\n  8 weeks of the Lent Term.</p>\n<p>The Practical Classes take the form of 4 workshops,\n  specifically for the face-to-face classes:</p>\n<ul>\n<li>Workshop 1 \u2013 Electronic Die;</li>\n<li>Workshop 2 \u2013 Shaft Position Encoder;</li>\n<li>Workshop 3 \u2013 Debouncing a Switch;</li>\n<li>Workshop 4 \u2013 Framestore for an LED Array.</li>\n</ul>\n<p>In general, the workshops require some preparatory work to be\n  done prior to the practical session. These tasks are highlighted\n  at the beginning of each Worksheet. Typically this involves\n  preparing a design that you will then build, test and modify\n  during the practical class. Note that insufficient preparation\n  prior to the practical classes may compromise effective use of\n  your time in the laboratory.</p>\n<p>In the Practical Classes you will usually work on your own,\n  and you are expected to complete one Workshop in each of your\n  scheduled sessions. Demonstrators are available during the\n  sessions to assist you with any queries or problems you may\n  have.</p>\n<p>Important: Remember to get your work ticked.</p>\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/HW", "lecturers": ["ijw24"], "lectures": null, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Graphics": {"supervisions": 2, "prerequisite_for": ["FGraphics"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoGraphics.html", "description": "<h2>Aims</h2>\n<p>To introduce the necessary background, the basic algorithms,\n  and the applications of computer graphics and graphics\n  hardware.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Background.</strong> What is an image? Resolution\n    and quantisation. Storage of images in memory. [1 lecture]</li>\n<li><strong>Rendering.</strong> Perspective. Reflection of\n    light from surfaces and shading. Geometric models. Ray tracing.\n    [2 lectures]</li>\n<li><strong>Graphics pipeline.</strong> Polygonal mesh models.\n    Transformations using matrices in 2D and 3D. Homogeneous\n    coordinates. Projection: orthographic and perspective. [1\n    lecture]</li>\n<li><strong>Graphics hardware and modern OpenGL.</strong> GPU\n    rendering. GPU frameworks and APIs. Vertex processing.\n    Rasterisation. Fragment processing. Working with meshes and\n    textures. Z-buffer. Double-buffering and frame synchronization.\n    [2 lectures]</li>\n<li>\u00a0</li>\n<li><strong>Human vision, colour and tone mapping</strong>.\n    Perception of colour. Tone mapping. Colour spaces. [2\n    lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should be able to:</p>\n<ul>\n<li>understand and apply in practice basic concepts of\n    ray-tracing: ray-object intersection, reflections, refraction,\n    shadow rays, distributed ray-tracing, direct and indirect\n    illumination;</li>\n<li>describe and explain the following algorithms: z-buffer,\n    texture mapping, double buffering, mip-map, and\n    normal-mapping;</li>\n<li>use matrices and homogeneous coordinates to represent and\n    perform 2D and 3D transformations; understand and use 3D to 2D\n    projection, the viewing volume, and 3D clipping;</li>\n<li>implement OpenGL code for rendering of polygonal objects,\n    control camera and lighting, work with vertex and fragment\n    shaders;</li>\n<li>describe a number of colour spaces and their relative\n    merits.</li>\n<li>explain the need for tone mapping and colour processing in\n    rendering pipeline.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Shirley, P. and Marschner, S. (2009). <em>Fundamentals of\n  Computer Graphics</em>. CRC Press (3rd ed.).</p>\n<p>Foley, J.D., van Dam, A., Feiner, S.K. and Hughes, J.F.\n  (1990). <em>Computer graphics: principles and practice</em>.\n  Addison-Wesley (2nd ed.).</p>\n<p>Kessenich, J.M., Sellers, G. and Shreiner, D (2016).\n  <em>OpenGL Programming Guide: The Official Guide to Learning\n  OpenGL, Version 4.5 with SPIR-V</em>, [seventh edition and\n  later]</p>\n", "course_name": "Introduction to Graphics", "course_code": "Graphics", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/Graphics", "lecturers": ["rkm38"], "lectures": 8, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OCaml": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "OCaml Practical Classes", "course_code": "OCaml", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/OCaml", "lecturers": ["jdy22"], "lectures": null, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 3, "prerequisite_for": ["ConcDisSys", "FJava", "MSP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html", "description": "<h2>Aims</h2>\n<p>The goal of this course is to provide students with an\n  understanding of Object-Oriented Programming. Concepts are\n  demonstrated in multiple languages, but the primary language is\n  Java.</p>\n<h2>Lecture syllabus</h2>\n<ul>\n<li><strong>Types, Objects and Classes</strong> Moving from\n    functional to imperative. Functions, methods. Control flow.\n    values, variables and types. Primitive Types. Classes as custom\n    types. Objects vs Classes. Class definition, constructors.\n    Static data and methods.</li>\n<li><strong>Designing Classes</strong> Identifying classes. UML\n    class diagrams. Modularity. Encapsulation/data hiding.\n    Immutability. Access modifiers. Parameterised types\n    (Generics).</li>\n<li><strong>Pointers, References and Memory</strong> Pointers\n    and references. Reference types in Java. The call stack. The\n    heap. Iteration and recursion. Pass-by-value and\n    pass-by-reference.</li>\n<li><strong>Inheritance</strong> Inheritance. Casting.\n    Shadowing. Overloading. Overriding. Abstract Methods and\n    Classes.</li>\n<li><strong>Polymorphism and Multiple Inheritance</strong>\n    Polymorphism in ML and Java. Multiple inheritance. Interfaces\n    in Java.</li>\n<li><strong>Lifecycle of an Object</strong> Constructors and\n    chaining. Destructors. Finalizers. Garbage Collection:\n    reference counting, tracing.</li>\n<li><strong>Java Collections and Object Comparison</strong>\n    Java Collection interface. Key classes. Collections class.\n    Iteration options and the use of Iterator. Comparing primitives\n    and objects. Operator overloading.</li>\n<li><strong>Error Handling</strong> Types of errors.\n    Limitations of return values. Deferred error handling.\n    Exceptions. Custom exceptions. Checked vs unchecked.\n    Inappropriate use of exceptions. Assertions.</li>\n<li><strong>DesignLanguage evolution</strong> Need for\n    languages to evolve. Generics in Java. Type erasure.\n    Introduction to Java 8: Lambda functions, functions as values,\n    method references, streams.</li>\n<li><strong>Design Patterns</strong> Introduction to design\n    patterns. Open-closed principle. Examples of Singleton,\n    Decorator, State, Composite, Strategy, Observer. [2\n    lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with the main features and limitations of the\n    Java language;</li>\n<li>be able to write a Java program to solve a well specified\n    problem;</li>\n<li>understand the principles of OOP;</li>\n<li>be able to demonstrate good object-oriented programming\n    skills in Java;</li>\n<li>be able to describe, recognise, apply and implement\n    selected design patterns in Java;</li>\n<li>be familiar with common errors in Java and its associated\n    libraries;</li>\n<li>understand a Java program written by someone else;</li>\n<li>be able to debug and test Java programs;</li>\n<li>be familiar with major parts of Java 8 SE libraries;</li>\n<li>understand how to read Javadoc library documentation and\n    reuse library code.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>No single text book covers all of the topics in this course.\n  For those new to OOP, the best introductions are usually found in\n  the introductory programming texts for OOP languages (such as\n  Java, Python or C++). Look for those that are for people new to\n  programming rather than those that are designed for programmers\n  transitioning between languages (the Deitel book is highlighted\n  for this reason). The web is also a very useful resource -- look\n  for Java tutorials.</p>\n<p>* Deitel, H.M. and Deitel, P.J. (2009). <em>Java: How to\n  Program</em>. Prentice Hall (8th ed.).<br/>\n  Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick\n  reference</em>. O\u2019Reilly (5th ed.).<br/>\n  Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial\n  companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).<br/>\n  Gamma, E., Helm, R., Johnson, R. and Vlissides, A. (1995).\n  <em>Design patterns: elements of reusable object-oriented\n  software</em>. Addison-Wesley.<br/>\n  Bloch, J. and Gafter, N. (2005). <em>Java puzzlers</em>.\n  Addison-Wesley.</p>\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/OOProg", "lecturers": ["acr31"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/Registratn", "lecturers": ["aac10", "rkh23"], "lectures": null, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "SciComp": {"supervisions": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>This course is a hands-on introduction to using computers to\n  investigate scientific models and data.</p>\n<h2>Syllabus</h2>\n<ul>\n<li>Python notebooks. Overview of the Python programming\n    language. Use of notebooks for scientific computing.</li>\n<li>Numerical computation. Writing fast vectorized code in\n    numpy. Optimization and fitting. Simulation.</li>\n<li>Working with data. Data import. Common ways to summarize\n    and plot data, for univariate and multivariate analysis.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to import data, plot it, and summarize it\n    appropriately</li>\n<li>be able to write fast vectorized code for scientific / data\n    work</li>\n</ul>\n", "course_name": "Scientific Computing Practical Course", "course_code": "SciComp", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/SciComp", "lecturers": ["djw1005"], "lectures": 1, "year": "2122", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Algorithm1": {"supervisions": 3, "prerequisite_for": ["Algorithm2", "ArtInt", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms1.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  computer algorithms and data structures, with an emphasis on\n  foundational material.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Sorting.</strong> Review of complexity and\n    O-notation. Trivial sorting algorithms of quadratic complexity.\n    Review of merge sort and quicksort, understanding their memory\n    behaviour on statically allocated arrays. Heapsort. Stability.\n    Other sorting methods including sorting in linear time. Median\n    and order statistics. [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9]\n    [about 4 lectures]</li>\n<li><strong>Strategies for algorithm design.</strong> Dynamic\n    programming, divide and conquer, greedy algorithms and other\n    useful paradigms. [Ref: CLRS3 chapters 4, 15, 16] [about 3\n    lectures]</li>\n<li><strong>Data structures.</strong> Elementary data\n    structures: pointers, objects, stacks, queues, lists, trees.\n    Binary search trees. Red-black trees. B-trees. Hash tables.\n    Priority queues and heaps. [Ref: CLRS3 chapters 6, 10, 11, 12,\n    13, 18] [about 5 lectures].</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>have a thorough understanding of several classical\n    algorithms and data structures;</li>\n<li>be able to analyse the space and time efficiency of most\n    algorithms;</li>\n<li>have a good understanding of how a smart choice of data\n    structures may be used to increase the efficiency of particular\n    algorithms;</li>\n<li>be able to design new algorithms or modify existing ones\n    for new applications and reason about the efficiency of the\n    result.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Cormen, T.H., Leiserson, C.D., Rivest, R.L. and Stein, C.\n  (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.).\n  ISBN 978-0-262-53305-8</p>\n<p>Sedgewick, R., Wayne, K. (2011). <em>Algorithms</em>.\n  Addison-Wesley. ISBN 978-0-321-57351-3.</p>\n<p>Kleinberg, J. and Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.</p>\n<p>Knuth, D.A. (2011). <em>The Art of Computer Programming</em>.\n  Addison-Wesley. ISBN 978-0-321-75104-1.</p>\n", "course_name": "Algorithms 1", "course_code": "Algorithm1", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/Algorithm1", "lecturers": ["fms27"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "Algorithm2": {"supervisions": 3, "prerequisite_for": ["ArtInt", "Complexity", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms2.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  computer algorithms and data structures, with an emphasis on\n  foundational material.</p>\n<h2>Lectures</h2>\n<ul style=\"list-style-type:square\">\n<li>Graph algorithms.\u00a0Graph representations. Breadth-first\n    and depth-first search. Topological sort. Minimum spanning\n    tree. Kruskal and Prim algorithms. Single-source shortest\n    paths: Bellman-Ford and Dijkstra algorithms. All-pairs shortest\n    paths: matrix multiplication and Johnson\u2019s algorithms. Maximum\n    flow: Ford-Fulkerson method, Max-Flow Min-Cut Theorem.\n    Matchings in bipartite graphs. [Ref: CLRS3 chapters 22, 23, 24,\n    25, 26] [about 7 lectures]</li>\n<li>Advanced data structures.\u00a0Binomial heap. Amortized\n    analysis: aggregate analysis, potential method. Fibonacci\n    heaps. Disjoint sets. [Ref: CLRS3 chapters 17, 19, 20, 21]\n    [about 4 lectures]</li>\n<li>Geometric algorithms.\u00a0Intersection of segments. Convex\n    hull: Graham\u2019s scan, Jarvis\u2019s march. [Ref: CLRS3 chapter 33]\n    [about 1 lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>have a thorough understanding of several classical\n    algorithms and data structures;</li>\n<li>be able to analyse the space and time efficiency of most\n    algorithms;</li>\n<li>have a good understanding of how a smart choice of data\n    structures may be used to increase the efficiency of particular\n    algorithms;</li>\n<li>be able to design new algorithms or modify existing ones\n    for new applications and reason about the efficiency of the\n    result.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Cormen, T.H., Leiserson, C.D., Rivest, R.L. and Stein, C.\n  (2009).\u00a0Introduction to Algorithms. MIT Press (3rd ed.).\n  ISBN 978-0-262-53305-8</p>\n<p>Sedgewick, R., Wayne, K. (2011).\u00a0Algorithms.\n  Addison-Wesley. ISBN 978-0-321-57351-3.</p>\n<p>Kleinberg, J. and Tardos, \u00c9. (2006).\u00a0Algorithm design.\n  Addison-Wesley. ISBN 978-0-321-29535-4.</p>\n<p>Knuth, D.A. (2011).\u00a0The Art of Computer Programming.\n  Addison-Wesley. ISBN 978-0-321-75104-1.</p>\n<p>\u00a0</p>\n<p>\u00a0</p>\n", "course_name": "Algorithms 2", "course_code": "Algorithm2", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/Algorithm2", "lecturers": ["djw1005"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "MLRD": {"supervisions": 4, "prerequisite_for": ["ADS", "NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MachineLearningandReal-worldData.html", "description": "<h2>Aims</h2>\n<p>This course introduces students to machine learning algorithms\n  as used in real-world applications, and to the experimental\n  methodology necessary to perform statistical analysis of\n  large-scale data from unpredictable processes. Students will\n  perform 3 extended practicals, as follows:</p>\n<ul>\n<li>Statistical classification: Determining movie review\n    sentiment using Naive Bayes (7 sessions);</li>\n<li>Sequence Analysis: Hidden Markov Modelling and its\n    application to a task from biology (predicting protein\n    interactions with a cell membrane) (4 sessions);</li>\n<li>Analysis of social networks, including detection of cliques\n    and central nodes (5 sessions).</li>\n</ul>\n<h2>Syllabus</h2>\n<ul>\n<li><strong>Topic One: Statistical Classification [7\n    sessions].</strong><br/>\n    Introduction to sentiment classification.<br/>\n    Naive Bayes parameter estimation.<br/>\n    Statistical laws of language.<br/>\n    Statistical tests for classification tasks.<br/>\n    Cross-validation and test sets.<br/>\n    Uncertainty and human agreement.</li>\n<li><strong>Topic Two: Sequence Analysis [4\n    sessions].</strong><br/>\n    Hidden Markov Models (HMM) and HMM training.<br/>\n    The Viterbi algorithm.<br/>\n    Using an HMM in a biological application.</li>\n<li><strong>Topic Three: Social Networks [5\n    sessions].</strong><br/>\n    Properties of networks: Degree, Diameter.<br/>\n    Betweenness Centrality.<br/>\n    Clustering using betweenness centrality.</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should be able to:</p>\n<ul>\n<li>understand and program two simple supervised machine\n    learning algorithms;</li>\n<li>use these algorithms in statistically valid experiments,\n    including the design of baselines, evaluation metrics,\n    statistical testing of results, and provision against\n    overtraining;</li>\n<li>visualise the connectivity and centrality in large\n    networks;</li>\n<li>use clustering (i.e., a type of unsupervised machine\n    learning) for detection of cliques in unstructured\n    networks.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Jurafsky, D. and Martin, J. (2008). <em>Speech and language\n  processing</em>. Prentice Hall.</p>\n<p>Easley, D. and Kleinberg, J. (2010). <em>Networks, crowds, and\n  markets: reasoning about a highly connected world</em>. Cambridge\n  University Press.</p>\n", "course_name": "Machine Learning and Real-world Data", "course_code": "MLRD", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/MLRD", "lecturers": ["sht25", "av308"], "lectures": 16, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OpSystems": {"supervisions": 3, "prerequisite_for": ["CC", "ConcDisSys", "UnixTools"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "<h2>Aims</h2>\n<p>The overall aim of this course is to provide a general\n  understanding of the structure and key functions of the operating\n  system. Case studies will be used to illustrate and reinforce\n  fundamental concepts.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to operating systems.</strong>\n    Abstract view of an operating system. Elementary computer\n    architecture. OS evolution: multi-programming, time-sharing.\n    [1\u00a0lecture]</li>\n<li><strong>Protection.</strong> Dual-mode operation.\n    Protecting I/O, memory, CPU. Kernels and micro-kernels. Virtual\n    machines and containers. Subjects and objects. Authentication.\n    Access matrix: ACLs and capabilities. Combined scheme. Covert\n    channels. [1\u00a0lecture]</li>\n<li><strong>Processes.</strong> Job/process concepts.\n    Lifecycle. Process management. Inter-process communication.\n    [1\u00a0lecture]</li>\n<li><strong>Scheduling.</strong> Scheduling basics: CPU-I/O\n    interleaving, (non-)preemption, context switching. Scheduling\n    algorithms: FCFS, SJF, SRTF, priority scheduling, round robin.\n    Combined schemes. [2\u00a0lectures]</li>\n<li><strong>Memory management.</strong> Processes in memory.\n    Logical addresses. Partitions: static <em>versus</em> dynamic,\n    free space management, external fragmentation. Segmented\n    memory. Paged memory: concepts, internal fragmentation, page\n    tables. Demand paging/segmentation. Replacement strategies:\n    OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working\n    set schemes. [3\u00a0lectures]</li>\n<li><strong>I/O subsystem.</strong> General structure. Polled\n    mode <em>versus</em> interrupt-driven I/O. Application I/O\n    interface: block and character devices, buffering, blocking\n    <em>versus</em> non-blocking I/O. Other issues: caching,\n    scheduling, spooling, performance. [1\u00a0lecture]</li>\n<li><strong>File management.</strong> File concept. Directory\n    and storage services. File names and meta-data. Directory\n    name-space: hierarchies, DAGs, hard and soft links. File\n    operations. Access control. Existence and concurrency control.\n    [1\u00a0lecture]</li>\n<li><strong>Unix case study.</strong> History. General\n    structure. Unix file system: file abstraction, directories,\n    mount points, implementation details. Processes: memory image,\n    life cycle, start of day. The shell: basic operation, commands,\n    standard I/O, redirection, pipes, signals. Character and block\n    I/O. Process scheduling. [2\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should be able to</p>\n<ul>\n<li>describe the general structure and purpose of an operating\n    system;</li>\n<li>explain the concepts of process, address space, and\n    file;</li>\n<li>compare and contrast various CPU scheduling\n    algorithms;</li>\n<li>understand various mechanisms involved in memory\n    management, and be able to describe the advantages and\n    disadvantages of each;</li>\n<li>compare and contrast polled, interrupt-driven and DMA-based\n    access to I/O devices.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Bacon, J. and Harris, T. (2003). <em>Operating systems</em>.\n  Addison-Wesley (3rd ed.).<br/>\n  Silberschatz, A., Peterson, J.L. and Galvin, P.C. (2008).\n  <em>Operating systems concepts</em>. Wiley (8th ed.).<br/>\n  Anderson, T. and Dahlin, M. (2014). <em>Operating Systems:\n  Principles and Practice</em>. Recursive Books (2nd ed.).<br/>\n  Leffler, S. (1989). <em>The design and implementation of the\n  4.3BSD Unix operating system</em>. Addison-Wesley.<br/>\n  McKusick, M.K., Neville-Neil, G.N. and Watson, R.N.M. (2014)\n  <em>The Design and Implementation of the FreeBSD Operating\n  System</em>. Pearson Education. (2nd ed.).</p>\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/OpSystems", "lecturers": ["rmm1002"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "IntDesign": {"supervisions": 2, "prerequisite_for": ["FHCI"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-InteractionDesign.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  interaction design, with an emphasis on understanding and\n  experiencing the user interface design process from requirements\n  and data gathering to implementation and evaluation, while\n  gaining an understanding of the background to human factors. This\n  course focuses equally on design and implementation.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Course overview and requirements analysis.</strong>\n    Introduction to the course and the practicals. Identifying\n    potential users and understanding their tasks. Identifying and\n    establishing non-functional and functional requirements.</li>\n<li><strong>Data gathering.</strong> Data collection and\n    quantitative/qualitative analysis techniques.</li>\n<li><strong>Design and prototyping.</strong> Participatory\n    design process. Conceptual versus physical design. Concept\n    development. Prototyping and different kinds of prototypes.\n    Personas and storyboards.</li>\n<li><strong>Case studies from the industry.</strong> Guest\n    lecture (the schedule of this lecture is subject to\n    change).</li>\n<li><strong>Cognitive aspects.</strong> Attention,\n    perception/recognition, memory, context and grouping, and their\n    implications for interaction design. Cognitive frameworks.</li>\n<li><strong>Evaluation.</strong> Introduction, evaluation\n    techniques, and an evaluation case study.</li>\n<li><strong>Student (group) presentations</strong></li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should</p>\n<ul>\n<li>have a thorough understanding of the iterative design\n    process and be able to apply it to interaction design;</li>\n<li>be able to design new user interfaces that are informed by\n    principles of human visual perception and cognition;</li>\n<li>be able to construct user interfaces using Java with a\n    strong emphasis on users, usability and appearance;</li>\n<li>be able to evaluate existing or new user interfaces using\n    multiple techniques;</li>\n<li>be able to compare and contrast different design techniques\n    and to critique their applicability to new domains.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Preece, J., Rogers, Y. and Sharp, H. (2015). <em>Interaction\n  design</em>. Wiley (4th ed.).</p>\n", "course_name": "Interaction Design", "course_code": "IntDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/IntDesign", "lecturers": ["mcm79"], "lectures": 16, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "IntroProb": {"supervisions": 3, "prerequisite_for": ["CSM", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoProbability.html", "description": "<h2>Aims</h2>\n<p>This course provides an elementary introduction to probability\n  and statistics with applications. Probability theory and the\n  related field of statistical inference provide the foundations\n  for analysing and making sense of data. The focus of this course\n  is to introduce the language and core concepts of probability\n  theory. The course will also cover some applications of\n  statistical inference and algorithms in order to equip students\n  with the ability to represent problems using these concepts and\n  analyse the data within these principles.</p>\n<h2>Lectures</h2>\n<p>Part 1 - Introduction to Probability</p>\n<ul>\n<li><strong>Introduction.</strong> Counting/Combinatorics\n    (revision), Probability Space, Axioms, Union Bound.</li>\n<li><strong>Conditional probability.</strong> Conditional\n    Probabilities and Independence, Bayes\u2019Theorem, Partition\n    Theorem</li>\n</ul>\n<p>Part 2 - Discrete Random Variables</p>\n<ul>\n<li><strong>Random variables.</strong> Definition of a Random\n    Variable, Probability Mass Function, Cumulative Distribution,\n    Expectation.</li>\n<li><strong>Probability distributions.</strong> Definition and\n    Properties of Expectation, Variance, different ways of\n    computing them, Examples of important Distributions (Bernoulli,\n    Binomial, Geometric, Poisson), Primer on Continuous\n    Distributions including Normal and Exponential\n    Distributions.</li>\n<li><strong>Multivariate distributions.</strong> Multiple\n    Random Variables, Joint and Marginal Distributions,\n    Independence of Random Variables, Covariance.</li>\n</ul>\n<p>Part 3 - Moments and Limit Theorems</p>\n<ul>\n<li><strong>Introduction.</strong> Law of Average, Useful\n    inequalities (Markov and Chebyshef), Weak Law of Large Numbers\n    (including Proof using Chebyshef\u2019s inequality), Examples.</li>\n<li><strong>Moments and Central Limit Theorem.</strong>\n    Introduction to Moments of Random Variables, Central Limit\n    Theorem (Proof using Moment Generating functions),\n    Example.</li>\n</ul>\n<p>Part 4 - Applications/Statistics</p>\n<ul>\n<li><strong>Statistics.</strong> Classical Parameter Estimation\n    (Maximum-Likelihood-Estimation), bias, sample mean, sample\n    variance), Examples (Collision-Sampling, Estimating Population\n    Size).</li>\n<li><strong>Algorithms.</strong> Online Algorithms (Secretary\n    Problem, Odd\u2019s Algorithm).</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand the basic principles of probability spaces and\n    random variables</li>\n<li>be able to formulate problems using concepts from\n    probability theory and compute or estimate probabilities</li>\n<li>be familiar with more advanced concepts such as moments,\n    limit theorems and applications such as parameter\n    estimation</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Ross, S.M. (2014). <em>A First course in probability</em>.\n  Pearson (9th ed.).</p>\n<p>Bertsekas, D.P. and Tsitsiklis, J.N. (2008). <em>Introduction\n  to probability</em>. Athena Scientific.</p>\n<p>Grimmett, G. and Welsh, D. (2014). <em>Probability: an\n  Introduction</em>. Oxford University Press (2nd ed.).</p>\n<p>Dekking, F.M., et. al. (2005) <em>A modern introduction to\n  probability and statistics</em>. Springer.</p>\n", "course_name": "Introduction to Probability", "course_code": "IntroProb", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/IntroProb", "lecturers": ["mj201", "tms41"], "lectures": 12, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWSecEng": {"supervisions": 3, "prerequisite_for": ["Cybercrime", "Security"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandSecurityEngineering.html", "description": "<h2>Aims</h2>\n<p>This course aims to introduce students to software and\n  security engineering, and in particular to the problems of\n  building large systems, safety-critical systems and systems that\n  must withstand attack by capable opponents. Case histories of\n  failure are used to illustrate what can go wrong,\n  while\u00a0current software and security engineering practice is\n  studied as a guide to how failures can be avoided.</p>\n<h2>Lectures</h2>\n<p>\u00a0</p>\n<p><strong>1. What is a security policy or a safety case?\n  Definitions and examples;</strong> one-way flows for both\n  confidentiality and safety properties; separation of duties.\n  Top-down and bottom-up analysis methods. What architecture can\n  do, versus benefits of decoupling policy from mechanism.</p>\n<p><strong>2. Examples of safety and security policies.</strong>\n  Safety and security usability; the pyramid of harms. Predicting\n  and mitigating user errors. The prevention of fraud and error in\n  accounting systems; the safety usability of medical devices.</p>\n<p><strong>3. Attitudes to risk:</strong> expected\u00a0 utility,\n  prospect theory, framing, status quo bias. Authority, conformity\n  and gender; mental models, affordances and defaults. The\n  characteristics of human memory; forgetting passwords versus\n  guessing them.</p>\n<p><strong>4. Security protocols;</strong> how to enforce policy\n  using\u00a0 structured human interaction, cryptography or both.\n  Middleperson attacks.The role of verification and its\n  limitations.</p>\n<p><strong>5. Attacks on TLS, from rogue CAs through side\n  channels to Heartbleed.</strong> Other types of software bugs:\n  syntactic, timing, concurrency, code injection, buffer overflows.\n  Defensive\u00a0programming: secure coding, contracts.\n  Fuzzing.</p>\n<p><strong>6. The software crisis.</strong> Examples of\n  large-scale project failure, such as the London Ambulance Service\n  system and the NHS National Programme for IT. Intrinsic\n  difficulties with complex software.</p>\n<p><strong>7. Software engineering as the management of\n  complexity.\u00a0</strong>The software life cycle; requirements\n  analysis methods; modular design; the role of prototyping; the\n  waterfall, spiral and agile models.</p>\n<p><strong>8. The economics of software as a Service\n  (SaaS);</strong> the impact SaaS has on software engineering.\n  Continuous integration, release engineering, behavioural\n  analytics and experiment frameworks, rearchitecting systems while\n  in operation.</p>\n<p><strong>9. Critical systems:</strong> safety as an emergent\n  system property.\u00a0Examples of catastrophic failure: from\n  Therac-25 to the Boeing 737Max. The problems of managing\n  redundancy.\u00a0The overall process of safety engineering.</p>\n<p><strong>10. Managing the development of critical\n  systems:</strong> tools and methods, individual versus group\n  productivity, economics of testing and agile development,\n  measuring outcomes versus process, the technical and human\n  aspects of management, post-market surveillance and coordinated\n  disclosure. The sustainability of products with software\n  components.</p>\n<p>At the end of the course students should know how writing\n  programs with tough assurance targets, in large teams, or both,\n  differs from the programming exercises they have engaged in so\n  far. They should understand the different models of software\n  development described in the course as well as the value of\n  various development and management tools. They should understand\n  the development life cycle and its basic economics. They should\n  understand the various types of bugs, vulnerabilities and\n  hazards, how to find them, and how to avoid introducing them.\n  Finally, they should be prepared for the organizational aspects\n  of their Part\u00a0IB group project.</p>\n<h2>Recommended reading</h2>\n<p><br/>\n  Anderson, R. (Third Edition 2020). <em>Security engineering</em>\n  (Part 1 and Chapters 27-28). Wiley. Available at: <a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" id=\"tex2html5\" name=\"tex2html5\">http://www.cl.cam.ac.uk/users/rja14/book.html</a></p>\n", "course_name": "Software and Security Engineering", "course_code": "SWSecEng", "course_url": "https://www.cl.cam.ac.uk/teaching/2122/SWSecEng", "lecturers": ["rja14"], "lectures": 11, "year": "2122", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}