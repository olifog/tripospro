{"CompDesign": {"supervisions": 5, "prerequisite_for": ["CompArch"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerDesign.html", "description": "<h2>Aims</h2>\n<p>The aims of this course are to introduce a hardware\n  description language (SystemVerilog) and computer architecture\n  concepts in order to design computer systems. The parallel\n  ECAD+Arch practical classes will allow students to apply the\n  concepts taught in lectures.</p>\n<h2>Lectures</h2>\n<p>Part 1 - Gates to processors [lecturer: Professor Simon\n  Moore]</p>\n<ul>\n<li><strong>Technology trends and design challenges.</strong>\n    Current technology, technology trends, ECAD trends, challenges.\n    [1 lecture]</li>\n<li><strong>Digital system design.</strong> Practicalities of\n    mapping SystemVerilog descriptions of hardware (including a\n    processor) onto an FPGA board. Tips and pitfalls when\n    generating larger modular designs. [1 lecture]</li>\n<li><strong>Eight great ideas in computer\n    architecture.</strong> [1 lecture]</li>\n<li><strong>Reduced instruction set computers and\n    RISC-V.</strong> Introduction to the RISC-V processor design.\n    [1 lecture]</li>\n<li><strong>Executable and synthesisable models.</strong> [1\n    lecture]</li>\n<li><strong>Pipelining.</strong> [2 lectures]</li>\n<li><strong>Memory hierarchy and caching.</strong> Caching,\n    etc. [1 lecture]</li>\n<li><strong>Support for operating systems.</strong> Memory\n    protection, exceptions, interrupts, etc. [1 lecture]</li>\n<li><strong>Other instruction set architectures.</strong> CISC,\n    stack, accumulator. [1 lecture]</li>\n</ul>\n<p>Part 2 - Lecturer Dr Timothy Jones</p>\n<ul>\n<li><strong>Overview of Systems-on-Chip (SoCs) and\n    DRAM.</strong> [1 lecture] High-level SoCs, DRAM storage and\n    accessing.</li>\n<li><strong>Multicore Processors.</strong> [2 lectures]\n    Communication, cache coherence, barriers and synchronisation\n    primitives.</li>\n<li><strong>Graphics processing units (GPUs)</strong> [2\n    lectures] Basic GPU architecture and programming.</li>\n<li><strong>Future Directions</strong> [1 lecture] Where is\n    computer architecture heading?</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to read assembler given a guide to the instruction\n    set and be able to write short pieces of assembler if given an\n    instruction set or asked to invent an instruction set;</li>\n<li>understand the differences between RISC and CISC\n    assembler;</li>\n<li>understand what facilities a processor provides to support\n    operating systems, from memory management to software\n    interrupts;</li>\n<li>understand memory hierarchy including different cache\n    structures and coherency needed for multicore systems;</li>\n<li>understand how to implement a processor in\n    SystemVerilog;</li>\n<li>appreciate the use of pipelining in processor design;</li>\n<li>have an appreciation of control structures used in\n    processor design;</li>\n<li>have an appreciation of system-on-chips and their\n    components;</li>\n<li>understand how DRAM stores data;</li>\n<li>understand how multicore processors communicate;</li>\n<li>understand how GPUs work and have an appreciation of how to\n    program them.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Patterson, D.A. and Hennessy, J.L. (2017). <em>Computer\n  organization and design: The hardware/software interface RISC-V\n  edition</em>. Morgan Kaufmann. ISBN\u00a0978-0-12-812275-4.</p>\n<p>Recommended further reading:</p>\n<p>Harris, D.M. and Harris, S.L. (2012). <em>Digital design and\n  computer architecture</em>. Morgan Kaufmann.\n  ISBN\u00a0978-0-12-394424-5.<br/>\n  Hennessy, J. and Patterson, D. (2006). <em>Computer architecture:\n  a quantitative approach</em>. Elsevier (4th ed.).\n  ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also\n  still generally relevant.)</p>\n<p>Pointers to sources of more specialist information are\n  included in the lecture notes and on the associated course web\n  page.</p>\n", "course_name": "Computer Design", "course_code": "CompDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/CompDesign", "lecturers": ["swm11", "tmj32"], "lectures": 16, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ConcDisSys": {"supervisions": 4, "prerequisite_for": ["CloudComp", "L47", "MobSensSys"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html", "description": "<h2>Aims</h2>\n<p>This course considers two closely related topics, Concurrent\n  Systems and Distributed Systems, over 16 lectures. The aim of the\n  first half of the course is to introduce concurrency control\n  concepts and their implications for system design and\n  implementation. The aims of the latter half of the course are to\n  study the fundamental characteristics of distributed systems,\n  including their models and architectures; the implications for\n  software design; some of the techniques that have been used to\n  build them; and the resulting details of good distributed\n  algorithms and applications.</p>\n<h2>Lectures: Concurrency</h2>\n<ul>\n<li><strong>Introduction to concurrency, threads, and mutual\n    exclusion.</strong> Introduction to concurrent systems;\n    threads; interleaving; preemption; parallelism; execution\n    orderings; processes and threads; kernel vs. user threads; M:N\n    threads; atomicity; mutual exclusion; and mutual exclusion\n    locks (mutexes).</li>\n<li><strong>Automata Composition.</strong> Synchronous and\n    asynchronous parallelism; sequential consistency; rendezvous.\n    Safety, liveness and deadlock; the Dining Philosophers;\n    Hardware foundations for atomicity: test-and-set,\n    load-linked/store-conditional and fence instructions. Lamport\n    bakery algorithm.</li>\n<li><strong>Common design patterns: semaphores,\n    producer-consumer, and MRSW.</strong> Locks and invariants;\n    semaphores; condition synchronisation; N-resource allocation;\n    two-party and generalised producer-consumer; Multi-Reader,\n    Single-Write (MRSW) locks.</li>\n<li><strong>CCR, monitors, and concurrency in\n    practice.</strong> Conditional critical regions (CCR);\n    monitors; condition variables; signal-wait vs. signal-continue\n    semantics; concurrency in practice (kernels, pthreads,\n    Java).</li>\n<li><strong>Deadlock and liveness guarantees</strong> Offline\n    vs. online; model checking; resource allocation graphs; lock\n    order checking; deadlock prevention, avoidance, detection, and\n    recovery; livelock; priority inversion; priority\n    inheritance.</li>\n<li><strong>Concurrency without shared data;\n    transactions.</strong> Active objects; message passing; tuple\n    spaces; CSP; and actor models. Composite operations;\n    transactions; ACID; isolation; and serialisability.</li>\n<li><strong>Further transactions</strong> History graphs; good\n    and bad schedules; isolation vs. strict isolation; 2-phase\n    locking; rollback; timestamp ordering (TSO); and optimistic\n    concurrency control (OCC).</li>\n<li><strong>Crash recovery, lock-free programming, and\n    transactional memory.</strong> Write-ahead logging,\n    checkpoints, and recovery. Lock-free programming. Hardware and\n    software transactional memories.</li>\n</ul>\n<p>\u00a0</p>\n<h2>Lectures: Distributed Systems</h2>\n<ul>\n<li><strong>Introduction to distributed systems; RPC.</strong>\n    Avantages and challenges of distributed systems; unbounded\n    delay and partial failure; network protocols; transparency;\n    client-server systems; remote procedure call (RPC);\n    marshalling; interface definition languages (IDLs).</li>\n<li><strong>System models and\n    faults.</strong>\u00a0Synchronous, partially synchronous, and\n    asynchronous network models; crash-stop, crash-recovery, and\n    Byzantine faults; failures, faults, and fault tolerance; two\n    generals problem.</li>\n<li><strong>Time, clocks, and ordering of\n    events.</strong>\u00a0Physical clocks; UTC; clock\n    synchronisation, drift, and compensation; Network Time Protocol\n    (NTP). Logical time; happens-before relation; Lamport clocks;\n    vector clocks.</li>\n<li><strong>Replication.</strong> Fault tolerance;\n    leader-based, multi-leader, and leaderless replication; quorum\n    systems; replica consistency; linearizability; CAP theorem;\n    eventual consistency; session guarantees.</li>\n<li><strong>Middleware and protocols</strong>. Process groups;\n    FIFO, causal order, and total order broadcast; message-oriented\n    and object-oriented middleware; distributed mutual\n    exclusion.</li>\n<li><strong>Consensus and distributed transactions.</strong>\n    Leader elections; consensus; the FLP result; Paxos and Raft;\n    state machine replication; distributed transactions; atomic\n    commit protocols; 2-phase commit.</li>\n<li><strong>Case studies.</strong> Network File System (NFS);\n    Amazon\u2019s Dynamo; Google datacentre technologies (e.g.\n    MapReduce, Spanner); cloud computing services.</li>\n<li><strong>Advanced topics.</strong> Conflict-free Replicated\n    Data Types (CRDTs); Byzantine fault tolerance; peer-to-peer\n    systems; distributed systems security.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of Concurrent Systems portion of the course,\n  students should:</p>\n<ul>\n<li>understand the need for concurrency control in operating\n    systems and applications, both mutual exclusion and condition\n    synchronisation;</li>\n<li>understand how multi-threading can be supported and the\n    implications of different approaches;</li>\n<li>be familiar with the support offered by various programming\n    languages for concurrency control and be able to judge the\n    scope, performance implications and possible applications of\n    the various approaches;</li>\n<li>be aware that dynamic resource allocation can lead to\n    deadlock;</li>\n<li>understand the concept of transaction; the properties of\n    transactions, how they can be implemented, and how their\n    performance can be optimised based on optimistic\n    assumptions;</li>\n<li>understand how the persistence properties of transactions\n    are addressed through logging; and</li>\n<li>have a high-level understanding of the evolution of\n    software use of concurrency in the operating-system kernel case\n    study.</li>\n</ul>\n<p>At the end of the Distributed Systems portion of the course,\n  students should:</p>\n<ul>\n<li>understand the difference between shared-memory concurrency\n    and distributed systems;</li>\n<li>understand the fundamental properties of distributed\n    systems and their implications for system design;</li>\n<li>understand notions of time, including logical clocks,\n    vector clocks, and physical time synchronisation;</li>\n<li>be familiar with various approaches to data and service\n    replication, as well as the concept of data consistency;</li>\n<li>understand the effects of large scale on the provision of\n    fundamental services and the tradeoffs arising from scale;</li>\n<li>appreciate the implications of individual node and network\n    communications failures on distributed computation;</li>\n<li>be aware of a variety of programming models and\n    abstractions for distributed systems, such as RPC, middleware,\n    and total order broadcast;</li>\n<li>be familiar with a range of distributed algorithms, such as\n    consensus and two-phase commit;</li>\n<li>be familiar with a number of case studies in\n    distributed-system design including the Network File System\n    (NFS), the Network Time Protocol (NTP), Amazon's Dynamo, and\n    Google\u2019s MapReduce and Spanner systems.</li>\n</ul>\n<h2>Recommended reading</h2>\n<ul>\n<li>Bacon, J. and Harris, T. (2003). <em>Operating systems:\n    distributed and concurrent software design</em>.\n    Addison-Wesley.</li>\n<li>Bacon, J. (1997). <em>Concurrent systems</em>.\n    Addison-Wesley.</li>\n<li>Kleppmann, M. (2017). <em>Designing data-intensive\n    applications</em>. O\u2019Reilly.</li>\n<li>Tanenbaum, A.S. and van Steen, M.\n    (2017).\u00a0<em>Distributed systems,</em> 3rd\n    edition.\u00a0<a href=\"https://www.distributed-systems.net/index.php/books/ds3/\">available\n    online</a>.</li>\n<li>Cachin, C., Guerraoui, R. and Rodrigues, L.\n    (2011)\u00a0<em>Introduction to Reliable and Secure Distributed\n    Programming.</em> Springer (2nd edition).</li>\n</ul>\n", "course_name": "Concurrent and Distributed Systems", "course_code": "ConcDisSys", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys", "lecturers": ["djg11", "mk428"], "lectures": 16, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "DataSci": {"supervisions": 4, "prerequisite_for": ["CompSysMod", "L330", "DataSciII", "MLBayInfer", "NLP", "QuantComp"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DataScience.html", "description": "<h2>Aims</h2>\n<p>This course introduces fundamental tools for describing and\n  reasoning about data. There are two themes: describing the\n  behaviour of random systems; and making inferences based on data\n  generated by such systems. The course will survey a wide range of\n  models and tools, and it will emphasize how to design a model and\n  what sorts of questions one might ask about it.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Likelihood.</strong> Random variables. Random\n    samples. Maximum likelihood estimation, likelihood\n    profile.</li>\n<li><strong>Random variables.</strong> Rules for expectation\n    and variance. Generating random variables. Empirical\n    distribution. Monte Carlo estimation; law of large numbers.\n    Central limit theorem.</li>\n<li><strong>Inference.</strong> Estimation, confidence\n    intervals, hypothesis testing, prediction. Bootstrap.\n    Bayesianism. Logistic regression, natural parameters.</li>\n<li><strong>Feature spaces.</strong> Vector spaces, bases,\n    inner products, projection. Model fitting as projection. Linear\n    modeling. Choice of features.</li>\n<li><strong>Random processes.</strong> Markov chains.\n    Stationarity and convergence. Drift models. Examples, including\n    estimation and memory.</li>\n<li><strong>Probabilistic modelling.</strong> Independence;\n    joint distributions. Descriptive, discriminative, and causal\n    models. Latent variable models. Random fields.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to formulate basic probabilistic models, including\n    discrete time Markov chains and linear models</li>\n<li>be familiar with common random variables and their uses,\n    and with the use of empirical distributions rather than\n    formulae</li>\n<li>be able to use expectation and conditional expectation,\n    limit theorems, equilibrium distributions</li>\n<li>understand different types of inference about noisy data,\n    including model fitting, hypothesis testing, and making\n    predictions</li>\n<li>understand the fundamental properties of inner product\n    spaces and orthonormal systems, and their application to model\n    representation</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* F.M. Dekking, C. Kraaikamp, H.P. Lopuha\u00e4, L.E. Meester\n  (2005). <em>A modern introduction to probability and statistics:\n  understanding why and how.</em> Springer.</p>\n<p>S.M. Ross (2002). <em>Probability models for computer\n  science.</em> Harcourt / Academic Press.</p>\n<p>M. Mitzenmacher and E. Upfal (2005). <em>Probability and\n  computing: randomized algorithms and probabilistic analysis.</em>\n  Cambridge University Press.</p>\n", "course_name": "Data Science", "course_code": "DataSci", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/DataSci", "lecturers": ["djw1005"], "lectures": 16, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ECAD+Arch": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>The aims of this course are to enable students to apply the\n  concepts learned in the Computer Design course. In particular a\n  web based tutor is used to introduce the SystemVerilog hardware\n  description language, while the remaining practical classes will\n  then allow students to implement the design of components in this\n  language.</p>\n<h2>Practical Classes</h2>\n<ul>\n<li><strong>Web tutor</strong> The first class uses a web based\n    tutor to rapidly teach the SystemVerilog language.</li>\n<li><strong>FPGA design flow</strong> Test driven hardware\n    development for FPGA including an embedded processor and\n    peripherals [3\u00a0classes]</li>\n<li><strong>Embedded system implementation</strong> Embedded\n    system implementation on FPGA [3-4\u00a0classes]</li>\n</ul>\n<h2>Objectives</h2>\n<ul>\n<li>Gain experience in electronic computer aided design (ECAD)\n    through learning a design-flow for field programmable gate\n    arrays (FPGAs).</li>\n<li>Learn how to interface to peripherals like a touch\n    screen.</li>\n<li>Learn how to debug hardware and software systems in\n    simulation.</li>\n<li>Understand how to construct and program a heterogeneous\n    embedded system.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Harris, D.M. and Harris, S.L. (2007). <em>Digital design and\n  computer architecture: from gates to processors</em>. Morgan\n  Kaufmann.</p>\n<p>Pointers to sources of more specialist information are\n  included on the associated course web page.</p>\n", "course_name": "ECAD and Architecture Practical Classes", "course_code": "ECAD+Arch", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ECAD+Arch", "lecturers": ["atm26", "swm11", "rdm34"], "lectures": null, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "EconLaw": {"supervisions": 2, "prerequisite_for": ["Business", "Cybercrime", "ECommerce"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsLawandEthics.html", "description": "\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Aims</strong></span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\">This course aims to give\n  students an introduction to some basic concepts in economics, law\n  and ethics.</span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Lectures</strong></span></span></p>\n<ul>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Classical economics\n    and consumer theory.</strong> Prices and markets; Pareto\n    efficiency; preferences; utility; supply and demand; the\n    marginalist revolution; elasticity; the welfare theorems;\n    transaction costs.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Information\n    economics</strong>. The discriminating monopolist; marginal\n    costs; effects of technology on supply and demand; competition\n    and information; lock in; real and virtual networks; Metcalfe\u2019s\n    law; the dominant firm model; price discrimination; bundling;\n    income distribution.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Market failure and\n    behavioural economics.</strong> Market failure: the business\n    cycle; recession and technology; tragedy of the commons;\n    externalities; monopoly rents; asymmetric information: the\n    market for lemons; adverse selection; moral hazard; signalling.\n    Behavioural economics: bounded rationality, heuristics and\n    biases; nudge theory; the power of defaults; agency\n    effects.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Auction theory and\n    game theory.</strong> Auction theory: types of auctions;\n    strategic equivalence; the revenue equivalence theorem; the\n    winner\u2019s curse; problems with real auctions; mechanism design\n    and the combinatorial auction; applicability of auction\n    mechanisms in computer science; advertising auctions. Game\n    theory: the choice between cooperation and conflict; strategic\n    forms; dominant strategy equilibrium; Nash equilibrium; the\n    prisoners\u2019 dilemma; evolution of strategies; stag hunt;\n    volunteer\u2019s dilemma; chicken; iterated games; hawk-dove;\n    application to computer science.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Principles of\n    law.</strong> Criminal and civil law; contract law; choice of\n    law and jurisdiction; arbitration; tort; negligence;\n    defamation; intellectual property rights.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Law and the\n    Internet.</strong> Computer evidence; the General Data\n    Protection Regulation; UK laws that specifically affect the\n    Internet; e-commerce regulations; privacy and electronic\n    communications.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Philosophies of\n    ethics.</strong> Authority, intuitionist, egoist and\n    deontological theories; utilitarian and Rawlsian models;\n    morality; insights from evolutionary psychology, neurology, and\n    experimental ethics; professional codes of ethics; research\n    ethics.</span></span></li>\n<li><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Contemporary ethical\n    issues.</strong> The Internet and social policy; current\n    debates on privacy, surveillance, and censorship; responsible\n    vulnerability disclosure; algorithmic bias; predictive\n    policing; gamification and engagement; targeted political\n    advertising; environmental impacts.</span></span></li>\n</ul>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Objectives</strong></span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\">At the end of the course\n  students should have a basic appreciation of economic and legal\n  terminology and arguments. They should understand some of the\n  applications of economic models to systems engineering and their\n  interest to theoretical computer science. They should also\n  understand the main constraints that markets, legislation and\n  ethics place on firms dealing in information goods and\n  services.</span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\"><strong>Recommended\n  reading</strong></span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\">* Shapiro, C. &amp; Varian, H.\n  (1998). <em>Information rules</em>. Harvard Business School\n  Press.<br/>\n  Varian, H. (1999). <em>Intermediate microeconomics - a modern\n  approach</em>. Norton.</span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\">Further\n  reading:</span></span></p>\n<p><span style=\"font-size:11pt\"><span style=\"font-family:Calibri,sans-serif\">Smith, A. (1776). <em>An inquiry\n  into the nature and causes of the wealth of nations</em>,\n  available at\u00a0\u00a0\u00a0\u00a0<a href=\"http://www.econlib.org/library/Smith/smWN.html\" style=\"color:blue; text-decoration:underline\">http://www.econlib.org/library/Smith/smWN.html</a><br/>\n  Thaler, R.H. (2016). <em>Misbehaving</em>. Penguin.<br/>\n  Galbraith, J.K. (1991). <em>A history of economics</em>.\n  Penguin.<br/>\n  Poundstone, W. (1992). <em>Prisoner\u2019s dilemma</em>. Anchor\n  Books.<br/>\n  Pinker, S (2011). <em>The Better Angels of our Nature</em>.\n  Penguin.<br/>\n  Anderson, R. (2008). <em>Security engineering</em> (Chapter 7).\n  Wiley.<br/>\n  Nuffield Council on Bioethics (2015) <em>The collection, linking\n  and use of data in biomedical research and health\n  care</em>.</span></span></p>\n", "course_name": "Economics, Law and Ethics", "course_code": "EconLaw", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/EconLaw", "lecturers": ["ah793"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FGraphics": {"supervisions": 2, "prerequisite_for": ["AdvGraphIP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherGraphics.html", "description": "<h2>Aims</h2>\n<p>The course introduces fundamental concepts of modern graphics\n  pipelines.</p>\n<h2>Lectures</h2>\n<p>The order and content of lectures is provisional and subject\n  to change.</p>\n<ul>\n<li>Geometry Representations. Parametric surfaces, implicit\n    surfaces, meshes, point-set surfaces, geometry processing\n    pipeline. [1 lecture]</li>\n<li>Discrete Differential Geometry. Surface normal and\n    curvature, Laplace-Beltrami operator, heat diffusion. [1\n    lecture]</li>\n<li>Geometry Processing.\u00a0 Parametrization, filtering, 3D\n    capture. [1 lecture]</li>\n<li>Animation I. Animation types, animation pipeline,\n    rigging/skinning, character animation. [1 lecture]</li>\n<li>Animation II. Blending transformations, pose-space\n    animation, controllers. [1 lecture]</li>\n<li>The Rendering Equation. Radiosity, reflection models,\n    BRDFs, local vs. global illumination. [1 lecture]</li>\n<li>Distributed Ray Tracing. Quadrature, importance sampling,\n    recursive ray tracing. [1 lecture]</li>\n<li>Inverse Rendering. Differentiable rendering, inverse\n    problems. [1 lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>On completing the course, students should be able to</p>\n<ul>\n<li>understand and use fundamental 3D geometry/scene\n    representations and operations;</li>\n<li>learn animation techniques and controls;</li>\n<li>learn how light transport is modeled and simulated in\n    rendering;</li>\n<li>understand how graphics and rendering can be used to solve\n    computer perception problems.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Students should expect to refer to one or more of these books,\n  but should not find it necessary to purchase any of them.</p>\n<ul>\n<li>Shirley, P. and Marschner, S. (2009). Fundamentals of\n    Computer Graphics. CRC Press (3rd ed.).</li>\n<li>Watt, A. (2000). 3D Computer Graphics. Addison-Wesley (3rd\n    ed).</li>\n<li>Hughes, van Dam, McGuire, Skalar, Foley, Feiner and Akeley\n    (2013). Computer Graphics: Principles and Practice.\n    Addison-Wesley (3rd edition)</li>\n<li>Akenine-M\u00f6ller, et. al. (2018). Real-time rendering. CRC\n    Press (4th ed.).</li>\n</ul>\n", "course_name": "Further Graphics", "course_code": "FGraphics", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/FGraphics", "lecturers": [], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FJava": {"supervisions": 2, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherJava.html", "description": "<h2>Aims</h2>\n<p>The goal of this course is to provide students with the\n  ability to understand the advanced programming features available\n  in the Java programming language, completing the coverage of the\n  language started in the Programming in Java course. The course is\n  designed to accommodate students with diverse programming\n  backgrounds; consequently Java is taught from first principles in\n  a practical class setting where students can work at their own\n  pace from a course handbook. Each practical class will culminate\n  in an assessed exercise.</p>\n<h2>Practical classes</h2>\n<ul>\n<li><strong>Communication and client applications.</strong>\n    This class will introduce an integrated development\n    environment. Students will write a simple client to send and\n    receive data to a server via TCP.</li>\n<li><strong>Serialisation, reflection and class\n    loaders.</strong> This class will introduce object\n    serialisation. Students will use a class loader and reflection\n    to inspect an object which is only available at run-time.</li>\n<li><strong>Concurrency and synchronisation.</strong> This\n    class introduces the concurrency and synchronisation primitives\n    found in Java. Students will implement a thread-safe\n    first-in-first-out queue and learn about Java generics.</li>\n<li><strong>Server applications</strong>. Students implement a\n    server in Java which is capable of communicating concurrently\n    with mulitple clients.</li>\n<li><strong>Vector clocks</strong>. This week students will use\n    the concept of vector clocks to make their client and server\n    robust to message delays and reordering.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand different mechanisms for communication between\n    distributed applications and be able to evaluate their\n    trade-offs;</li>\n<li>be able to use Java generics and annotations to improve\n    software usability, readability and safety;</li>\n<li>understand and be able to exploit the Java class-loading\n    mechansim;</li>\n<li>understand and be able to use concurrency control\n    correctly;</li>\n<li>be able to implement a vector clock algorithm and the\n    happens-before relation.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Goetz, B. (2006). <em>Java concurrency in practice</em>.\n  Addison-Wesley.<br/>\n  Gosling, J., Joy, B., Steele, G., Bracha, G. and Buckley, A.\n  (2014). <em>The Java language specification, Java SE 8\n  Edition</em>. Addison-Wesley.<br/>\n<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/\" id=\"tex2html11\" name=\"tex2html11\">http://docs.oracle.com/javase/specs/jls/se8/html/</a></p>\n", "course_name": "Further Java", "course_code": "FJava", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/FJava", "lecturers": ["arb33", "acr31"], "lectures": 10, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "GroupProj": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Group Project", "course_code": "GroupProj", "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/", "lecturers": ["afb21", "rkh23"], "lectures": null, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "ProgC": {"supervisions": 3, "prerequisite_for": ["AdvGraphIP", "Security"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html", "description": "<h2>Aims</h2>\n<p>The aims of this course are to provide a solid introduction to\n  programming in C and to provide an overview of the principles and\n  constraints that affect the way in which the C programming\n  language has been designed and is used, including the differences\n  betweeen it and C++.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to the C language.</strong> Background\n    and goals of C. Types and variables. Expressions and\n    statements. Functions. Multiple compilation units. Tooling for\n    C programming. [2 lectures]</li>\n<li><strong>Further C concepts.</strong> Preprocessor. Pointers\n    and pointer arithmetic. Data structures. Dynamic memory\n    management. Examples. [2 lectures]</li>\n<li><strong>Memory Management</strong> Unique ownership. Object\n    graphs and graph traversals. Aliasing and deallocation. Mark\n    and sweep algorithms. Reference counting. Arenas. Stack\n    allocation. Handles and compaction. [3 lectures]</li>\n<li><strong>Memory Hierarchy and Cache Optimization</strong>\n    Cache hierarchy. Data structure layouts. Intrusive lists.\n    Array-of-structs vs struct-of-array representations. [1\n    lecture]</li>\n<li><strong>Linkers, loaders and debugging.</strong> Executable\n    sections. Debug symbols. Inspecting program state. [1\n    lecture]</li>\n<li><strong>C semantics.</strong> Undefined vs\n    implementation-defined behaviour. Common optimisation problems.\n    Buffer and integer overflows. Examples. [1 lecture]</li>\n<li><strong>Introduction to C++.</strong> Goals of C++.\n    Differences between C and C++. References versus pointers.\n    Overloading functions. [1 lecture]</li>\n<li><strong>Objects in C++</strong> Classes and structs.\n    Exceptions. Destructors. Operator overloading. Virtual\n    functions. Casting. Multiple inheritance. Virtual base classes.\n    Templates and meta-programming. [1 lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to read and write C programs;</li>\n<li>understand the interaction between C programs and the host\n    operating system;</li>\n<li>be familiar with the structure of C program execution in\n    machine memory;</li>\n<li>understand the potential dangers of writing programs in\n    C;</li>\n<li>understand the main differences between C and C++.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Kernighan, B.W. and Ritchie, D.M. (1988). <em>The C\n  programming language</em>. Prentice\u00a0Hall (2nd ed.).</p>\n", "course_name": "Programming in C and C++", "course_code": "ProgC", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ProgC", "lecturers": ["djg11", "am21"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Semantics": {"supervisions": 3, "prerequisite_for": ["CatTheory", "HLog+ModC", "Multicore", "Types"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SemanticsofProgrammingLanguages.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce the structural,\n  operational approach to programming language semantics. It will\n  show how to specify the meaning of typical programming language\n  constructs, in the context of language design, and how to reason\n  formally about semantic properties of programs.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Transition systems. The idea\n    of structural operational semantics. Transition semantics of a\n    simple imperative language. Language design options. [2\n    lectures]</li>\n<li><strong>Types.</strong> Introduction to formal type\n    systems. Typing for the simple imperative language. Statements\n    of desirable properties. [2 lectures]</li>\n<li><strong>Induction.</strong> Review of mathematical\n    induction. Abstract syntax trees and structural induction.\n    Rule-based inductive definitions and proofs. Proofs of type\n    safety properties. [2 lectures]</li>\n<li><strong>Functions.</strong> Call-by-name and call-by-value\n    function application, semantics and typing. Local recursive\n    definitions. [2 lectures]</li>\n<li><strong>Data.</strong> Semantics and typing for products,\n    sums, records, references. [1 lecture]</li>\n<li><strong>Subtyping.</strong> Record subtyping and simple\n    object encoding. [1 lecture]</li>\n<li><strong>Semantic equivalence.</strong> Semantic equivalence\n    of phrases in a simple imperative language, including the\n    congruence property. Examples of equivalence and\n    non-equivalence. [1 lecture]</li>\n<li><strong>Concurrency.</strong> Shared variable interleaving.\n    Semantics for simple mutexes; a serializability property. [1\n    lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with rule-based presentations of the\n    operational semantics and type systems for some simple\n    imperative, functional and interactive program constructs;</li>\n<li>be able to prove properties of an operational semantics\n    using various forms of induction (mathematical, structural, and\n    rule-based);</li>\n<li>be familiar with some operationally-based notions of\n    semantic equivalence of program phrases and their basic\n    properties.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Pierce, B.C. (2002). <em>Types and programming\n  languages</em>. MIT Press.<br/>\n  Hennessy, M. (1990). <em>The semantics of programming\n  languages</em>. Wiley. Out of print, but available on the web at\n  <a href=\"http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf\" id=\"tex2html12\" name=\"tex2html12\">http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf</a><br/>\n  Winskel, G. (1993). <em>The formal semantics of programming\n  languages</em>. MIT Press.</p>\n", "course_name": "Semantics of Programming Languages", "course_code": "Semantics", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/Semantics", "lecturers": ["nk480"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "UnixTools": {"supervisions": 0, "prerequisite_for": ["CloudComp", "Security"], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>This video-lecture course gives students who have already\n  basic Unix/Linux experience some additional practical\n  software-engineering knowledge: how to use the shell and related\n  tools as an efficient working environment, how to automate\n  routine tasks, and how version-control and automated-build tools\n  can help to avoid confusion and accidents, especially when\n  working in teams. These are essential skills, both in industrial\n  software development and student projects.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Unix concepts.</strong> Brief review of Unix\n    history and design philosophy, documentation, terminals,\n    inter-process communication mechanisms and conventions, shell,\n    command-line arguments, environment variables, file\n    descriptors.</li>\n<li><strong>Shell concepts.</strong> Program invocation,\n    redirection, pipes, file-system navigation, argument expansion,\n    quoting, job control, signals, process groups, variables,\n    locale, history and alias functions, security\n    considerations.</li>\n<li><strong>Scripting.</strong> Plain-text formats,\n    executables, #!, shell control structures and functions.\n    Startup scripts.</li>\n<li><strong>Text, file and networking tools.</strong> sed,\n    grep, chmod, find, ssh, rsync, tar, zip, etc.</li>\n<li><strong>Version control.</strong> diff, patch, RCS,\n    Subversion, git.</li>\n<li><strong>Software development tools.</strong> C compiler,\n    linker, debugger, make.</li>\n<li><strong>Perl.</strong> Introduction to a powerful scripting\n    and text-manipulation language. [2\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be confident in performing routine user tasks on a POSIX\n    system, understand command-line user-interface conventions and\n    know how to find more detailed documentation;</li>\n<li>appreciate how simple tools can be combined to perform a\n    large variety of tasks;</li>\n<li>be familiar with the most common tools, file formats and\n    configuration practices;</li>\n<li>be able to understand, write, and maintain shell scripts\n    and makefiles;</li>\n<li>appreciate how using a version-control system and fully\n    automated build processes help to maintain reproducibility and\n    audit trails during software development;</li>\n<li>know enough about basic development tools to be able to\n    install, modify and debug C source code;</li>\n<li>have understood the main concepts of, and gained initial\n    experience in, writing Perl scripts (excluding the facilities\n    for object-oriented programming).</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Robbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th\n  ed.).<br/>\n  Schwartz, R.L., Foy, B.D. and Phoenix, T. (2011). <em>Learning\n  Perl</em>. O\u2019Reilly (6th ed.).</p>\n", "course_name": "Unix Tools", "course_code": "UnixTools", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/UnixTools", "lecturers": ["mgk25"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompConstr": {"supervisions": 4, "prerequisite_for": ["ForModLang", "OptComp"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html", "description": "<h2>Aims</h2>\n<p>This course aims to cover the main concepts associated with\n  implementing compilers for programming languages. We use a\n  running example called SLANG (a Small LANGuage) inspired by the\n  languages described in 1B Semantics. A toy compiler (written in\n  ML) is provided, and students are encouraged to extend it in\n  various ways.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Overview of compiler structure</strong> The\n    spectrum of interpreters and compilers; compile-time and\n    run-time. Compilation as a sequence of translations from\n    <em>higher-level</em> to <em>lower-level</em> intermediate\n    languages, where each translation preserves semantics. The\n    structure of a simple compiler: lexical analysis and syntax\n    analysis, type checking, intermediate representations,\n    optimisations, code generation. Overview of run-time data\n    structures: stack and heap. Virtual machines.\n    [1\u00a0lecture]</li>\n<li><strong>Lexical analysis and syntax analysis.</strong>\n    Lexical analysis based on regular expressions and finite state\n    automata. Using LEX-tools. How does LEX work? Parsing based on\n    context-free grammars and push-down automata. Grammar\n    ambiguity, left- and right-associativity and operator\n    precedence. Using YACC-like tools. How does YACC work? LL(k)\n    and LR(k) parsing theory. [3\u00a0lectures]</li>\n<li><strong>Compiler Correctness</strong> Recursive functions\n    can be transformed into iterative functions using the\n    Continuation-Passing Style (CPS) transformation. CPS applied to\n    a (recursive) SLANG interpreter to derive, in a step-by-step\n    manner, a correct stack-based compiler. [3\u00a0lectures]</li>\n<li><strong>Data structures, procedures/functions</strong>\n    Representing tuples, arrays, references. Procedures and\n    functions: calling conventions, nested structure, non-local\n    variables. Functions as <em>first-class</em> values represented\n    as <em>closures</em>. Simple optimisations: inline expansion,\n    constant folding, elimination of tail recursion, peephole\n    optimisation. [5\u00a0lectures]</li>\n<li><strong>Advanced topics</strong> Run-time memory management\n    (garbage collection). Static and dynamic linking. Objects and\n    inheritance; implementation of method dispatch. Try-catch\n    exception mechanisms. Compiling a compiler via bootstrapping.\n    [4\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should understand the\n  overall structure of a compiler, and will know significant\n  details of a number of important techniques commonly used. They\n  will be aware of the way in which language features raise\n  challenges for compiler builders.</p>\n<h2>Recommended reading</h2>\n<p>* Aho, A.V., Sethi, R. and Ullman, J.D. (2007). <em>Compilers:\n  principles, techniques and tools</em>. Addison-Wesley (2nd\n  ed.).<br/>\n  Mogensen, T. \u00c6. (2011). <em>Introduction to compiler design</em>.\n  Springer. <a href=\"http://www.diku.dk/~torbenm/Basics\" id=\"tex2html13\" name=\"tex2html13\">http://www.diku.dk/\u00a0torbenm/Basics</a>.</p>\n", "course_name": "Compiler Construction", "course_code": "CompConstr", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/CompConstr", "lecturers": ["tgg22"], "lectures": 16, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompTheory": {"supervisions": 3, "prerequisite_for": ["Complexity", "QuantComp", "Types"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce several apparently\n  different formalisations of the informal notion of algorithm; to\n  show that they are equivalent; and to use them to demonstrate\n  that there are uncomputable functions and algorithmically\n  undecidable problems.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction: algorithmically undecidable\n    problems.</strong> Decision problems. The informal notion of\n    algorithm, or effective procedure. Examples of algorithmically\n    undecidable problems. [1 lecture]</li>\n<li><strong>Register machines.</strong> Definition and\n    examples; graphical notation. Register machine computable\n    functions. Doing arithmetic with register machines. [1\n    lecture]</li>\n<li><strong>Universal register machine.</strong> Natural number\n    encoding of pairs and lists. Coding register machine programs\n    as numbers. Specification and implementation of a universal\n    register machine. [2\u00a0lectures]</li>\n<li><strong>Undecidability of the halting problem.</strong>\n    Statement and proof. Example of an uncomputable partial\n    function. Decidable sets of numbers; examples of undecidable\n    sets of numbers. [1 lecture]</li>\n<li><strong>Turing machines.</strong> Informal description.\n    Definition and examples. Turing computable functions.\n    Equivalence of register machine computability and Turing\n    computability. The Church-Turing Thesis. [2\u00a0lectures]</li>\n<li><strong>Primitive and partial recursive functions.</strong>\n    Definition and examples. Existence of a recursive, but not\n    primitive recursive function. A partial function is partial\n    recursive if and only if it is computable.\n    [2\u00a0lectures]</li>\n<li><strong>Lambda-Calculus.</strong> Alpha and beta\n    conversion. Normalization. Encoding data. Writing recursive\n    functions in the lambda-calculus. The relationship between\n    computable functions and lambda-definable functions.\n    [3\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with the register machine, Turing machine and\n    lambda-calculus models of computability;</li>\n<li>understand the notion of coding programs as data, and of a\n    universal machine;</li>\n<li>be able to use diagonalisation to prove the undecidability\n    of the Halting Problem;</li>\n<li>understand the mathematical notion of partial recursive\n    function and its relationship to computability.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Hopcroft, J.E., Motwani, R. and Ullman, J.D. (2001).\n  <em>Introduction to automata theory, languages, and\n  computation</em>. Addison-Wesley (2nd ed.).<br/>\n  * Hindley, J.R. and Seldin, J.P. (2008). <em>Lambda-calculus and\n  combinators, an introduction</em>. Cambridge University Press\n  (2nd ed.).<br/>\n  Cutland, N.J. (1980). <em>Computability: an introduction to\n  recursive function theory</em>. Cambridge University Press.<br/>\n  Davis, M.D., Sigal, R. and Weyuker, E.J. (1994).\n  <em>Computability, complexity and languages</em>. Academic Press\n  (2nd ed.).<br/>\n  Sudkamp, T.A. (2005). <em>Languages and machines</em>.\n  Addison-Wesley (3rd ed.).</p>\n", "course_name": "Computation Theory", "course_code": "CompTheory", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/CompTheory", "lecturers": ["amp12"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompNet": {"supervisions": 5, "prerequisite_for": ["CloudComp", "L47", "PrincComm", "Security"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce key concepts and\n  principles of computer networks. The course will use a top-down\n  approach to study the Internet and its protocol stack. Instances\n  of architecture, protocol, application-examples will include\n  email, web and media-streaming. We will cover communications\n  services (e.g., TCP/IP) required to support such network\n  applications. The implementation and deployment of communications\n  services in practical networks: including wired and wireless LAN\n  environments, will be followed by a discussion of issues of\n  network-management. Throughout the course, the Internet\u2019s\n  architecture and protocols will be used as the primary examples\n  to illustrate the fundamental principles of computer\n  networking.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Overview of networking using\n    the Internet as an example. LANs and WANs. OSI reference model,\n    Internet TCP/IP Protocol Stack. Circuit-switching,\n    packet-switching, Internet structure, networking delays and\n    packet loss. [3\u00a0lectures]</li>\n<li><strong>Link layer and local area networks.</strong> Link\n    layer services, error detection and correction, Multiple Access\n    Protocols, link layer addressing, Ethernet, hubs and switches,\n    Point-to-Point Protocol. [2\u00a0lectures]</li>\n<li><strong>Wireless and mobile networks.</strong> Wireless\n    links and network characteristics, Wi-Fi: IEEE 802.11 wireless\n    LANs. [1\u00a0lecture]</li>\n<li><strong>Network layer addressing.</strong> Network layer\n    services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\n    [3\u00a0lectures]</li>\n<li><strong>Network layer routing.</strong> Routing and\n    forwarding, routing algorithms, routing in the Internet,\n    multicast. [3\u00a0lectures]</li>\n<li><strong>Transport layer.</strong> Service models,\n    multiplexing/demultiplexing, connection-less transport (UDP),\n    principles of reliable data transfer, connection-oriented\n    transport (TCP), TCP congestion control, TCP variants.\n    [6\u00a0lectures]</li>\n<li><strong>Application layer.</strong> Client/server paradigm,\n    WWW, HTTP, Domain Name System, P2P. [1.5\u00a0lectures]</li>\n<li><strong>Multimedia networking.</strong> Networked\n    multimedia applications, multimedia delivery requirements,\n    multimedia protocols (SIP), content distribution networks.\n    [0.5\u00a0lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to analyse a communication system by separating out\n    the different functions provided by the network;</li>\n<li>understand that there are fundamental limits to any\n    communications system;</li>\n<li>understand the general principles behind multiplexing,\n    addressing, routing, reliable transmission and other stateful\n    protocols as well as specific examples of each;</li>\n<li>understand what FEC is;</li>\n<li>be able to compare communications systems in how they solve\n    similar problems;</li>\n<li>have an informed view of both the internal workings of the\n    Internet and of a number of common Internet applications and\n    protocols.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Peterson, L.L. and Davie, B.S. (2011). <em>Computer\n  networks: a systems approach</em>. Morgan Kaufmann (5th ed.).\n  ISBN 9780123850591<br/>\n  Kurose, J.F. and Ross, K.W. (2009). <em>Computer networking: a\n  top-down approach</em>. Addison-Wesley (5th ed.).<br/>\n  Comer, D. and Stevens, D. (2005). <em>Internetworking with\n  TCP-IP, vol.</em> 1 <em>and</em> 2. Prentice\u00a0Hall (5th\n  ed.).<br/>\n  Stevens, W.R., Fenner, B. and Rudoff, A.M. (2003). <em>UNIX\n  network programming, Vol.I: The sockets networking API</em>.\n  Prentice\u00a0Hall (3rd ed.).</p>\n", "course_name": "Computer Networking", "course_code": "CompNet", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/CompNet", "lecturers": ["awm22"], "lectures": 20, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "FHCI": {"supervisions": 2, "prerequisite_for": ["InteractML"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherHuman-ComputerInteraction.html", "description": "<h2>Aims</h2>\n<p>This aim of this course is to provide an introduction to the\n  theoretical foundations of Human Computer Interaction, and an\n  understanding of how these can be applied to the design of\n  complex technologies.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Theory driven approaches to HCI.</strong> What is a\n    theory in HCI? Why take a theory driven approach to HCI?</li>\n<li><strong>Design of visual displays.</strong> Segmentation\n    and variables of the display plane. Modes of\n    correspondence.</li>\n<li><strong>Goal-oriented interaction.</strong> Using cognitive\n    theories of planning, learning and understanding to understand\n    user behaviour, and what they find hard.</li>\n<li><strong>Designing smart systems.</strong> Using statistical\n    methods to anticipate user needs and actions with Bayesian\n    strategies.</li>\n<li><strong>Designing efficient systems.</strong> Measuring and\n    optimising human performance through quantitative experimental\n    methods.</li>\n<li><strong>Designing meaningful systems.</strong> Qualitative\n    research methods to understand social context and requirements\n    of user experience.</li>\n<li><strong>Evaluating interactive system designs.</strong>\n    Approaches to evaluation in systems research and engineering,\n    including Part II Projects.</li>\n<li><strong>Designing complex systems.</strong> Worked case\n    studies of applying the theories to a hard HCI problem.\n    Research directions in HCI.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should be able to apply\n  theories of human performance and cognition to system design,\n  including selection of appropriate techniques to analyse, observe\n  and improve the usability of a wide range of technologies.</p>\n<h2>Recommended reading</h2>\n<p>* Preece, J., Sharp, H. and Rogers, Y. (2015). <em>Interaction\n  design: beyond human-computer interaction</em>. Wiley (Currently\n  in 4th edition, but earlier editions will suffice).</p>\n<p>Further reading:</p>\n<p>Carroll, J.M. (ed.) (2003). <em>HCI models, theories and\n  frameworks: toward a multi-disciplinary science</em>. Morgan\n  Kaufmann.</p>\n", "course_name": "Further Human\u2013Computer Interaction", "course_code": "FHCI", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/FHCI", "lecturers": ["afb21"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "LogicProof": {"supervisions": 3, "prerequisite_for": ["HLog+ModC"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html", "description": "<h2>Aims</h2>\n<p>This course will teach logic, especially the predicate\n  calculus. It will present the basic principles and definitions,\n  then describe a variety of different formalisms and algorithms\n  that can be used to solve problems in logic. Putting logic into\n  the context of Computer Science, the course will show how the\n  programming language Prolog arises from the automatic proof\n  method known as resolution. It will introduce topics that are\n  important in mechanical verification, such as binary decision\n  diagrams (BDDs), SAT solvers and modal logic.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to logic.</strong> Schematic\n    statements. Interpretations and validity. Logical consequence.\n    Inference.</li>\n<li><strong>Propositional logic.</strong> Basic syntax and\n    semantics. Equivalences. Normal forms. Tautology checking using\n    CNF.</li>\n<li><strong>The sequent calculus.</strong> A simple\n    (Hilbert-style) proof system. Natural deduction systems.\n    Sequent calculus rules. Sample proofs.</li>\n<li><strong>First order logic.</strong> Basic syntax.\n    Quantifiers. Semantics (truth definition).</li>\n<li><strong>Formal reasoning in FOL.</strong> Free\n    <em>versus</em> bound variables. Substitution. Equivalences for\n    quantifiers. Sequent calculus rules. Examples.</li>\n<li><strong>Clausal proof methods.</strong> Clause form. A\n    SAT-solving procedure. The resolution rule. Examples.\n    Refinements.</li>\n<li><strong>Skolem functions, Unification and Herbrand\u2019s\n    theorem.</strong> Prenex normal form. Skolemisation. Most\n    general unifiers. A unification algorithm. Herbrand models and\n    their properties.</li>\n<li><strong>Resolution theorem-proving and Prolog.</strong>\n    Binary resolution. Factorisation. Example of Prolog execution.\n    Proof by model elimination.</li>\n<li><strong>Satisfiability Modulo Theories.</strong> Decision\n    problems and procedures. How SMT solvers work.</li>\n<li><strong>Binary decision diagrams.</strong> General\n    concepts. Fast canonical form algorithm. Optimisations.\n    Applications.</li>\n<li><strong>Modal logics.</strong> Possible worlds semantics.\n    Truth and validity. A Hilbert-style proof system. Sequent\n    calculus rules.</li>\n<li><strong>Tableaux methods.</strong> Simplifying the sequent\n    calculus. Examples. Adding unification. Skolemisation. The\n    world\u2019s smallest theorem prover?</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to manipulate logical formulas accurately;</li>\n<li>be able to perform proofs using the presented formal\n    calculi;</li>\n<li>be able to construct a small BDD;</li>\n<li>understand the relationships among the various calculi,\n    e.g. SAT solving, resolution and Prolog;</li>\n<li>understand the concept of a decision procedure and the\n    basic principles of \u201csatisfiability modulo theories\u201d.</li>\n<li>be able to apply the unification algorithm and to describe\n    its uses.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Huth, M. and Ryan, M. (2004). <em>Logic in computer science:\n  modelling and reasoning about systems</em>. Cambridge University\n  Press (2nd ed.).<br/>\n  Ben-Ari, M. (2001). <em>Mathematical logic for computer\n  science</em>. Springer (2nd ed.).</p>\n", "course_name": "Logic and Proof", "course_code": "LogicProof", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/LogicProof", "lecturers": ["lp15"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "Prolog": {"supervisions": 2, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Prolog.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce programming in the\n  Prolog language. Prolog encourages a different programming style\n  to Java or ML and particular focus is placed on programming to\n  solve real problems that are suited to this style. Practical\n  experimentation with the language is strongly encouraged.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to Prolog.</strong> The structure of a\n    Prolog program and how to use the Prolog interpreter.\n    Unification. Some simple programs.</li>\n<li><strong>Arithmetic and lists.</strong> Prolog\u2019s support for\n    evaluating arithmetic expressions and lists. The space\n    complexity of program evaluation discussed with reference to\n    last-call optimisation.</li>\n<li><strong>Backtracking, cut, and negation.</strong> The cut\n    operator for controlling backtracking. Negation as failure and\n    its uses.</li>\n<li><strong>Search and cut.</strong> Prolog\u2019s search method for\n    solving problems. Graph searching exploiting Prolog\u2019s built-in\n    search mechanisms.</li>\n<li><strong>Difference structures.</strong> Difference lists:\n    introduction and application to example programs.</li>\n<li><strong>Building on Prolog.</strong> How particular\n    limitations of Prolog programs can be addressed by techniques\n    such as Constraint Logic Programming (CLP) and tabled\n    resolution.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to write programs in Prolog using techniques such\n    as accumulators and difference structures;</li>\n<li>know how to model the backtracking behaviour of program\n    execution;</li>\n<li>appreciate the unique perspective Prolog gives to problem\n    solving and algorithm design;</li>\n<li>understand how larger programs can be created using the\n    basic programming techniques used in this course.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Bratko, I. (2001). <em>PROLOG programming for artificial\n  intelligence</em>. Addison-Wesley (3rd or 4th\u00a0ed.).<br/>\n  Sterling, L. and Shapiro, E. (1994). <em>The art of Prolog</em>.\n  MIT Press (2nd\u00a0ed.).</p>\n<p>Further reading:</p>\n<p>O\u2019Keefe, R. (1990). <em>The craft of Prolog</em>. MIT Press.\n  [This book is beyond the scope of this course, but it is very\n  instructive. If you understand its contents, you\u2019re more than\n  prepared for the examination.]</p>\n", "course_name": "Prolog", "course_code": "Prolog", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/Prolog", "lecturers": ["acr31", "ijl20"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "ArtInt": {"supervisions": 3, "prerequisite_for": ["NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligence.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to some\n  fundamental issues and algorithms in artificial intelligence\n  (AI). The course approaches AI from an algorithmic, computer\n  science-centric perspective; relatively little reference is made\n  to the complementary perspectives developed within psychology,\n  neuroscience or elsewhere. The course aims to provide some\n  fundamental tools and algorithms required to produce AI systems\n  able to exhibit limited human-like abilities, particularly in the\n  form of problem solving by search, game-playing, representing and\n  reasoning with knowledge, planning, and learning.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Alternate ways of thinking\n    about AI. Agents as a unifying view of AI systems.\n    [1\u00a0lecture]</li>\n<li><strong>Search I.</strong> Search as a fundamental paradigm\n    for intelligent problem-solving. Simple, uninformed search\n    algorithms. Tree search and graph search. [1\u00a0lecture]</li>\n<li><strong>Search II.</strong> More sophisticated heuristic\n    search algorithms. The A* algorithm and its properties.\n    Improving memory efficiency: the IDA* and recursive best first\n    search algorithms. Local search and gradient descent.\n    [1\u00a0lecture]</li>\n<li><strong>Game-playing.</strong> Search in an adversarial\n    environment. The minimax algorithm and its shortcomings.\n    Improving minimax using alpha-beta pruning.\n    [1\u00a0lecture]</li>\n<li><strong>Constraint satisfaction problems (CSPs).</strong>\n    Standardising search problems to a common format. The\n    backtracking algorithm for CSPs. Heuristics for improving the\n    search for a solution. Forward checking, constraint propagation\n    and arc consistency. [1\u00a0lecture]</li>\n<li><strong>Backjumping in CSPs.</strong> Backtracking,\n    backjumping using Gaschnig\u2019s algorithm, graph-based\n    backjumping. [1\u00a0lecture]</li>\n<li><strong>Knowledge representation and reasoning I.</strong>\n    How can we represent and deal with commonsense knowledge and\n    other forms of knowledge? Semantic networks, frames and rules.\n    How can we use inference in conjunction with a knowledge\n    representation scheme to perform reasoning about the world and\n    thereby to solve problems? Inheritance, forward and backward\n    chaining. [1\u00a0lecture]</li>\n<li><strong>Knowledge representation and reasoning II.</strong>\n    Knowledge representation and reasoning using first order logic.\n    The frame, qualification and ramification problems. The\n    situation calculus. [1\u00a0lecture]</li>\n<li><strong>Planning I.</strong> Methods for planning in\n    advance how to solve a problem. The STRIPS language. Achieving\n    preconditions, backtracking and fixing threats by promotion or\n    demotion: the partial-order planning algorithm.\n    [1\u00a0lecture]</li>\n<li><strong>Planning II.</strong> Incorporating heuristics into\n    partial-order planning. Planning graphs. The GRAPHPLAN\n    algorithm. Planning using propositional logic. Planning as a\n    constraint satisfaction problem. [1\u00a0lecture]</li>\n<li><strong>Neural Networks I.</strong> A brief introduction to\n    supervised learning from examples. Learning as fitting a curve\n    to data. The perceptron. Learning by gradient descent.\n    [1\u00a0lecture]</li>\n<li><strong>Neural Networks II.</strong> Multilayer perceptrons\n    and the backpropagation algorithm. [1\u00a0lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>appreciate the distinction between the popular view of the\n    field and the actual research results;</li>\n<li>appreciate the fact that the computational complexity of\n    most AI problems requires us regularly to deal with approximate\n    techniques;</li>\n<li>be able to design basic problem solving methods based on\n    AI-based search, knowledge representation, reasoning, planning,\n    and learning algorithms.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>The recommended text is:</p>\n<p>* Russell, S. and Norvig, P. (2010). <em>Artificial\n  intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd\n  ed.).</p>\n<p>There are many good books available on artificial\n  intelligence; one alternative is:</p>\n<p>Poole, D. L. and Mackworth, A. K. (2017). <em>Artificial\n  intelligence: foundations of computational agents</em>. Cambridge\n  University Press (2nd ed.).</p>\n<p>For some of the material you might find it useful to consult\n  more specialised texts, in particular:</p>\n<p>Dechter, R. (2003). Constraint processing. Morgan\n  Kaufmann.</p>\n<p>Cawsey, A. (1998). <em>The essence of artificial\n  intelligence</em>. Prentice\u00a0Hall.</p>\n<p>Ghallab, M., Nau, D. and Traverso, P. (2004). Automated\n  planning: theory and practice. Morgan Kaufmann.</p>\n<p>Bishop, C.M. (2006). <em>Pattern recognition and machine\n  learning</em>. Springer.</p>\n<p>Brachman, R.J and Levesque, H.J. (2004). <em>Knowledge\n  Representation and Reasoning</em>. Morgan Kaufmann.</p>\n", "course_name": "Artificial Intelligence", "course_code": "ArtInt", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ArtInt", "lecturers": ["sbh11"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Complexity": {"supervisions": 3, "prerequisite_for": ["Crypto"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComplexityTheory.html", "description": "<h2>Aims</h2>\n<p>The aim of the course is to introduce the theory of\n  computational complexity. The course will explain measures of the\n  complexity of problems and of algorithms, based on time and space\n  used on abstract models. Important complexity classes will be\n  defined, and the notion of completeness established through a\n  thorough study of NP-completeness. Applications to cryptography\n  will be considered.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Algorithms and problems.</strong> Complexity of\n    algorithms and of problems. Lower and upper bounds. Examples:\n    sorting and travelling salesman.</li>\n<li><strong>Time and space.</strong> Models of computation and\n    measures of complexity. Time and space complexity on a Turing\n    machine. Decidability and complexity.</li>\n<li><strong>Time complexity.</strong> Time complexity classes.\n    Polynomial time problems and algorithms. Problems on numbers,\n    graphs and formulas.</li>\n<li><strong>Non-determinism.</strong> Non-deterministic\n    machines. The complexity class NP and its various\n    characterizations. Non-deterministic algorithms for\n    satisfiability and other problems in NP.</li>\n<li><strong>NP-completeness.</strong> Reductions and\n    completeness. NP-completeness of satisfiability.</li>\n<li><strong>More NP-complete problems.</strong> Graph-theoretic\n    problems. Independent set, clique and 3-colourability.</li>\n<li><strong>More NP-complete problems.</strong> Sets, numbers\n    and scheduling. Matching, set covering and knapsack.</li>\n<li><strong>coNP.</strong> Validity of boolean formulae and its\n    completeness. NP\u00a0\u2229\u00a0coNP. Primality and\n    factorisation.</li>\n<li><strong>Cryptographic complexity.</strong> One-way\n    functions. The class UP.</li>\n<li><strong>Space complexity.</strong> Deterministic and\n    non-deterministic space complexity classes. The reachability\n    method. Savitch\u2019s theorem.</li>\n<li><strong>Hierarchy.</strong> The time and space hierarchy\n    theorems and complete problems.</li>\n<li><strong>Descriptive complexity.</strong> Logics capturing\n    complexity classes. Fagin\u2019s theorem.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to analyse practical problems and classify them\n    according to their complexity;</li>\n<li>be familiar with the phenomenon of NP-completeness, and be\n    able to identify problems that are NP-complete;</li>\n<li>be aware of a variety of complexity classes and their\n    interrelationships;</li>\n<li>understand the role of complexity analysis in\n    cryptography.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Papadimitriou, Ch.H. (1994). <em>Computational\n  complexity</em>. Addison-Wesley.<br/>\n  Goldreich, O. (2010). <em>P, NP, and NP-Completeness: the basics\n  of computational complexity</em>. Cambridge University Press.\n  Sipser, M. (1997). <em>Introduction to the theory of\n  computation</em>. PWS.</p>\n", "course_name": "Complexity Theory", "course_code": "Complexity", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/Complexity", "lecturers": ["mpf23"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ConceptsPL": {"supervisions": 2, "prerequisite_for": ["CloudComp"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConceptsinProgrammingLanguages.html", "description": "<h2>Aims</h2>\n<p>The general aim of this course is to provide an overview of\n  the basic concepts that appear in modern programming languages,\n  the principles that underlie the design of programming languages,\n  and their interaction.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction, motivation, and overview.</strong>\n    What is a programming language? Application domains in language\n    design. Program execution models. Theoretical foundations.\n    Language standardization. History.</li>\n<li><strong>The ancestors: Fortran, Lisp, Algol and\n    Pascal.</strong> Key ideas: procedural (Fortran), declarative\n    (Lisp), block structured (Algol and Pascal). Execution models\n    (abstract machines), data types, control structures, storage,\n    arrays and pointers, procedures and forms of parameter passing,\n    scope, strict and lazy evaluation, garbage collection. Programs\n    as data (Lisp).</li>\n<li><strong>Object-oriented languages -- Concepts and origins:\n    Simula\u00a0(1964-67) and Smalltalk\u00a0(1971-80).</strong>\n    Dynamic lookup. Abstraction. Subtyping. Inheritance. JavaScript\n    prototypal vs Java class-based inheritance.</li>\n<li><strong>Languages for parallel processing.</strong>\n    Shared-memory concurrency with spawn/sync (OpenMP, Cilk, X10).\n    Distributed-memory models (the actor model, Erlang). External\n    vs. internal iteration.</li>\n<li><strong>Types.</strong> Types in programming languages.\n    Type safety. Type systems--static vs. dynamic. Type checking\n    and type inference. Polymorphism. Overloading. Type\n    equivalence.</li>\n<li><strong>Data abstraction and modularity: SML\n    Modules\u00a0(1984-97).</strong> Information hiding.\n    Modularity. Signatures, structures, and functors. Sharing.</li>\n<li><strong>Combining functional and object-oriented\n    features.</strong> Scala and Java 8. Generic types and methods.\n    Variance annotations. The expression problem. Value types and\n    deep copy.</li>\n<li><strong>More-advanced concepts and idioms.</strong> Haskell\n    monads, type classes. Continuation passing style and call/cc.\n    Dependent types.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with several language paradigms and how they\n    relate to different application domains;</li>\n<li>understand the design space of programming languages,\n    including concepts and constructs from past languages as well\n    as those that may be used in the future;</li>\n<li>develop a critical understanding of the programming\n    languages that we use by being able to identify and compare the\n    same concept as it appears in different languages.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Books:<br/>\n  * Mitchell, J.C. (2003). <em>Concepts in programming\n  languages</em>. Cambridge University Press.<br/>\n  * Scott, M.L. (2009). <em>Programming language pragmatics</em>.\n  Morgan Kaufmann.<br/>\n  Odersky, M. (2008). <em>Scala by example</em>. Programming\n  Methods Laboratory, EPFL.<br/>\n  Pratt, T.W. and Zelkowitz, M.V. (2001). <em>Programming\n  languages: design and implementation</em>. Prentice Hall.</p>\n<p>Papers:<br/>\n  Kay, A.C. (1993). The early history of Smalltalk. <em>ACM SIGPLAN\n  Notices</em>, Vol.\u00a028, No.\u00a03.<br/>\n  Kernighan, B. (1981). Why Pascal is not my favorite programming\n  language. ATandT Bell Laboratories. <em>Computing Science\n  Technical Report</em> No.\u00a0100.<br/>\n  Koenig, A. (1994). An anecdote about ML type inference.\n  <em>USENIX Symposium on Very High Level Languages</em>.<br/>\n  Landin, P.J. (1966). The next 700 programming languages.\n  <em>Communications of the ACM</em>, Vol.\u00a09,\n  Issue\u00a03.<br/>\n  Odersky, M. <em>et al.</em> (2006). An overview of the Scala\n  programming language. <em>Technical Report\n  LAMP-REPORT-2006-001</em>, Second Edition.<br/>\n  McCarthy, J. (1960). Recursive functions of symbolic expressions\n  and their computation by machine. <em>Communications of the\n  ACM</em>, 3(4):184-195.<br/>\n  Stroustrup, B. (1991). What is Object-Oriented Programming? (1991\n  revised version). <em>Proceedings\u00a01st European Software\n  Festival</em>.</p>\n", "course_name": "Concepts in Programming Languages", "course_code": "ConceptsPL", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ConceptsPL", "lecturers": ["am21"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ForModLang": {"supervisions": 2, "prerequisite_for": ["NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FormalModelsofLanguage.html", "description": "<h2>Aims</h2>\n<p>This course studies formal models of language and considers\n  how they might be relevant to the processing and acquisition of\n  natural languages. The course will extend knowledge of formal\n  language theory; introduce several new grammars; and use concepts\n  from information theory to describe natural language.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Natural language and the Chomsky hierarchy\n    1.</strong> Recap classes of language. Closure properties of\n    language classes. Recap pumping lemma for regular languages.\n    Discussion of relevance (or not) to natural languages (example\n    embedded clauses in English).</li>\n<li><strong>Natural language and the Chomsky hierarchy\n    2.</strong> Pumping lemma for context free languages.\n    Discussion of relevance (or not) to natural languages (example\n    Swiss-German cross serial dependancies). Properties of\n    minimally context sensitive languages. Introduction to tree\n    adjoining grammars.</li>\n<li><strong>Language processing and context free grammar\n    parsing 1.</strong> Recap of context free grammar parsing.\n    Language processing predictions based on top down parsing\n    models (example Yngve\u2019s language processing predictions).\n    Language processing predictions based on probabilistic parsing\n    (example Halle\u2019s language processing predictions).</li>\n<li><strong>Language processing and context free grammar\n    parsing 2.</strong> Introduction to context free grammar\n    equivalent dependancy grammars. Language processing predictions\n    based on Shift-Reduce parsing (examples prosodic look-ahead\n    parsers, Parsey McParseface).</li>\n<li><strong>Grammar induction of language classes.</strong>\n    Introduction to grammar induction. Discussion of relevance (or\n    not) to natural language acquisition. Gold\u2019s theorem.\n    Introduction to context free grammar equivalent categorial\n    grammars and their learnable classes.</li>\n<li><strong>Natural language and information theory 1.</strong>\n    Entropy and natural language typology. Uniform information\n    density as a predictor for language processing.</li>\n<li><strong>Natural language and information theory 2.</strong>\n    Noisy channel encoding as a model for spelling error,\n    translation and language processing.</li>\n<li><strong>Vector space models and word vectors.</strong>\n    Introduction to word vectors (example Word2Vec). Word vectors\n    as predictors for semantic language processing.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand how known natural languages relate to formal\n    languages in the Chomsky hierarchy;</li>\n<li>have knowledge of several context free grammars\n    equivalents;</li>\n<li>understand how we might make predictions about language\n    processing and language acquisition from formal models;</li>\n<li>know how to use information theoretic concepts to describe\n    aspects of natural language.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Jurafsky, D. and Martin, J. (2008). <em>Speech and language\n  processing</em>. Prentice Hall.<br/>\n  Manning, C.D. and Schutze, H. (1999) <em>Foundations of\n  statistical natural language processing</em>. MIT Press.<br/>\n  Ruslan, M. (2003) <em>The Oxford handbook of computational\n  linguistics</em>. Oxford University Press.<br/>\n  Clark, A., Fox, C. and Lappin, S. (2010) <em>The handbook of\n  computational linguistics and natural language processing</em>.\n  Wiley-Blackwell.<br/>\n  Kozen, D. (1997) <em>Automata and computibility</em>.\n  Springer.</p>\n", "course_name": "Formal Models of Language", "course_code": "ForModLang", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/ForModLang", "lecturers": ["pjb48"], "lectures": 8, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Security": {"supervisions": 3, "prerequisite_for": ["ECommerce"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Security.html", "description": "<h2>Aims</h2>\n<p>This course provides an overview of technical measures\n  commonly used to enforce security policies, to protect networked\n  and multi-user information systems against malicious user\n  activity, mainly at the level of operating systems and network\n  protocols. It also discusses common security concepts and\n  pitfalls for application programmers and system architects, and\n  strategies for exploiting and mitigating the resulting\n  vulnerabilities.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong>\u00a0Malicious intent:\n    safety vs. security engineering. Security policies, targets,\n    mechanisms. Aspects of confidentiality, integrity,\n    availability, privacy. Requirements across different\n    applications.</li>\n<li><strong>Operating-system security\n    overview.</strong>\u00a0Access-control matrix, trusted\n    computing base, domain separation, CPU modes, system calls,\n    residual information protection, virtual machines.</li>\n<li><strong>POSIX discretionary access\n    control.</strong>\u00a0User and group databases and\n    identifiers, file permission modes, ownership rights, sticky\n    bit, group inheritance, set-uid, elevation of privileges, root\n    user, NFS root squash, chroot, POSIX.1e ACLs.</li>\n<li><strong>Windows discretionary access\n    control.</strong>\u00a0NTFS access rights, security\n    identifiers, access-control entries and lists, inheritance,\n    services, auditing, NFSv4 ACLs.</li>\n<li><strong>Linux-specific mechanisms.</strong>\u00a0LSM, Linux\n    capabilities, AppArmor, seccomp,namespaces, containers.</li>\n<li><strong>Running untrusted code.</strong>\u00a0Mandatory\n    access control, covert channels, SELinux, type enforcement,\n    iOS/macOS/Android app-store sandboxes, capabilities.</li>\n<li><strong>Software\n    vulnerabilities.</strong>\u00a0buffer/integer overflows, ASLR,\n    metacharacter vulnerabilities: shell and SQL injection, side\n    channels, race conditions, environmental exploits,\n    fuzzing.</li>\n<li><strong>Cryptography\n    overview.</strong>\u00a0Private/public-key encryption, MACs,\n    digital signatures, certificates, key revocation, secure hash\n    functions, key-establishment schemes, key generation.</li>\n<li><strong>Entity authentication.</strong>\u00a0Password\n    verification, guessing user-generated secrets, biometric\n    identification, hardware tokens, challenge-response\n    authentication protocols, Kerberos, ssh, TLS.</li>\n<li><strong>Internet protocols.</strong>\u00a0TCP vs UDP,\n    firewalls, iptables, IPSEC/IKE, VPNs, IP options/fragmentation,\n    DDoS.</li>\n<li><strong>Web security.</strong>\u00a0HTTP basics, HTTP\n    authentication, cookies, single sign-on (Ucam WebAuth, SAML),\n    delegation (OAuth2), JavaScript, cross-site scripting,\n    cross-site request forgery, same-origin policy, CORS.</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course, students should appreciate the\n  importance of adversarial thinking in systems design and have a\n  good overview of the security mechanisms and attributes of some\n  of the most commonly used operating systems, networking\n  infrastructure and Internet applications. They should also\n  understand commonly exploited vulnerabilities of authentication\n  mechanisms and know how to avoid some common security pitfalls in\n  software development.</p>\n<h2>Recommended reading</h2>\n<p>Gollmann, D. (2010).\u00a0<em>Computer security</em>. Wiley\n  (3rd ed.).<br/>\n  Dowd, M.; McDonald, J.; Schuh, J. (2007).\u00a0<em>The art of\n  software security assessment</em>. Addison-Wesley.</p>\n", "course_name": "Security", "course_code": "Security", "course_url": "https://www.cl.cam.ac.uk/teaching/2021/Security", "lecturers": ["mgk25"], "lectures": 12, "year": "2021", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}}