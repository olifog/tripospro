{
  "DigElec": {
    "supervisions": 4,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html",
    "description": "\n\n\n<a name=\"SECTION02023100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02023200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p></p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\n\n<p></p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p></p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p></p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p></p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p></p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p></p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n\n<p></p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p></p></li>\n<li><b>Electronics, Devices and Circuits.</b>  Current and voltage, resistance, basic circuit theory, the potential divider. \n  Solving non-linear circuits. Resistor-Capacitor (RC) circuits.\n  Materials, semiconductors and the p-n junction, i.e., the diode. n and p channel MOSFETs and n-MOSFET logic, e.g., n-MOSFET inverter. \n  CMOS logic. Logic families. Noise margin. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02023300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p></p></li>\n<li>be able to design and minimise combinational logic;\n\n<p></p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p></p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p></p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p></p></li>\n<li>understand how to use MOSFETs to build digital logic circuits.\n\n<p></p></li>\n<li>understand the effect of finite load capacitance on the performance of digital logic circuits.\n\n<p></p></li>\n\n\n<a name=\"SECTION02023400000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture</em>. Morgan Kaufmann.\n<br/>Katz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>Hayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\nBooks for reference:\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>Weste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>Mead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>Crowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>Gibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n",
    "course_name": "Digital Electronics",
    "course_code": "DigElec",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/DigElec",
    "lecturers": ["ijw24"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "DiscMath": {
    "supervisions": null,
    "lectures": 24,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html",
    "description": "\n\n\n<a name=\"SECTION02024100000000000000\">Aims</a>\n\n<br/>\n<a name=\"SECTION02024200000000000000\">Lectures</a>\n\n\n<li><b>Proof [5\u00a0lectures].</b>\n<p>Proofs in practice and mathematical jargon. Mathematical statements:\n  implication, bi-implication, universal quantification, conjunction,\n  existential quantification, disjunction, negation.  Logical deduction: proof\n  strategies and patterns, scratch work, logical equivalences.  Proof by\n  contradiction.  Divisibility and congruences.  Fermat\u2019s Little Theorem.\n\n</p><p></p></li>\n<li><b>Numbers [5\u00a0lectures].</b>\n<p>Number systems: natural numbers, integers, rationals, modular integers.  The\n  Division Theorem and Algorithm.  Modular arithmetic.  Sets: membership and\n  comprehension.  The greatest common divisor, and Euclid\u2019s Algorithm and\n  Theorem. The Extended Euclid\u2019s Algorithm and multiplicative inverses in\n  modular arithmetic.  The Diffie-Hellman cryptographic method.  Mathematical\n  induction: Binomial Theorem, Pascal\u2019s Triangle, Fundamental Theorem of\n  Arithmetic, Euclid\u2019s infinity of primes.\n\n</p><p></p></li>\n<li><b>Sets [7\u00a0lectures].</b>\n<p>Extensionality Axiom: subsets and supersets.  Separation Principle:\n  Russell\u2019s Paradox, the empty set.  Powerset Axiom: the powerset Boolean\n  algebra, Venn and Hasse diagrams.  Pairing Axiom: singletons, ordered pairs,\n  products.  Union axiom: big unions, big intersections, disjoint unions.\n  Relations: composition, matrices, directed graphs, preorders and partial\n  orders.  Partial and (total) functions.  Bijections: sections and\n  retractions.  \n  Equivalence relations and set partitions. Calculus of bijections: characteristic (or indicator) functions.  Finite\n  cardinality and counting.  Infinity axiom.  \n  Surjections. Enumerable and countable sets.  Axiom of choice.  \n  Injections. Images:  direct and inverse images.  Replacement Axiom: set-indexed\n  constructions.  Set cardinality: Cantor-Schoeder-Bernstein Theorem,\n  unbounded cardinality, diagonalisation, fixed-points.  Foundation Axiom.\n\n</p><p></p></li>\n<li><b>Formal languages and automata [7\u00a0lectures].</b>\n<p>Introduction to inductive definitions using rules and proof by rule\n  induction. Abstract syntax trees.\n  \n</p><p>Regular expressions and their algebra.  \n  \n</p><p>Finite automata and regular languages: Kleene\u2019s theorem and the Pumping\n  Lemma.\n  </p></li>\n\n<br/>\n<a name=\"SECTION02024300000000000000\">Objectives</a>\n\nOn completing the course, students should be able to\n\n\n<li>prove and disprove mathematical statements using a variety of\n  techniques; \n\n<p></p></li>\n<li>apply the mathematical principle of induction;\n\n<p></p></li>\n<li>know the basics of modular arithmetic and appreciate its role in\n  cryptography; \n\n<p></p></li>\n<li>understand and use the language of set theory in applications to\n  computer science;\n\n<p></p></li>\n<li>define sets inductively using rules and prove properties about them; \n\n<p></p></li>\n<li>convert between regular expressions and finite automata; \n\n<p></p></li>\n<li>use the Pumping Lemma to prove that a language is not regular.\n\n<p></p></li>\n\n\n<a name=\"SECTION02024400000000000000\">Recommended reading</a>\n\nBiggs, N.L. (2002). \n  <em>Discrete mathematics.</em> \n  Oxford University Press (Second Edition).\n<br/>Davenport, H. (2008).\n  <em>The higher arithmetic: an introduction to the theory of numbers.</em>\n  Cambridge University Press.\n<br/>Houston, K. (2009).\n  <em>How to think like a mathematician: a companion to undergraduate\n    mathematics.</em>\n  Cambridge University Press.\n<br/>Kozen, D.C. (1997). \n  <em>Automata and computability</em>. \n  Springer.\n<br/>Lehman, E.; Leighton, F.T.; Meyer, A.R. (2014).\n  <em>Mathematics for computer science.</em> \n  Available on-line.\n<br/>Velleman, D.J. (2006).\n  <em>How to prove it: a structured approach.</em>\n  Cambridge University Press (Second Edition).\n\n\n",
    "course_name": "Discrete Mathematics",
    "course_code": "DiscMath",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/DiscMath",
    "lecturers": ["mpf23", "iml1"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": true,
    "easter": false
  },
  "FoundsCS": {
    "supervisions": 3,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html",
    "description": "\n\n\n<a name=\"SECTION02021100000000000000\">Aims</a>\n\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using <span class=\"MATH\"><i>O</i></span>-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\nThe course will use a functional language (ML).  ML is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso introduce traditional (procedural) programming, such as\nassignments, arrays and references.\n\n\n<a name=\"SECTION02021200000000000000\">Lectures</a>\n\n<li><b>Introduction to Programming.</b>\nThe role of abstraction and representation.  Introduction to integer and floating-point arithmetic.\nDeclaring functions. Decisions and booleans. Example: integer exponentiation.\n\n<p></p></li>\n<li><b>Recursion and Efficiency.</b>\nExamples: Exponentiation and summing integers.  Overloading. Iteration <em>versus</em> recursion. \nExamples of growth rates.  Dominance and <span class=\"MATH\"><i>O</i></span>-Notation.  The costs\nof some representative functions.  Cost estimation.\n\n<p></p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p></p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p></p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p></p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p></p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p></p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying. \nThe \u201capply to all\u201d functional, <tt>map</tt>.  \n<span class=\"textit\">Examples</span>: matrix transpose and product.  \nThe predicate functionals <tt>filter</tt> and <tt>exists</tt>.\n\n<p></p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in ML.\nApplications, for example Newton-Raphson square roots.\n\n<p></p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p></p></li>\n<li><b>Polynomial arithmetic.</b>\nAddition, multiplication of polynomials using ideas from sorting,\netc.\n\n<p></p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not. Introduction to linked lists. \n\n<p></p></li>\n\n\n<a name=\"SECTION02021300000000000000\">Objectives</a>\n\nAt the end of the course, students should\n\n\n<li>be able to write simple ML programs;\n\n<p></p></li>\n<li>understand the fundamentals of using a data structure to represent some mathematical abstraction;\n\n<p></p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p></p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p></p></li>\n<li>understand binary search and binary search trees;\n\n<p></p></li>\n<li>know how to use currying and higher-order functions;\n\n<p></p></li>\n<li>understand how ML combines imperative and functional programming in a single language.\n\n<p></p></li>\n\n\n<a name=\"SECTION02021400000000000000\">Recommended reading</a>\n\n* Paulson, L.C. (1996). <em>ML for the working programmer</em>. Cambridge University Press (2nd\u00a0ed.).\n<br/>Okasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\nFor reference only:\n<br/>Gansner, E.R. &amp; Reppy, J.H. (2004). <em>The Standard ML Basis Library</em>. Cambridge University Press. ISBN: 0521794781\n\n\n",
    "course_name": "Foundations of Computer Science",
    "course_code": "FoundsCS",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/FoundsCS",
    "lecturers": ["lp15"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "HW": {
    "supervisions": null,
    "lectures": null,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": "\n<li><a href=\"Hardware_15.pdf\">Notes</a> for hardware practical\n  classes</li>\n<li><a href=\"../ML/Allocations.pdf\">Group Assignments</a>\n</li>\n<a href=\"../../1415/HW/\">Last year\u2019s course materials</a> are still available.\n",
    "course_name": "Hardware Practical Classes",
    "course_code": "HW",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/HW",
    "lecturers": ["ijw24"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": true,
    "easter": false
  },
  "ML": {
    "supervisions": null,
    "lectures": null,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": "\nPractical Group Assignments and Ticking Times\nYou can view the allocation of ML tick slots\n  by <a href=\"Allocations.pdf\">clicking here</a>\n",
    "course_name": "ML Practical Classes",
    "course_code": "ML",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/ML",
    "lecturers": ["lp15"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "OOProg": {
    "supervisions": 3,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html",
    "description": "\n\n\n<a name=\"SECTION02022100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02022200000000000000\">Lecture syllabus</a>\n\n\n<li><b>Types, Objects and Classes</b> Moving from functional to\n  imperative. Distinguishing state and behaviour. Primitive\n  types. Function prototypes. Objects and classes as custom\n  types. Introduction to parameterised types (templates/Generics).\n\n<p></p></li>\n<li><b>Pointers, References and Memory</b> Pointers and\n  references. The call stack and heap. Iteration and\n  recursion. Pass-by-value and pass-by-reference. Objects as reference\n  types in Java.\n\n<p></p></li>\n<li><b>Creating Classes</b> Modularity. Encapsulation. Information\n  hiding. Access modifiers. \u00a0Advantages of immutability. Creating\n  Generic types in Java. Static data.\n\n<p></p></li>\n<li><b>Inheritance</b> Inheritance. Casting. Shadowing. Overloading. Overriding. Abstract Methods and Classes.\n\n<p></p></li>\n<li><b>Polymorphism and Multiple Inheritance</b> Polymorphism in ML\n  and Java. Multiple inheritance. Interfaces in Java.  \n\n<p></p></li>\n<li><b>Lifecycle of an Object</b> Constructors and chaining. Destructors. Finalizers. Garbage Collection.  Copying Objects. Shallow and deep copies. Copy\n  constructors. Cloning in Java. Cloneable as a marker interface in\n  Java.\n\n<p></p></li>\n<li><b>Java Collections</b> Java Collection interface. Key\n  classes. Collections class. Iteration options and the use of\n  Iterator.  \n\n<p></p></li>\n<li><b>Object Comparison</b> Comparing primitive and reference\n  types. Equals. Comparable and Comparator in Java. Operator\n  Overloading.\n\n<p></p></li>\n<li><b>Error Handling</b> Limitations of return\n  values. Exceptions. Custom exceptions.\n\n<p></p></li>\n<li><b>Design Patterns</b> Introduction to design patterns. Examples\n  of Singleton, Decorator, State, Strategy, Observer.  \n\n<p></p></li>\n<li><b>Case Studies and Worked Examples</b>\n<p></p></li>\n\n\n<a name=\"SECTION02022300000000000000\">Practical classes</a>\n\n\n<li><b>Methods, operators and types.</b>\nThis class will concentrate on the fundamentals of imperative\nprogramming. Students will learn about Java primitive types, variable\ndeclaration, operators and method calls.\n\n<p></p></li>\n<li><b>Control structures.</b>\nStudents will explore the control structures found in Java.\n\n<p></p></li>\n<li><b>Arrays, references and classes.</b>\nThis week the students will explore arrays and references in Java and\nlearn how to define and instantiate their own class.\n\n<p></p></li>\n<li><b>Input/Output and Exceptions.</b>\nThis class will examine streams and Exceptions. Students will read and\nwrite data to and from the filesystem and network and learn to handle\nerrors using Java Exceptions.\n\n<p></p></li>\n<li><b>Inheritance and interfaces.</b>\nThis class will explore object-oriented programming as expressed in\nJava. Students will learn how to extend classes, as well as specify\nand provide implementations for Java interfaces.\n\n<p></p></li>\n<li><b>Abstraction and graphical interfaces.</b>\nStudents will examine code-reuse through inheritance and the use of\ninner classes for encapsulation.  Students will begin to construct a\ngraphical interface using Swing.\n\n<p></p></li>\n<li><b>Swing and event handling.</b>\nStudents will complete their graphical interface by writing event\nhandlers to control the execution of a graphical application.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022400000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with the main features and limitations of the Java\n  language;\n\n<p></p></li>\n<li>be able to write a Java program to solve a well specified problem;\n\n<p></p></li>\n<li>understand the principles of OOP;\n\n<p></p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p></p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p></p></li>\n<li>be familiar with common errors in Java and its associated\n    libraries;\n\n<p></p></li>\n<li>understand a Java program written by someone else;\n\n<p></p></li>\n<li>be able to debug and test Java programs;\n\n<p></p></li>\n<li>be familiar with major parts of Java 8 SE libraries;\n\n<p></p></li>\n<li>understand how to read Javadoc library documentation and reuse\n    library code.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022500000000000000\">Recommended reading</a>\n\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>Gamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>Bloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n",
    "course_name": "Object-Oriented Programming",
    "course_code": "OOProg",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/OOProg",
    "lecturers": ["rkh23", "acr31", "sac92"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "Registratn": {
    "supervisions": null,
    "lectures": null,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": "\n",
    "course_name": "Registration",
    "course_code": "Registratn",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/Registratn",
    "lecturers": ["rkh23"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "Algorithms": {
    "supervisions": 7,
    "lectures": 24,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms.html",
    "description": "\n\n\n<a name=\"SECTION02031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02031200000000000000\">Lectures</a>\n\n<li><b>Sorting.</b>  Review of complexity and O-notation. Trivial\n  sorting algorithms of quadratic complexity. Review of merge sort and\n  quicksort, understanding their memory behaviour on statically\n  allocated arrays. Heapsort. Stability. Other sorting methods\n  including sorting in linear time. Median and order statistics.\n  [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9] [about 4 lectures] \n<p></p></li>\n<li><b>Strategies for algorithm design.</b>\nDynamic programming, divide and conquer, greedy algorithms and other\nuseful paradigms.\n[Ref: CLRS3 chapters 4, 15, 16] [about 3 lectures] \n<p></p></li>\n<li><b>Data structures.</b>  Primitive data structures. Abstract data\n  types. Pointers, stacks, queues, lists, trees. Binary search\n  trees. Red-black trees. B-trees. Hash tables. Priority queues and\n  heaps.  [Ref: CLRS3 chapters 6, 10, 11, 12, 13, 18] [about 5 lectures] \n<p></p></li>\n<li><b>Advanced data structures.</b>  Amortized analysis: aggregate\n  analysis, potential method. Fibonacci heaps. Disjoint sets.  [Ref: CLRS3 chapters 17, 19, 20, 21] [about 4\n    lectures]\n\n<p></p></li>\n<li><b>Graph algorithms.</b>  Graph representations. Breadth-first and\n  depth-first search. Topological sort. Minimum spanning tree. Kruskal\n  and Prim algorithms. Single-source shortest paths: Bellman-Ford and\n  Dijkstra algorithms.  All-pairs shortest paths: matrix\n  multiplication and Johnson\u2019s algorithms. Maximum flow:\n  Ford-Fulkerson method, Max-Flow Min-Cut Theorem. Matchings in bipartite graphs.  [Ref: CLRS3\n    chapters 22, 23, 24, 25, 26] [about 7 lectures]\n\n<p></p></li>\n<li><b>Geometric algorithms.</b>  Intersection of segments. Convex\n  hull: Graham\u2019s scan, Jarvis\u2019s march.  [Ref: CLRS3 chapter 33] [about\n    1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION02031300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>have a thorough understanding of several classical algorithms\n  and data structures;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p></p></li>\n<li>have a good understanding of how a smart choice of data\n  structures may be used to increase the efficiency of particular\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\n\n<a name=\"SECTION02031400000000000000\">Recommended reading</a>\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein,\nC. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN\n978-0-262-53305-8\n<br/>Sedgewick, R., Wayne, K. (2011). <em>Algorithms</em> Addison-Wesley. ISBN\n978-0-321-57351-3.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.\n<br/>Knuth, D.A. (2011). <em>The Art of Computer\n  Programming</em>. Addison-Wesley. ISBN 978-0-321-75104-1.\n<br/>\n<br/>\nStudents hoping to receive a computer science degree from Cambridge\nare expected to buy, make extensive use of, and keep as reference for\ntheir future career, one of the above fundamental textbooks: those not\ndoing so will be severely disadvantaged. The recommended choice is\nCormen, Leiserson, Rivest and Stein (CLRS3, starred in the above list)\nwhich covers all topics listed and, in spite of its superb quality, is\nthe cheapest: about 35 GBP new for over 1300 pages. The references in\nthe syllabus are to this textbook. The other textbooks listed are\nexcellent additions for further study but might cost more and yet not\ncover the entire syllabus.\n\n\n",
    "course_name": "Algorithms",
    "course_code": "Algorithms",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/Algorithms",
    "lecturers": ["fms27", "tms41"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "OpSystems": {
    "supervisions": 3,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html",
    "description": "\n\n\n<a name=\"SECTION02032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02032200000000000000\">Lectures</a>\n\n<li><b>Introduction to operating systems.</b> Abstract view of an operating system. OS evolution: multi-programming, time-sharing. Dual-mode operation. Protecting I/O, memory, CPU. Kernels and micro-kernels. Elementary computer architecture. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Processes and scheduling.</b> Job/process concepts. Scheduling basics: CPU-I/O interleaving, (non-)preemption, context switching. Scheduling algorithms: FCFS, SJF, SRTF, priority scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Memory management.</b> Processes in memory. Logical addresses. Partitions: static <em>versus</em> dynamic, free space management, external fragmentation. Segmented memory. Paged memory: concepts, internal fragmentation, page tables. Demand paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and approximations), NRU, LFU/MFU, MRU. Working set schemes. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>I/O subsystem.</b> General structure. Polled mode <em>versus</em> interrupt-driven I/O. Application I/O interface: block and character devices, buffering, blocking <em>versus</em> non-blocking I/O. Other issues: caching, scheduling, spooling, performance. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>File management.</b> File concept. Directory and storage services. File names and meta-data. Directory name-space: hierarchies, DAGs, hard and soft links. File operations. Access control. Existence and concurrency control. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Protection.</b> Requirements. Subjects and objects. Design principles. Authentication schemes. Access matrix: ACLs and capabilities. Combined scheme. Covert channels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Unix case study.</b> History. General structure. Unix file system: file abstraction, directories, mount points, implementation details. Processes: memory image, life cycle, start of day. The shell: basic operation, commands, standard I/O, redirection, pipes, signals. Character and block I/O. Process scheduling. [2\u00a0lectures]\n\n<p></p></li>\n\n<br/>\n<a name=\"SECTION02032300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>describe the general structure and purpose of an operating system;\n</li>\n<li>explain the concepts of process, address space, and file;\n</li>\n<li>compare and contrast various CPU scheduling algorithms;\n</li>\n<li>understand the differences between segmented and paged memories, and be able to describe the advantages and disadvantages of each;\n</li>\n<li>compare and contrast polled, interrupt-driven and DMA-based access to I/O devices.\n</li>\n\n<br/>\n<a name=\"SECTION02032400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>. Addison-Wesley (3rd ed.).\n<br/>Silberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <em>Operating systems concepts</em>. Wiley (8th ed.).\n<br/>Leffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>McKusick, M.K., Neville-Neil, G.N. &amp; Watson, R.N.M. (2014) <em>The Design and Implementation of the FreeBSD Operating System</em>. Pearson Education. (2nd end.).\n<br/>Solomon, D. &amp; Russinovich, M. (2000). <em>Inside Windows 2000</em>. Microsoft Press (3rd ed.).\n\n\n",
    "course_name": "Operating Systems",
    "course_code": "OpSystems",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/OpSystems",
    "lecturers": ["rmm1002"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "FJavaBrfg": {
    "supervisions": null,
    "lectures": 1,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": "\n\n\n<a name=\"SECTION02043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02043200000000000000\">Lecture</a>\n\nThe lecture describes the requirements for the first assessed\nexercise of the Part\u00a0IB Further Java course.\n\n\n<a name=\"SECTION02043300000000000000\">Objectives</a>\n\nOn completing the exercise students should\n\n\n<li>be prepared for the Part\u00a0IB Further Java course;\n\n<p></p></li>\n<li>have developed their practical Java programming skills further.\n\n<p></p></li>\n\n\n\n",
    "course_name": "Further Java Briefing",
    "course_code": "FJavaBrfg",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/FJavaBrfg",
    "lecturers": ["acr31"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": false,
    "lent": false,
    "easter": true
  },
  "NumMethods": {
    "supervisions": 3,
    "lectures": 11,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-NumericalMethods.html",
    "description": "\n\n\n<a name=\"SECTION02041100000000000000\">Aims</a>\n\n<li>an introduction to\n(IEEE) floating-point data representation and arithmetic; \n</li>\n<li>illustrations of how na\u00efve implementations of obvious mathematics can go badly wrong;\n</li>\n<li>a study of several standard numerical algorithms.\n</li>\n\nAn overall implicit aim is to encourage caution when using any\nfloating-point value produced by a computer program.  A variety of code\nfragments are provided and most are available in multiple languages.\nStudents are strongly encouraged to experiment with these fragments.\n\n<br/>\n<a name=\"SECTION02041200000000000000\">Lectures</a>\n\n<li><b>Integer and floating-point representation and arithmetic.</b>\nSigned and unsigned integers and fixed-point; arithmetic, saturating arithmetic.\nLong division and multiplication.\nFloating point I/O in ASCII.\nWhat numbers are exactly representable in bases 2 and 10.\nAccuracy in terms of significant figures.\n\n<p></p></li>\n<li><b>IEEE floating-point arithmetic.</b>\nFloating-point arithmetic, and the IEEE requirements.\nIEEE 754/854 floating point (32 and 64 bit); zeros, infinities, NaN.\nOverflow, underflow, progressive loss of significance.      Rounding modes.\nFloating-point arithmetic is non-associative, and mathematical equivalences fail.\nNonsensical results, e.g. <tt>sin(1e40)</tt>.\nDifficulty in obtaining IEEE-quality in libraries.\n\n<p></p></li>\n<li><b>How floating-point computations diverge from real-number calculations.</b>\nAbsolute Error, Relative Error, Machine epsilon, Unit in Last Place (ulp).\nFinite computation: solving a quadratic.\nSumming a finite series.\nRounding (round-off) and truncation (discretisation) error.\nNumerical differentiation; determining a good step size.\n\n<p></p></li>\n<li><b>Iteration and when to stop.</b>\nUnbounded computation may produce unbounded errors.\nSolving equations by iteration and comparison to terminate it.\nNewton\u2019s method.\nOrder of convergence. Limit cycles.\nWhy summing a Taylor series is problematic. \nCondition number, partial derivatives, backwards stability and chaos.\n\n<p></p></li>\n<li><b>Matrix Form Simultaneous Equations.</b>\nGaussian Elimination. \nStability and pivoting improvements.\nPositive-definite. L/U and Cholesky decompositions.  Doolittle/Crout method.\n\n<p></p></li>\n<li><b>Efficient Implementation</b>\nChebychev orthogonal basis (for power series economisation) \nPractical implementation of scientific (trig/log) functions. \nComparison of Taylor, Chebychev and Cordic.\n\n<p></p></li>\n<li><b>Finite-Difference Time-Domain Simulation.</b>\nNumerical simulation of SHM, charge/discharge, waves and other various examples (such as a Moniac Simulator). \n\n<p></p></li>\n<li><b>Circuit/Flow Analysis.</b>  Using a matrix representation\nof a linear flow circuit (water, electricity etc) to find steady\nstate. Extensions for non-linear and time-varying branches as used by SPICE.\n\n<p></p></li>\n<li><b>Adaptive Methods and Custom Encodings</b> \nA subset of the following topics will we be lectured. Details in handout.\nArbitrary precision floating point, adaptive floating point, interval arithmetic.\nRounding errors in PCM. Logarithmic and other non-linear representations. Their use in a-posteriori decision algorithms.\nEg for rapid multiplication in Viterbi/Bayes and specialist ALUs (e.g. for low-density parity).\nSimulated Annealing. Non-linear spatial quantisation.\n\n<p></p></li>\n\n\n<a name=\"SECTION02041300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to convert simple decimal numbers to and from IEEE\n  floating-point format, and to perform IEEE arithmetic on them;\n\n<p></p></li>\n<li>be able to identify problems with floating-point implementations of\n      simple mathematical problems and know when incorrect solution is likely;\n\n<p></p></li>\n<li>be familiar with several key algorithms from the history of numerical analysis;\n\n<p></p></li>\n<li>decide how and when computation energy should be traded for accuracy;\n\n<p></p></li>\n<li>know to use a professionally-written package whenever possible\n      (and still to treat claims of accuracy with suspicion).\n\n<p></p></li>\n\n\n<a name=\"SECTION02041400000000000000\">Recommended reading</a>\n\nOverton, M.L. (2001). <em>Numerical computing with IEEE floating point arithmetic</em>. SIAM.\n\nFurther reading - goes far beyond the course\n\nGoldberg, D. (1991). <em>What every computer scientist should know about floating-point arithmetic</em>. ACM Computing Surveys, vol. 23, pp. 5-48.\n\n\n",
    "course_name": "Numerical Methods",
    "course_code": "NumMethods",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/NumMethods",
    "lecturers": ["djg11"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": false,
    "lent": false,
    "easter": true
  },
  "SWIDesign": {
    "supervisions": 3,
    "lectures": 11,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandInterfaceDesign.html",
    "description": "\n\n\n<a name=\"SECTION02042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02042200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Design process overview: Inception phase,\r\n  Elaboration phase, Construction phase, Transition phase (1 lecture).\n\n<p></p></li>\n<li><b>Inception.</b>  Structured description of system usage\r\n  and function (2 lectures).\n\n<p></p></li>\n<li><b>Elaboration.</b> Development and evaluation of\r\n  interactive prototypes (2 lectures).\n\n<p></p></li>\n<li><b>Construction.</b> Use of source code as a design model (1 lecture).\n\n<p></p></li>\n<li><b>Transition.</b> Testing and debugging techniques (2 lectures).\n\n<p></p></li>\n<li><b>Evaluation.</b> Measurement with respect to design objectives (2 lectures).\n\n<p></p></li>\n<li><b>Iteration.</b> Design process responses to uncertainty and\r\n  requirements change (1 lecture).\n\n<p></p></li>\n\n\n<a name=\"SECTION02042300000000000000\">Objectives</a>\n\nAt the end of the course, students should be able to undertake design of an\ninteractive system in a methodical manner, starting from a general requirement, analysing user needs, developing a design model, approaching iterative model\r\nrefinement and implementation in a manner that minimises risk, and\r\nusing appropriate methods to identify and prevent faults.\n\n\n<a name=\"SECTION02042400000000000000\">Recommended reading</a>\n\nPressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>Sharp, H., Rogers, Y. &amp; Preece, J. (2007). <i>Interaction design: beyond \r\nhuman-computer interaction</i>. Wiley (2nd ed.).\n<br/>Further reading\n\nMcConnell, S. (2004). <i>Code complete: a practical handbook of software construction</i>. Microsoft Press (2nd ed.).\n<br/>Broy, M. &amp; Denert, E. (ed.) (2002). <i>Software pioneers: contributions to software engineering</i>. Springer-Verlag.\n<br/>Schon, D.A. (1990). <i>Educating the reflective practitioner</i>. Jossey-Bass.\n<br/>\n\n",
    "course_name": "Software and Interface Design",
    "course_code": "SWIDesign",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1516/SWIDesign",
    "lecturers": ["afb21"],
    "year": "1516",
    "tripos_part": "1a",
    "michaelmas": false,
    "lent": false,
    "easter": true
  }
}
