{
  "AlgorithII": {
    "supervisions": null,
    "lectures": 2,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-AlgorithmsII.html",
    "description": "\nSyllabus\n2011-11-04 Fri\nYou may skip 17.2, 17.4\nFrom last year: revise 6.5 and binomial heaps (problem 19-2)\nif you forgot them.\n\n2011-11-07 Mon\n19.1, 19.2\n\n2011-11-09 Wed\n19.3, 19.4\n\n2011-11-11 Fri\n20.1, 20.2\n\n2011-11-14 Mon\n20.3\n\n2011-11-16 Wed\n21.1, 21.2, 21.3, 22.1, 22.2, 22.3\nYou may skip 21.4, 22.5\n\n2011-11-18 Fri\n22.4, 23.1, 23.2\n\n2011-11-21 Mon\n24.1, 24.3, 24.5\n You may skip 24.2, 24.4\n\n2011-11-23 Wed\n25.1, 25.3\nYou may skip 25.2\n\n2011-11-25 Fri\n26.1, 26.2, 26.3\nYou may skip 26.4, 26.5\n\n2011-11-28 Mon\n27.1\nYou may skip 27.2, 27.3\n\n2011-11-30 Wed\n33.1, 33.2, 33.3\nYou may skip 33.4\n\n\n\nPast exam questions\nQuestions can be found\nunder <a href=\"http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-AlgorithmsII.html\">Algorithms\nII</a> but also, for historical reasons,\nunder <a href=\"http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DataStructuresandAlgorithms.html\">Data\nStructures and Algorithms</a> (the parent course for both Algorithms I\nand Algorithms II); if you pick from the latter set, be sure to select\nquestions dealing with topics covered in this year's syllabus.\n\nInformation for supervisors\nThis year the course has two new lectures. You want\nthe <a href=\"supervisors\">new guide</a>.  Contact lecturer for access,\nstating your name, your CRSID and, if you are a student, your PhD\nsupervisor.\n\nLecture handouts\nDistributed during the first lecture. It will be to\nyour advantage to bring your handout to every lecture, together with a\nnotebook with non-detachable pages and a few coloured pens. Further\nprinted copies of the handout are available from the student\nadministration\noffice. An <a href=\"./handout/2011-stajano-algs2-students-handout.pdf\">electronic\ncopy</a> is also available: please do not print it again yourself and\nplease do not circulate it outside cam.ac.uk.\n\nMicrochallenges\n2011-11-04 Fri\nCDLL (expired)\n\n\n\n2011-11-09 Wed\nlg lg nanochallenge (expired)\n\n\n\n2011-11-25 Fri\nMST microchallenge (expired)\n\n\nMy heroes!\n2011-11-04 microchallenge (circular doubly-linked list)\n<tbody><tr><td>Timothy Goh\n</td></tr><tr><td>James King\n</td></tr><tr><td>David Brazdil\n</td></tr><tr><td>Eduardo Munoz\n</td></tr><tr><td>Lewis Brown\n</td></tr><tr><td>Rory McCann \n</td></tr><tr><td>Thomas Chetwin\n</td></tr><tr><td>Dylan Ede (8 mins past the deadline :-))\n</td></tr></tbody>\n2011-11-09 nanochallenge (lg lg x)\n<tbody><tr><td>Tom Smith (7 mins after the lecture!!!)\n</td></tr><tr><td>Thomas Chetwin\n</td></tr><tr><td>Timothy Goh\n</td></tr><tr><td>Rolandas Glotnis \n</td></tr><tr><td>David Brazdil\n</td></tr><tr><td>James Morley\n</td></tr></tbody>\n2011-11-16 (spontaneous initiative, not a microchallenge)\nSzymon Sidor, for suggesting\nand <a href=\"http://pastebin.com/6WBthRNY\">implementing</a> a\nnon-recursive alternative\n(<a href=\"http://dx.doi.org/10.1145%2F368996.369025\">Kahn</a>'s\nalgorithm) for topological sort. There\nis <a href=\"http://en.wikipedia.org/wiki/Topological_sorting\">pseudocode</a>\non Wikipedia.\n\n2011-11-25 microchallenge (MST)\n<tbody><tr><td>Timothy Goh\n</td></tr><tr><td>Lewis Brown\n</td></tr><tr><td>Max Spencer (Prim only)\n</td></tr></tbody>\n\"I know my submission is totally late and you might not even have read\nthese emails, but I am so glad I figured it out I just wanted to send\nit anyway!  This is the best feeling, this is why I love programming.\"\n\nAdditional resources\nFibonacci heaps\nThe original paper on Fibonacci heaps is available from\nthe <a href=\"http://portal.acm.org/citation.cfm?id=28874\">ACM digital\nlibrary</a> (or <a href=\"1987-FredmanTar-fibonacci.pdf\">cached</a>).\n\nHere is the animation that I used in lectures (click for multi-page pdf).\n\n<a href=\"fibonacci.pdf\"><img alt=\"Fibonacci heap execution trace\" src=\"fibonacci-preview.png\"/></a>\nVisualization of graphs and other linked data structures\nWorth becoming familiar\nwith <a href=\"http://en.wikipedia.org/wiki/DOT_language\">DOT</a>\nand <a href=\"http://graphviz.org\">Graphviz</a>; then, when you write\nprograms to practice what you study in this course, with modest\nadditional effort you can neatly display what goes on inside.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nErrata corrige\nNegative line numbers are counted from the bottom of the page. Top\nline (excluding headers) is 1. Bottom line (excluding footers) is -1.\n\n<tbody><tr><th>Page</th><th>Line</th><th>Errata</th><th>Corrige</th><th>Found\non</th><th>by\n\n </th></tr><tr><td>8</td><td>pseudocode line 29</td><td>Payload p;</td><td>Data\n payload;</td><td>2011-12-03</td><td>Heidi Howard\n\n\n </td></tr><tr><td>15</td><td>-4</td><td>cost of Dijkstra is |V| times</td><td>cost of Dijkstra\n is dominated by |V| times</td><td>2011-11-03</td><td>author\n\n\n\n </td></tr><tr><td>19</td><td>-3</td><td>void decreaseKey(FibNode n, int delta)</td><td>void\n decreaseKey(FibNode n, int newKey)</td><td>2011-12-03</td><td>Heidi Howard\n\n </td></tr><tr><td>20</td><td>1</td><td>Decrease the key of node n by delta</td><td>Decrease\n the key of node n to newKey</td><td>2011-12-03</td><td>Heidi Howard\n\n </td></tr><tr><td>20</td><td>2</td><td>and delta is non-negative</td><td>and newKey &lt;\n n.key</td><td>2011-12-03</td><td>Heidi Howard\n\n </td></tr><tr><td>20</td><td>5</td><td>Decrease that key by the stated amount</td><td>Decrease\n n.key to the new value</td><td>2011-12-03</td><td>Heidi Howard\n\n </td></tr><tr><td>20</td><td>21</td><td>with the largest possible delta (conceptually\n decreasing the key to -infinity)</td><td>with a newKey of\n -infinity</td><td>2011-12-03</td><td>Heidi Howard\n\n\n\n\n </td></tr><tr><td>21</td><td>-16</td><td>given heap in a given state</td><td>heap with n\n nodes</td><td>2011-11-03</td><td>author\n\n </td></tr><tr><td>21</td><td>-16, -14, -13, -13, -13</td><td>d</td><td>d(n)</td><td>2011-11-03</td><td>author\n\n </td></tr><tr><td>21</td><td>-10</td><td>O(d) = O(lg n)</td><td>d(n) = O(lg n)</td><td>2011-11-03</td><td>author\n\n\n </td></tr><tr><td>21</td><td>-3</td><td>void decreaseKey(FibNode n, int delta)</td><td>void\n decreaseKey(FibNode n, int newKey)</td><td>2011-12-03</td><td>Heidi Howard\n\n\n\n\n </td></tr><tr><td>22</td><td>13</td><td>This is still a constant,</td><td>This is still a\n constant with respect to n,</td><td>2011-11-03</td><td>author\n\n </td></tr><tr><td>22</td><td>-14</td><td>in a Fibonacci heap</td><td>in an n-node Fibonacci\n heap</td><td>2011-11-03</td><td>author\n\n </td></tr><tr><td>24</td><td>8</td><td>were the fastest</td><td>were the asymptotically\n fastest</td><td>2011-11-01</td><td>author\n\n </td></tr><tr><td>24</td><td>20</td><td>set: insert()</td><td>set (except that we disregard\n satellite data): member(), insert()</td><td>2011-11-01</td><td>author\n\n </td></tr><tr><td>25</td><td>-6</td><td>the total cost is O(1)</td><td>the total cost is\n O(\u221a u)</td><td>2011-11-11</td><td>author\n\n </td></tr><tr><td>30</td><td>-26 to -24</td><td>If it's not the base case, we set the\n appropriate summary bit (direct access, therefore constant time) and\n we recursively insert the key into the correct cluster.</td><td>If the\n node is empty, insert directly at constant cost. Otherwise, insert\n into both cluster and summary. However only one of these two calls is\n recursive: if the cluster was empty, insertion into cluster has\n constant cost and insertion into summary is recursive; otherwise,\n insertion into cluster is recursive and insertion into summary is not\n needed because it's already marked as\n non-empty.</td><td>2011-11-14</td><td>author\n\n </td></tr><tr><td>32</td><td>lines 10 and 11 of first pseudocode\n block</td><td>PRECONDITION: there exists a set containing x and a\n different one containing y.</td><td>PRECONDITION: x !=\n y.</td><td>2011-12-27</td><td>Simon Blessenohl\n\n </td></tr><tr><td>42</td><td>lines 11 to 14 of Kruskal listing</td><td>\n<pre>for edge in E:\n    if D.findSet(edge.start) != D.findSet(edge.end): \n        A.append(edge) \n        D.union(edge.start, edge.end)\n</pre></td><td><pre>for edge in E:\n    startSet = D.findSet(edge.start) \n    endSet = D.findSet(edge.end)\n    if startSet != endSet:\n        A.append(edge)\n        D.union(startSet, endSet)\n</pre>\n</td><td>2011-12-27</td><td>Simon Blessenohl\n\n\n </td></tr><tr><td>45</td><td>-15 to -14</td><td>equal to the number of vertices in the\n graph</td><td>eqal to the maximum possible length of a shortest path,\n |V|-1</td><td>2011-12-16</td><td>Tom Sparrow\n\n\n </td></tr><tr><td>47</td><td>-8</td><td>cost of decreaseKey.</td><td>cost of\n decreaseKey().</td><td>2011-11-01</td><td>author\n\n </td></tr><tr><td>59</td><td>5</td><td>computation on on</td><td>computation on</td><td>2011-11-19</td><td>author\n\n </td></tr><tr><td>59</td><td>15</td><td>&gt;=</td><td>\u2265</td><td>2011-11-19</td><td>author\n\n </td></tr><tr><td>61</td><td>13</td><td>(and the next vertex may or may not be a source\n at that point)</td><td>(and the next vertex will be a source at that\n point)</td><td>2011-11-28</td><td>Ben Thorner\n\n </td></tr><tr><td>63</td><td>-4</td><td>Extrapolating to 256 processors</td><td>Extrapolating\n to 512 processors</td><td>2011-11-19</td><td>author\n\n\n</td></tr></tbody>\nIf you find any more errors, please mail them to me and I'll\n credit you here and in the next version of the handout. Recursive\n thanks also to Simon Iremonger for finding a further error, now\n corrected, in the Errata Corrige itself.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n <a href=\"http://validator.w3.org/check?uri=referer\"><img alt=\"Valid XHTML 1.0 Transitional\" height=\"31\" src=\"http://www.w3.org/Icons/valid-xhtml10-blue\" width=\"88\"/></a>\n\n",
    "course_name": "Algorithms\u00a0II",
    "course_code": "AlgorithII",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/AlgorithII",
    "lecturers": ["fms27"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "CompDesign": {
    "supervisions": null,
    "lectures": 22,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerDesign.html",
    "description": "\n\n\nAddendum to the syllabus\nThis course has been overhauled this year and there have been some\n  minor adjustments to the syllabus (below) that was prepared earlier\n  in the year:\n<li>An implementation of the Manchester Baby machine has been dropped\n  in favour of introducing the implementation of Chuck Thacker's Tiny\n  Computer 3 used in the ECAD+Arch labs.  This new lecture is listed\n  on the syllabus as \"Building a simple RISC machine\".</li>\n<li>Due to the above change, there are now only 17 lectures.  The\n  spare lecture slot has been left available in case there is a major\n  problem with the new ECAD+Arch labs which requires additional\n  support teaching.</li>\n<li>The <b>SystemVerilog FPGA design</b> lecture has been swapped with\n  the <b>Chip, board and system testing</b> lecture.\n</li>\nThe syllabus\nNo. of lectures: 22 (including 4 via a web-based tutor)\n\n<br/>Prerequisite course: Digital Electronics\n\n<br/>This course is a prerequisite for the Part II courses Comparative Architectures and System-on-Chip Design.\n\n<br/>\n<a name=\"SECTION03022100000000000000\">Aims</a>\n\nThe aims of this course are to introduce a hardware description\nlanguage (SystemVerilog) and computer architecture concepts in order to\ndesign computer systems.  This is an amalgam of the former ECAD and\nComputer Design courses.\n\nThere are 18 lectures which cover design with hardware description\nlanguages, computer architecture and then computer implementation.  A\nweb based tutor (equivalent of 4 lectures) is used to teach much of\nthe SystemVerilog hardware description language.\n\n\n<a name=\"SECTION03022200000000000000\">Lectures</a>\n\n<li><b>Introduction and motivation.</b>\n  Current technology, technology trends, ECAD trends, challenges. \n<p></p></li>\n<li><b>Logic modelling, simulation and synthesis.</b>\n  Logic value and delay modelling. Discrete event and device\n  simulation. Automatic logic minimization. \n<p></p></li>\n<li><b>SystemVerilog FPGA design.</b>\n  Practicalities of mapping SystemVerilog descriptions of hardware\n  (including a processor) onto an FPGA\n  board.  Tips and pitfalls when generating larger modular designs. \n<p></p></li>\n<li><b>Chip, board and system testing.</b>\n  Production testing, fault models, testability, fault coverage,\n  scan path testing, simulation models. \n<p></p></li>\n<li><b>Historical perspective on computer architecture.</b>\n<p></p></li>\n<li><b>Early instruction set architecture.</b>\n   EDSAC <em>versus</em> Manchester Mark I.\n\n<p></p></li>\n<li><b>Build your first computer.</b>\n   Implement a Manchester Baby machine in Java and SystemVerilog.\n\n<p></p></li>\n<li><b>RISC machines.</b>\n   Introduction to RISC processor design.\n\n<p></p></li>\n<li><b>Building a simple RISC machine.</b>\n<p></p></li>\n<li><b>CISC machines and the Intel x86 instruction set.</b>\n<p></p></li>\n<li><b>Java Virtual Machine.</b>\n<p></p></li>\n<li><b>Memory hierarchy.</b>\n  Caching, etc.\n\n<p></p></li>\n<li><b>Hardware support for operating systems.</b>\n  Memory protection, exceptions, interrupts, etc.\n\n<p></p></li>\n<li><b>Pipelining and data paths.</b>\n<p></p></li>\n<li><b>Internal and external communication.</b>\n<p></p></li>\n<li><b>Introduction to many-core processors.</b>\n<p></p></li>\n<li><b>Data-flow machines.  Future directions.</b>\n<p></p></li>\n\n\n<a name=\"SECTION03022300000000000000\">On-Line Learning Component: Cambridge SystemVerilog Tutor</a>\n\n<li>The interactive web-based tutor teaches the synthesizable\n  subset of SystemVerilog which is required to complete the laboratory\n  sessions.\n</li>\n\n\n<a name=\"SECTION03022400000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read assembler given a guide to the instruction set\nand be able to write short pieces of assembler if given an\ninstruction set or asked to invent an instruction set;\n\n<p></p></li>\n<li>understand the differences between RISC and CISC assembler;\n\n<p></p></li>\n<li>understand what facilities a processor provides to support\noperating systems, from memory management to software interrupts;\n\n<p></p></li>\n<li>understand memory hierarchy including different cache\nstructures;\n\n<p></p></li>\n<li>appreciate the use of pipelining in processor design;\n\n<p></p></li>\n<li>understand the communications structures, from buses close to\nthe processor, to peripheral interfaces;\n\n<p></p></li>\n<li>have an appreciation of control structures used in processor design;\n\n<p></p></li>\n<li>have an appreciation of how to implement a processor in SystemVerilog.\n\n<p></p></li>\n\n\n<a name=\"SECTION03022500000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). <em>Digital design and computer architecture: from gates to processors</em>. Morgan Kaufmann.\n\nRecommended further reading:\n\nHennessy, J. &amp; Patterson, D. (2006). <em>Computer architecture: a quantitative approach</em>. Elsevier (4th ed.). ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also still generally relevant.)\n<br/>Patterson, D.A. &amp; Hennessy, J.L. (2004). <em>Computer organization and design</em>. Morgan Kaufmann (3rd ed., as an alternative to the above). (2nd ed., 1998, is also good.)\n<br/>Pointers to sources of more specialist information are included in the\nlecture notes and on the associated course web page.\n\n\n",
    "course_name": "Computer Design",
    "course_code": "CompDesign",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompDesign",
    "lecturers": ["swm11"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "ConcDisSys": {
    "supervisions": null,
    "lectures": 16,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html",
    "description": "\n\n\n<a name=\"SECTION03023100000000000000\">Aims of the Michaelmas Term part of the course</a>\n\n\n<a name=\"SECTION03023200000000000000\">Michaelmas Term Lectures (Concurrency)</a>\n\n\n<li><b>Introduction; thread models.</b>\nOverview of properties of distributed and concurrent systems. Software\nsystem structure. Occurrence of concurrency in systems. Recap of scheduling\nand preemption. Thread models.\n\n<p></p></li>\n<li><b>Classical concurrency control.</b>\nShared data and critical regions. Mutual exclusion and condition\nsynchronisation. Semaphores. Implementation of concurrency control.\n\n<p></p></li>\n<li><b>Classical problems using semaphores.</b>\nBounded cyclic buffer (producer(s) and consumer(s)), multiple readers and\nwriters. Problems arising in semaphore programming.\n\n<p></p></li>\n<li><b>Concurrency support in programming languages.</b>\nShared data: monitors, pthreads, Java. No shared data: occam, Ada active\nobjects, Erlang, Kilim, tuple spaces.  \nLock-free programming.\n\n<p></p></li>\n<li><b>Concurrent composite operations.</b>\nComposite operations in main memory and persistent memory. Dynamic\nresources allocation and deadlock. Dining philosophers program. Deadlock\ndetection and avoidance.\n\n<p></p></li>\n<li><b>Transactions.</b>\nACID properties. Concurrency control and crash recovery. Definition of\nconflicting operations. Serialisation. Cascading aborts.\n\n<p></p></li>\n<li><b>Database concurrency control.</b>\nPessimistic concurrency control: two-phase locking, timestamp ordering.  \nOptimistic concurrency control.\n\n<p></p></li>\n<li><b>Database recovery and summary of \u201cConcurrency\u201d.</b>\nWrite ahead log, undo/redo. Points to take forward.\n\n<p></p></li>\n\n\n<a name=\"SECTION03023300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the need for concurrency control in operating systems and\napplications, both mutual exclusion and condition synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the implications of\ndifferent approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming languages for\nconcurrency control and be able to judge the scope, performance\nimplications and possible applications of the various approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of transactions,\nhow concurrency control can be assured and how transactions can be\ndistributed;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and their\nimplications for system design;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of fundamental\nservices and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03023400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent Systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.). \n\n\n<a name=\"SECTION03023500000000000000\">Aims of the Lent Term part of the course</a>\n\nThe aims of this course are to study the fundamental characteristics of\ndistributed systems, including their models and architectures; the\nimplications for software design; some of the techniques that have been\nused to build them; and the resulting details of good distributed\nalgorithms and applications.\n\n\n<a name=\"SECTION03023600000000000000\">Lent Term Lectures (Distributed Systems)</a>\n\n\n<li><b>Introduction, Evolution, Architecture.</b>\nFundamental properties. Evolution from LANs. Introduction to the need\nfor naming, authentication, policy specification and enforcement.\nExamples of multi-domain systems. Why things can get difficult\nquickly.  Enough Erlang to understand subsequent examples.\n\n<p></p></li>\n<li><b>Time and event ordering.</b>\n Time, clocks and event ordering.\n    Earth time, computer clocks, clock drift, clock synchronisation.\n    Order imposed by inter-process communication. \n    Timestamps point/interval. \n    Event composition; uncertainty of ordering, failure and delay.\n<br/><p>Process groups: open/closed, structured/unstructured. \n    Message delivery ordering: arrival order; causal order (vector \nclocks);\n    total order. Physical causality from real-world examples. \n\n</p><p></p></li>\n<li><b>Consistency and commitment.</b>\nStrong and weak consistency. Replica management. Quorum assembly.\n    Distributed transactions. Distributed concurrency control:\n    two-phase locking, timestamp ordering.\n    Atomic commitment; two-phase commit protocol.\n    Distributed optimistic concurrency control and commitment. \n<br/><p>Some algorithm outlines: Election of a leader. \n    Distributed mutual exclusion.\n\n</p><p></p></li>\n<li><b>Middleware.</b>\n  Synchronous: RPC, object-orientated. Asynchronous: message orientated,\n    publish/subscribe, peer-to-peer. \n    Event-based systems. \n    Examples of some simple distributed programs in Java and Erlang.\n\n<p></p></li>\n<li><b>Naming and name services.</b>\nUnique identifiers, pure and impure names.\n    Name spaces, naming domains, name resolution.\n    Large scale name services: DNS, X.500/LDAP, GNS.\n    Use of replication. Consistency-availability tradeoffs. \n    Design assumptions and future issues.\n\n<p></p></li>\n<li><b>Access control for multi-domain distributed systems.</b>\n Requirements from healthcare, police, emergency services, globally\n    distributed companies.\n    ACLs, capabilities, Role-Based Access Control (RBAC). Context aware \naccess control.\n    Examples: OASIS, CBCL OASIS, Microsoft Healthvault, ...     Authentication and authorisation: Raven, Shibboleth, OpenID.\n\n<p></p></li>\n<li><b>Distributed storage services. Summary and roundup.</b>\nNetwork-based storage services. Naming and access control. \nPeer-to-peer protocols. Content distribution. \nSummary and roundup. Open problems for future years: transactional main\nmemory; multicore concurrency control; untrusted components. Byzantine \nfailure.\n\n<p></p></li>\n\n\n<a name=\"SECTION03023700000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the need for concurrency control in operating systems\n  and applications, both mutual exclusion and condition\n  synchronisation;\n\n<p></p></li>\n<li>understand how multi-threading can be supported and the\n  implications of different approaches;\n\n<p></p></li>\n<li>be familiar with the support offered by various programming\n  languages for concurrency control and be able to judge the scope,\n  performance implications and possible applications of the various\n  approaches;\n\n<p></p></li>\n<li>be aware that dynamic resource allocation can lead to deadlock;\n\n<p></p></li>\n<li>understand the concept of transaction; the properties of\n  transactions, how concurrency control can be assured and how\n  transactions can be distributed;\n\n<p></p></li>\n<li>understand the fundamental properties of distributed systems and\n  their implications for system design;\n\n<p></p></li>\n<li>understand the effects of large scale on the provision of\n  fundamental services and the tradeoffs arising from scale;\n\n<p></p></li>\n<li>be familiar with a range of distributed algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03023800000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems: distributed and concurrent software design</em>. Addison-Wesley.\n<br/>Bacon, J. (1997). <em>Concurrent Systems</em>. Addison-Wesley.\n<br/>Tanenbaum, A.S. &amp; van Steen, M. (2002). <em>Distributed systems</em>. Prentice Hall.\n<br/>Coulouris, G.F., Dollimore, J.B. &amp; Kindberg, T. (2005, 2001). <em>Distributed systems, concepts and design</em>. Addison-Wesley (4th, 3rd eds.).\n\n\n",
    "course_name": "Concurrent and Distributed Systems",
    "course_code": "ConcDisSys",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/ConcDisSys",
    "lecturers": ["smh22"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": true,
    "easter": false
  },
  "ECAD+Arch": {
    "supervisions": 0,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": null,
    "course_name": "ECAD and Architecture Practical Classes",
    "course_code": "ECAD+Arch",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/ECAD+Arch",
    "lecturers": ["swm11", "rdm34"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "FJava": {
    "supervisions": 0,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": null,
    "course_name": "Further Java",
    "course_code": "FJava",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/FJava",
    "lecturers": ["arb33", "acr31"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "GroupProj": {
    "supervisions": 0,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": null,
    "course_name": "Group Project",
    "course_code": "GroupProj",
    "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/",
    "lecturers": ["iml1"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": true,
    "easter": false
  },
  "LogicProof": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html",
    "description": "\n\n\n<a name=\"SECTION03026100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03026200000000000000\">Lectures</a>\n\n<li><b>Introduction to logic.</b>\nSchematic statements.  Interpretations and validity.  Logical\nconsequence.  Inference.\n\n<p></p></li>\n<li><b>Propositional logic.</b>\nBasic syntax and semantics.  Equivalences.  Normal forms.\nTautology checking using CNF.\n\n<p></p></li>\n<li><b>The sequent calculus.</b>\nA simple (Hilbert-style) proof system.  Natural deduction systems.\nSequent calculus rules.  Sample proofs.\n\n<p></p></li>\n<li><b>First order logic.</b>\nBasic syntax.  Quantifiers.  Semantics (truth definition).\n\n<p></p></li>\n<li><b>Formal reasoning in FOL.</b>\nFree <em>versus</em> bound variables.  Substitution. Equivalences for\nquantifiers.  Sequent calculus rules.  Examples.\n\n<p></p></li>\n<li><b>Clausal proof methods.</b>\nClause form.  A SAT-solving procedure.  The resolution rule.\nExamples.  Refinements.\n\n<p></p></li>\n<li><b>Skolem functions and Herbrand\u2019s theorem.</b>\nPrenex normal form.  Skolemisation.  Herbrand models and their\nproperties.\n\n<p></p></li>\n<li><b>Unification.</b>\nComposition of substitutions.  Most general unifiers. A\nunification algorithm.  Applications and variations.\n\n<p></p></li>\n<li><b>Prolog.</b>\nBinary resolution.  Factorisation.  Example of Prolog\nexecution. Proof by model elimination.\n\n<p></p></li>\n<li><b>Binary decision diagrams.</b>\nGeneral concepts.  Fast canonical form algorithm.  Optimisations.\nApplications.\n\n<p></p></li>\n<li><b>Modal logics.</b>\nPossible worlds semantics.  Truth and validity.  A Hilbert-style\nproof system.  Sequent calculus rules.\n\n<p></p></li>\n<li><b>Tableaux methods.</b>\nSimplifying the sequent calculus.  Examples.  Adding unification.\nSkolemisation.  The world\u2019s smallest theorem prover?\n\n<p></p></li>\n\n\n<a name=\"SECTION03026300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to manipulate logical formulas accurately;\n\n<p></p></li>\n<li>be able to perform proofs using the presented formal calculi;\n\n<p></p></li>\n<li>be able to construct a small BDD;\n\n<p></p></li>\n<li>understand the relationships among the various calculi, e.g. SAT solving, resolution and Prolog;\n\n<p></p></li>\n<li>be able to apply the unification algorithm and to describe its uses.\n\n<p></p></li>\n\n\n<a name=\"SECTION03026400000000000000\">Recommended reading</a>\n\n* Huth, M. &amp; Ryan, M. (2004). <em>Logic in computer science: modelling and reasoning about systems</em>. Cambridge University Press (2nd ed.).\n<br/>Ben-Ari, M. (2001). <em>Mathematical logic for computer science</em>. Springer (2nd ed.).\n\n\n",
    "course_name": "Logic and Proof",
    "course_code": "LogicProof",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/LogicProof",
    "lecturers": ["lp15"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "MathMforCS": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MathematicalMethodsforComputerScience.html",
    "description": "\n\n\n<a name=\"SECTION03027100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03027200000000000000\">Lectures</a>\n\n<li>Part A: Fourier and related methods (Professor J. Daugman)\n  \n<ul><li><b>Fourier representations.</b>  Inner product spaces and orthonormal\n    systems. Periodic functions and Fourier series. Results and\n    applications. The Fourier transform and its properties. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Discrete Fourier methods.</b> The Discrete Fourier transform,\n    efficient algorithms implementing it, and applications.  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Wavelets.</b>  Introduction to wavelets, with applications in\n    signal processing, coding, communications, and computing. [1\u00a0lecture]\n  \n</li>\n</ul>\n</li>\n<li>Part B: Probability methods (Dr R.J. Gibbens)\n  \n<ul><li><b>Inequalities and limit theorems.</b>  Bounds on tail\n    probabilities, moment generating functions, notions of convergence,\n    weak and strong laws of large numbers, the central limit theorem,\n    statistical applications, Monte Carlo simulation. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Markov chains.</b>  Discrete-time Markov chains,\n    Chapman-Kolmogorov equations, classifications of states, limiting and\n    stationary behaviour, time-reversible Markov chains. Examples and\n    applications. [3\u00a0lectures]\n  \n</li>\n</ul>\n</li>\n\n\n<a name=\"SECTION03027300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the fundamental properties of inner product spaces\n  and orthonormal systems;\n\n<p></p></li>\n<li>grasp key properties and uses of Fourier series and transforms,\n  and wavelets;\n\n<p></p></li>\n<li>understand discrete transform techniques, algorithms, and applications;\n\n<p></p></li>\n<li>understand basic probabilistic inequalities and limit results\n  and be able to apply them to commonly arising models;\n\n<p></p></li>\n<li>be familiar with the fundamental properties and uses of\n  discrete-time Markov chains.\n\n<p></p></li>\n\n\n<a name=\"SECTION03027400000000000000\">Reference books</a>\n\n* Pinkus, A. &amp; Zafrany, S. (1997). <em>Fourier series and integral transforms</em>. Cambridge University Press.\n<br/>* Ross, S.M. (2002). <em>Probability models for computer science</em>. Harcourt/Academic Press.\n<br/>Mitzenmacher, M. &amp; Upfal, E. (2005). <em>Probability and computing: randomized algorithms and probabilistic analysis</em>. Cambridge University Press.\n<br/>Oppenheim, A.V. &amp; Willsky, A.S. (1997). <em>Signals and systems</em>.  Prentice\u00a0Hall.\n\n\n",
    "course_name": "Mathematical Methods for Computer Science",
    "course_code": "MathMforCS",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/MathMforCS",
    "lecturers": ["jgd1000", "rg31"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "CandC++": {
    "supervisions": null,
    "lectures": 8,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html",
    "description": "\n\n\n<a name=\"SECTION03028100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03028200000000000000\">Lectures</a>\n\n<li><b>Introduction to the C language.</b>  Background and goals of C.\n  Types and variables.  Expressions and statements.  Functions.\n  Multiple compilation units. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Further C concepts.</b>  Preprocessor. Pointers and pointer\n  arithmetic. Data structures. Dynamic memory management.  Examples.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Introduction to C++.</b>  Goals of C++. Differences between C\n  and C++. References <i>versus</i> pointers. Overloading functions.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Objects in C++.</b>  Classes and structs. Operator overloading.\n  Virtual functions. Multiple inheritance. Virtual base classes.\n  Examples. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Further C++ concepts.</b>  Exceptions. Templates and\n  meta-programming. Java Native Interface (JNI). Examples. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03028300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to read and write C and C++ programs;\n\n<p></p></li>\n<li>understand the interaction between C and C++ programs and the\n  host operating system;\n\n<p></p></li>\n<li>be familiar with the structure of C and C++ program execution in\n  machine memory;\n\n<p></p></li>\n<li>understand the object-oriented paradigm presented by C++;\n\n<p></p></li>\n<li>be able to make effective use of templates and meta-programming\n  techniques as used in the STL;\n\n<p></p></li>\n<li>understand the potential dangers of writing programs in C and C++.\n\n<p></p></li>\n\n\n<a name=\"SECTION03028400000000000000\">Recommended reading</a>\n\n* Eckel, B. (2000). <em>Thinking in C++, Vol.\u00a01: Introduction to Standard C++</em>. Prentice\u00a0Hall (2nd ed.).  Also available at\n<br/><a href=\"http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html\" name=\"tex2html8\"><tt>http://www.mindview.net/Books/TICPP/ThinkingInCPP2e.html</tt></a>\n<br/>Kernighan, B.W. &amp; Ritchie, D.M. (1988). <em>The C programming language</em>. Prentice\u00a0Hall (2nd ed.).\n<br/>Stroustrup, B. (2008). <em>Programming -- principles and practice using C++</em>. Addison-Wesley.\n<br/>Stroustrup, B. (1994). <em>The design and evolution of C++</em>. Addison-Wesley.\n<br/>Lippman, S.B. (1996). <em>Inside the C++ object model</em>. Addison-Wesley.\n\n\n",
    "course_name": "Programming in C and C++",
    "course_code": "CandC++",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CandC++",
    "lecturers": ["sc609"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "Prolog": {
    "supervisions": null,
    "lectures": 6,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-PrologforArtificialIntelligence.html",
    "description": "\n\n\n<a name=\"SECTION03029100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03029200000000000000\">Lectures</a>\n\n<li><b>Introduction to Prolog.</b>  The structure of a Prolog program\n  and how to use the Prolog interpreter.  Unification revisited. Some\n  simple programs.\n\n<p></p></li>\n<li><b>Arithmetic and lists.</b>  Prolog\u2019s support for evaluating\n  arithmetic expressions and lists.  The space complexity of program\n  evaluation discussed with reference to last-call optimisation.\n\n<p></p></li>\n<li><b>Backtracking, cut, and negation.</b>  The <tt>cut</tt> operator\n  for controlling backtracking.\n  <span class=\"textit\">Negation as failure</span> and its uses.\n\n<p></p></li>\n<li><b>Search and cut.</b>  Prolog\u2019s search method for solving\n  problems.  Graph searching exploiting Prolog\u2019s built-in\n  search mechanisms.\n\n<p></p></li>\n<li><b>Difference structures.</b>  Difference lists: introduction and\n  application to example programs.\n\n<p></p></li>\n<li><b>Building on Prolog.</b>  How particular limitations of Prolog\n  programs can be addressed by techniques such as Constraint Logic\n  Programming (CLP) and tabled resolution.\n\n<p></p></li>\n\n\n<a name=\"SECTION03029300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to write programs in Prolog using techniques such as\n  accumulators and difference structures;\n\n<p></p></li>\n<li>know how to model the backtracking behaviour of program\n  execution;\n\n<p></p></li>\n<li>appreciate the unique perspective Prolog gives to problem\n  solving and algorithm design;\n\n<p></p></li>\n<li>understand how larger programs can be created using the basic\n  programming techniques used in this course.\n\n<p></p></li>\n\n\n<a name=\"SECTION03029400000000000000\">Recommended reading</a>\n\n* Bratko, I. (2001). <i>PROLOG programming for artificial intelligence</i>. Addison-Wesley (3rd or 4th\u00a0ed.).\n<br/>Sterling, L. &amp; Shapiro, E. (1994). <i>The art of Prolog</i>. MIT Press (2nd\u00a0ed.).\n\nFurther reading:\n\nO\u2019Keefe, R. (1990). <i>The craft of Prolog</i>. MIT Press. [This book is beyond the scope of this course, but it is very instructive. If you understand its contents, you\u2019re more than prepared for the examination.]\n\n\n",
    "course_name": "Prolog",
    "course_code": "Prolog",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Prolog",
    "lecturers": ["de239"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "Semantics": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Semantics.html",
    "description": "\n\n\n<a name=\"SECTION030210100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030210200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Transition systems.  \n  The idea of structural operational semantics. \n  Transition semantics of a simple imperative language. \n  Language design options. \n[2 lectures]\n\n<p></p></li>\n<li><b>Types.</b>  Introduction to formal type systems.\n  Typing for the simple imperative language.\n  Statements of desirable properties.\n[2 lectures]\n\n<p></p></li>\n<li><b>Induction.</b>  Review of mathematical induction. Abstract\n  syntax trees and structural induction. Rule-based inductive\n  definitions and proofs. Proofs of type safety\n  properties. \n[2 lectures]\n\n<p></p></li>\n<li><b>Functions.</b>  Call-by-name and call-by-value function\n application, semantics and typing. Local recursive\n definitions. \n[2 lectures]\n\n<p></p></li>\n<li><b>Data.</b> Semantics and typing for products, sums, records,\nreferences.\n[1 lecture]\n\n<p></p></li>\n<li><b>Subtyping.</b>  Record subtyping and simple object encoding.\n[1 lecture]\n\n<p></p></li>\n<li><b>Semantic equivalence.</b>  Semantic equivalence of phrases in a\nsimple imperative language, including the congruence property.\nExamples of equivalence and non-equivalence.\n[1 lecture]\n\n<p></p></li>\n<li><b>Concurrency.</b>  Shared variable interleaving. Semantics for\nsimple mutexes; a serializability property.\n[1 lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION030210300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with rule-based presentations of the operational\n  semantics and type systems for some simple imperative, functional\n  and interactive program constructs;\n\n<p></p></li>\n<li>be able to prove properties of an operational semantics using\n  various forms of induction (mathematical, structural, and\n  rule-based);\n\n<p></p></li>\n<li>be familiar with some operationally-based notions of semantic\n  equivalence of program phrases and their basic properties.\n\n<p></p></li>\n\n\n<a name=\"SECTION030210400000000000000\">Recommended reading</a>\n\n* Pierce, B.C. (2002). <em>Types and programming languages</em>. MIT Press.\n<br/>Hennessy, M. (1990). <em>The semantics of programming languages</em>. Wiley. Out of print, but available on the web at <a href=\"http://www.scss.tcd.ie/Matthew.Hennessy/slexternal/reading.php\" name=\"tex2html9\"><tt>http://www.scss.tcd.ie/Matthew.Hennessy/slexternal/reading.php</tt></a>\n<br/>Winskel, G. (1993). <em>The formal semantics of programming languages</em>. MIT Press.\n\n\n",
    "course_name": "Semantics of Programming Languages",
    "course_code": "Semantics",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Semantics",
    "lecturers": ["ss368"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "SWEng": {
    "supervisions": null,
    "lectures": 6,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareEngineering.html",
    "description": "\n\n\n<a name=\"SECTION030211100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030211200000000000000\">Lectures</a>\n\n\n<li><b>The software crisis.</b>  \nExamples of large-scale project failure, such as the London Ambulance \nService system and the NHS National Programme for IT. Intrinsic \ndifficulties with software.\n\n<p></p></li>\n<li><b>The software life cycle.</b>\nGetting the requirements right; requirements analysis methods; modular \ndesign; the role of prototyping; the waterfall, spiral and evolutionary \nmodels.\n\n<p></p></li>\n<li><b>Critical systems.</b>\nExamples of catastrophic failure; particular problems with real-time\nsystems; usability and human error; verification and validation.\n\n<p></p></li>\n<li><b>Quality assurance.</b>\nThe contribution of reviews and testing; reliability growth models; software\nmaintenance and configuration management; life-cycle costs.\n\n<p></p></li>\n<li><b>Tools.</b>\nThe effect of high-level languages; object-oriented systems and \nobject reuse; an overview of formal methods with some application \nexamples; project planning tools; automated testing tools.\n\n<p></p></li>\n<li><b>Guest lecture.</b>\nA guest lecture from an industry speaker about the realities of\nmanaging software development in a commercial environment.\n\n<p></p></li>\n\n\n<a name=\"SECTION030211300000000000000\">Objectives</a>\n\nAt the end of the course students should know how writing programs\nwith tough assurance targets, in large teams, or both, differs from\nthe programming exercises they have engaged in so far. They should\nappreciate the waterfall, spiral and evolutionary models of software\ndevelopment and be able to explain which kinds of software project\nmight profitably use them. They should appreciate the value of other\ntools and the difference between incidental and intrinsic complexity.\nThey should understand the software development life cycle and its\nbasic economics. They should be prepared for the organizational\naspects of their Part\u00a0IB group project.\n\n\n<a name=\"SECTION030211400000000000000\">Recommended reading</a>\n\n* Pressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>Leveson, N. (1994). <i>Safeware</i>. Addison-Wesley.\n<br/>Maguire, S. (1993). <i>Writing solid code</i>. Microsoft Press.\n\nFurther reading:\n\nBrooks, F.P. (1975). <i>The mythical man month</i>. Addison-Wesley.\n<br/>Reason, J. (2008). <i>The human contribution</i>. Ashgate Publishing.\n<br/>Leveson, N. (2008). <i>System safety engineering: back to the future</i>, available at\n<br/><a href=\"http://sunnyday.mit.edu/book2.pdf\" name=\"tex2html10\"><tt>http://sunnyday.mit.edu/book2.pdf</tt></a>\n<br/>Neumann, P. (1994). <i>Computer-related risks</i>. ACM Press.\n<br/><i>Report of the inquiry into the London Ambulance Service</i> (SW Thames RHA, 40 Eastbourne Terrace, London W2 3QR, February 1993).\n<br/><a href=\"http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html\" name=\"tex2html11\"><tt>http://www.cs.ucl.ac.uk/staff/A.Finkelstein/las.html</tt></a>\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapters 25 and 26). Wiley. Alternatively see 2001 edition, Chapters 22 and 23, available at\n<br/><a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" name=\"tex2html12\"><tt>http://www.cl.cam.ac.uk/users/rja14/book.html</tt></a>\n\n",
    "course_name": "Software Engineering",
    "course_code": "SWEng",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/SWEng",
    "lecturers": ["rnc1"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "UnixTools": {
    "supervisions": null,
    "lectures": 10,
    "prerequisite_for": [],
    "past_exam_questions": null,
    "description": "\n\n\n<a name=\"SECTION030212100000000000000\">Aims</a>\n\n\n<a name=\"SECTION030212200000000000000\">Lectures</a>\n\n<li><b>Unix concepts.</b> Brief review of Unix history and design\n  philosophy, documentation, terminals, inter-process communication\n  mechanisms and conventions, shell, command-line arguments,\n  environment variables, file descriptors.\n\n<p></p></li>\n<li><b>Shell basics.</b> Program invocation, redirecting standard I/O,\n  pipes, file-system navigation, argument expansion, quoting, job\n  control, signals, process groups, variables, locale.\n\n<p></p></li>\n<li><b>Shell script programming and configuration.</b> Efficient\n  command entry with history and alias functions. Scripts, plain-text\n  file formats, control structures, functions. Customizing user\n  environments. Basics of <span class=\"textit\">X Window System</span> configuration. Some\n  notes on PWF Linux.\n\n<p></p></li>\n<li><b>Common tools.</b> Overview of common text, shell, and network\n  utilities and their most frequently used options, including sed,\n  grep, chmod, find, ssh, rsync, packaging and compression tools.\n\n<p></p></li>\n<li><b>Revision control systems.</b> diff, patch, RCS, Subversion, git.\n\n<p></p></li>\n<li><b>Software development tools.</b> C compiler, linker and\n  debugger, makefiles.\n\n<p></p></li>\n<li><b>Perl.</b> Introduction to a powerful scripting and text\n  manipulation language. [2\u00a0lectures]\n\n<p></p></li>\n<li><b><span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span>.</b> Typesetting basics, introduction to the most\n  popular tool for scientific document formatting.\n\n<p></p></li>\n<li><b>Number crunching and data visualization.</b> Use of MATLAB on\n  PWF machines.\n\n<p></p></li>\n\n\n<a name=\"SECTION030212300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be confident in performing routine user tasks on a POSIX system,\n  understand command-line user-interface conventions and know how to\n  find more detailed documentation;\n\n<p></p></li>\n<li>appreciate how a range of simple tools can be combined with\n  little effort in pipes and scripts to perform a large variety of\n  tasks;\n\n<p></p></li>\n<li>be familiar with the most common tools, file formats and\n  configuration practices;\n\n<p></p></li>\n<li>be able to understand, write, and maintain shell scripts and\n  makefiles;\n\n<p></p></li>\n<li>appreciate how using revision control systems and fully\n  automated build processes help to maintain reproducibility and\n  audit trails during software development;\n\n<p></p></li>\n<li>know enough about basic development tools to be able to install\n  and modify C source code;\n\n<p></p></li>\n<li>have gained experience in using Perl, <span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span> and MATLAB.\n\n<p></p></li>\n\n\n<a name=\"SECTION030212400000000000000\">Recommended reading</a>\n\n* Lamport, L. (1994). <em><span class=\"logo,LaTeX\">L<sup><small>A</small></sup>T<small>E</small>X</span> - a documentation preparation system user\u2019s guide and reference manual</em>. Addison-Wesley (2nd ed.).\n<br/>Robbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th ed.).\n<br/>Schwartz, R.L., Foy, B.D. &amp; Phoenix, T. (2011). <em>Learning Perl</em>. O\u2019Reilly (6th ed.).\n\n\n",
    "course_name": "Unix Tools",
    "course_code": "UnixTools",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/UnixTools",
    "lecturers": ["mgk25"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": true,
    "lent": false,
    "easter": false
  },
  "CompConstr": {
    "supervisions": null,
    "lectures": 16,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html",
    "description": "\n\n\n<a name=\"SECTION03031100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03031200000000000000\">Lectures</a>\n\n<li><b>Survey of execution mechanisms.</b>\n      The spectrum of interpreters and compilers; compile-time and run-time.\n      Structure of a simple compiler. Java virtual machine (JVM), JIT.\n      Simple run-time structures (stacks).\n      Structure of interpreters for result of each stage of compilation\n      (tokens, tree, bytecode).\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Lexical analysis and syntax analysis.</b>\n      Recall regular expressions and finite state machine acceptors.\n      Lexical analysis: hand-written and machine-generated.\n      Recall context-free grammars.\n      Ambiguity, left- and right-associativity and operator precedence.\n      Parsing algorithms: recursive descent and machine-generated.\n      Abstract syntax tree; expressions, declarations and commands.\n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Simple type-checking.</b>\n      Type of an expression determined by type of subexpressions;\n      inserting coercions.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Translation phase.</b>\n      Translation of expressions, commands and declarations.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Code generation.</b>\n      Typical machine codes.\n      Code generation from intermediate code.\n      Simple peephole optimisation.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Object modules, linkers and run-time system.</b>\n      Resolving external references.\n      Static and dynamic linking.\n      Malloc and system calls.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Non-local variable references.</b>\n      Lambda-calculus as prototype, Landin\u2019s principle of correspondence.\n      Problems with <tt>rec</tt> and class variables.\n      Environments, function values are closures.\n      Static and dynamic binding (scoping).\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Machine implementation of a selection of interesting things.</b>\n      Free variable treatment, static and dynamic chains, ML free variables.\n      Compilation as source-to-source simplification, e.g. closure conversion.\n      Argument passing mechanisms.\n      Objects and inheritance; implementation of methods.\n      Labels, <tt>goto</tt> and exceptions.\n      Dynamic and static typing, polymorphism.\n      Storage allocation, garbage collection.\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Parser Generators.</b>\n      A user-level view of Lex and Yacc.\n[1\u00a0lecture]\n\n<p></p></li>\n<li><b>Parsing theory and practice.</b>\n      Phrase Structured Grammars.\n      Chomsky classification.\n      LL(k) and LR(k) parsing.\n      How tools like Yacc generate parsers, and their error messages.\n[2\u00a0lectures]\n</li>\n\n\n<a name=\"SECTION03031300000000000000\">Objectives</a>\n\nAt the end of the course students should understand the overall\nstructure of a compiler, and will know significant details of a number\nof important techniques commonly used. They will be aware of the way\nin which language features raise challenges for compiler builders.\n\n\n<a name=\"SECTION03031400000000000000\">Recommended reading</a>\n\n* Appel, A. (1997). <em>Modern compiler implementation in Java/C/ML</em> (3 editions). Cambridge University Press.\n<br/>Aho, A.V., Sethi, R. &amp; Ullman, J.D. (2007). <em>Compilers: principles, techniques and tools</em>. Addison-Wesley (2nd ed.).\n<br/>Bennett, J.P. (1990). <em>Introduction to compiling techniques: a first course using ANSI C, LEX and YACC</em>. McGraw-Hill.\n<br/>Bornat, R. (1979). <em>Understanding and writing compilers</em>. Macmillan.\n<br/>Fischer, C.N. &amp; LeBlanc, J. Jr (1988). <em>Crafting a compiler</em>. Benjamin/Cummings.\n<br/>Watson, D. (1989). <em>High-level languages and their compilers</em>. Addison-Wesley.\n\n\n\n",
    "course_name": "Compiler Construction",
    "course_code": "CompConstr",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompConstr",
    "lecturers": ["djg11"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "Complexity": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Complexity.html",
    "description": "\n\n\n<a name=\"SECTION03032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03032200000000000000\">Lectures</a>\n\n<li><b>Algorithms and problems.</b>\nComplexity of algorithms and of problems.  Lower and upper bounds.\nExamples: sorting and travelling salesman.\n\n<p></p></li>\n<li><b>Time and space.</b>\nModels of computation and measures of complexity.  Time and space\ncomplexity on a Turing machine. Decidability and complexity.\n\n<p></p></li>\n<li><b>Time complexity.</b>\nTime complexity classes.  Polynomial time problems and algorithms.  P\nand NP. \n\n<p></p></li>\n<li><b>Non-determinism.</b>\nNon-deterministic machines.  The class NP redefined.  Non-deterministic\nalgorithms for reachability and satisfiability.\n\n<p></p></li>\n<li><b>NP-completeness.</b>\nReductions and completeness.  NP-completeness of satisfiability.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nGraph-theoretic problems.  Hamiltonian cycle and clique.\n\n<p></p></li>\n<li><b>More NP-complete problems.</b>\nSets, numbers and scheduling.  Matching, set covering and bin packing.\n\n<p></p></li>\n<li><b>coNP.</b>\nValidity of boolean formulae and its\ncompleteness.  NP<span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$\\cap$\" border=\"0\" height=\"21\" src=\"img1.png\" width=\"17\"/></span>coNP.  Primality and factorisation.\n\n<p></p></li>\n<li><b>Cryptographic complexity.</b>\nOne-way functions.  The class UP.\n\n<p></p></li>\n<li><b>Space complexity.</b>\nDeterministic and non-deterministic space complexity classes.  The\nreachability method.  Savitch\u2019s theorem.\n\n<p></p></li>\n<li><b>Hierarchy.</b>\nThe time and space hierarchy theorems and complete problems.\n\n<p></p></li>\n<li><b>Descriptive complexity.</b>\nLogics capturing complexity classes.  Fagin\u2019s theorem.\n\n<p></p></li>\n\n\n<a name=\"SECTION03032300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse practical problems and classify them\naccording to their complexity;\n\n<p></p></li>\n<li>be familiar with the phenomenon of NP-completeness, and be able\nto identify problems that are NP-complete;\n\n<p></p></li>\n<li>be aware of a variety of complexity classes and their\ninterrelationships;\n\n<p></p></li>\n<li>understand the role of complexity analysis in cryptography.\n\n<p></p></li>\n\n\n<a name=\"SECTION03032400000000000000\">Recommended reading</a>\n\n* Papadimitriou, Ch.H. (1994).  <em>Computational complexity</em>. Addison-Wesley.\n<br/>Goldreich, O. (2008). <em>Computational complexity: a conceptual perspective</em>. Cambridge University Press.\nSipser, M. (1997). <em>Introduction to the theory of computation</em>. PWS.\n\n\n",
    "course_name": "Complexity Theory",
    "course_code": "Complexity",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Complexity",
    "lecturers": ["ad260"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "CompTheory": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html",
    "description": "\n\n\n<a name=\"SECTION03033100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03033200000000000000\">Lectures</a>\n\n<li><b>Introduction: algorithmically undecidable problems.</b>\n  Decision problems. The informal notion of algorithm, or effective\n  procedure. Examples of algorithmically undecidable problems. [1\n  lecture]\n\n<p></p></li>\n<li><b>Register machines.</b> Definition and examples; graphical\n  notation.  Register machine computable functions.  Doing arithmetic\n  with register machines. [1 lecture]\n\n<p></p></li>\n<li><b>Universal register machine.</b>  Natural number encoding of\n  pairs and lists.  Coding register machine programs as numbers.\n  Specification and implementation of a universal register\n  machine. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Undecidability of the halting problem.</b>  Statement and\n  proof. Example of an uncomputable partial function. Decidable sets\n  of numbers; examples of undecidable sets of numbers.  [1 lecture]\n\n<p></p></li>\n<li><b>Turing machines.</b> Informal description.  Definition and\n  examples.  Turing computable functions. Equivalence of register\n  machine computability and Turing computability. The Church-Turing\n  Thesis. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Primitive and partial recursive functions.</b> Definition and\n  examples.  Existence of a recursive, but not primitive recursive\n  function. A partial function is partial recursive if and only if it\n  is computable. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>lambda-Calculus.</b> Alpha and beta conversion.\n  Normalization. Encoding data. Writing recursive functions in the\n  lambda-calculus. The relationship between computable functions\n  and lambda-definable functions. [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03033300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with the register machine, Turing machine and\n  lambda-calculus models of computability;\n\n<p></p></li>\n<li>understand the notion of coding programs as data, and of a universal\n  machine;\n\n<p></p></li>\n<li>be able to use diagonalisation to prove the undecidability of\n  the Halting Problem;\n\n<p></p></li>\n<li>understand the mathematical notion of partial recursive function\n  and its relationship to computability.\n\n<p></p></li>\n\n\n<a name=\"SECTION03033400000000000000\">Recommended reading</a>\n\n* Hopcroft, J.E., Motwani, R. &amp; Ullman, J.D. (2001). <em>Introduction to automata theory, languages, and computation</em>. Addison-Wesley (2nd ed.). \n<br/>* Hindley, J.R. &amp; Seldin, J.P. (2008). <em>Lambda-calculus and combinators, an introduction</em>. Cambridge University Press (2nd ed.).\n<br/>Cutland, N.J. (1980). <em>Computability: an introduction to recursive function theory</em>. Cambridge University Press.\n<br/>Davis, M.D., Sigal, R. &amp; Weyuker, E.J. (1994). <em>Computability, complexity and languages</em>. Academic Press (2nd ed.).\n<br/>Sudkamp, T.A. (2005). <em>Languages and machines</em>. Addison-Wesley (3rd ed.).\n\n\n",
    "course_name": "Computation Theory",
    "course_code": "CompTheory",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompTheory",
    "lecturers": ["amp12"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "CompGraph": {
    "supervisions": null,
    "lectures": 16,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerGraphicsandImageProcessing.html",
    "description": "\n\n\n<a name=\"SECTION03034100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03034200000000000000\">Lectures</a>\n\n<li><b>Background.</b>  What is an image? What are computer graphics,\n  image processing, and computer vision? How do they relate to one\n  another?  Image capture. Image display. Human vision. Resolution and\n  quantisation.  Colour and colour spaces.  Storage of images in\n  memory, and double buffering.  Display devices: the inner workings\n  of CRTs, LCDs, and printers.  [3\u00a0lectures]\n\n<p></p></li>\n<li><b>2D Computer graphics.</b>  Drawing a straight line. Drawing\n  circles and ellipses.  Cubic curves: specification and drawing.\n  Clipping lines. Filling polygons. Clipping polygons. 2D\n  transformations, vectors and matrices, homogeneous co-ordinates.\n  Uses of 2D graphics: HCI, typesetting, graphic design.  [5\u00a0lectures]\n\n<p></p></li>\n<li><b>3D Computer graphics.</b>  Projection: orthographic and\n  perspective. 3D transforms and matrices. 3D clipping. 3D curves.  3D\n  scan conversion. <em>z</em>-buffer. A-buffer.  Ray tracing.  Lighting:\n  theory, flat shading, Gouraud, Phong.  Texture mapping.\n  [5\u00a0lectures]\n\n<p></p></li>\n<li><b>Image processing.</b>  Operations on images: filtering, point\n  processing, compositing.  Halftoning and dithering, error diffusion.\n  Encoding and compression: difference encoding, predictive, run\n  length, transform encoding (including JPEG).  [3\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03034300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>explain the basic function of the human eye and how this\n  impinges on resolution, quantisation, and colour representation for\n  digital images; describe a number of colour spaces and their\n  relative merits; explain the workings of cathode ray tubes, liquid\n  crystal displays, and laser printers;\n\n<p></p></li>\n<li>describe and explain the following algorithms: Bresenham\u2019s line\n  drawing, mid-point line drawing, mid-point circle drawing, Bezier\n  cubic drawing, Douglas and Pucker\u2019s line chain simplification,\n  Cohen-Sutherland line clipping, scanline polygon fill,\n  Sutherland-Hodgman polygon clipping, depth sort, binary space\n  partition tree, <em>z</em>-buffer, A-buffer, ray tracing, error\n  diffusion;\n\n<p></p></li>\n<li>use matrices and homogeneous coordinates to represent and\n  perform 2D and 3D transformations; understand and use 3D to 2D\n  projection, the viewing volume, and 3D clipping;\n\n<p></p></li>\n<li>understand Bezier curves and patches; understand sampling and\n  super-sampling issues; understand lighting techniques and how they\n  are applied to both polygon scan conversion and ray tracing;\n  understand texture mapping;\n\n<p></p></li>\n<li>explain how to use filters, point processing, and arithmetic\n  operations in image processing and describe a number of examples of\n  the use of each; explain how halftoning, ordered dither, and error\n  diffusion work; understand and be able to explain image compression\n  and the workings of a number of compression techniques.\n\n<p></p></li>\n\n\n<a name=\"SECTION03034400000000000000\">Recommended reading</a>\n\n* Foley, J.D., van Dam, A., Feiner, S.K. &amp; Hughes, J.F. (1990). <em>Computer graphics: principles and practice</em>. Addison-Wesley (2nd ed.).\n<br/>Gonzalez, R.C. &amp; Woods, R.E. (2008). <em>Digital image processing</em>. Addison-Wesley (3rd ed). [The second edition (1992) and the first edition (Gonzalez &amp; Wintz, 1977) are as useful for this course.]\n<br/>* Slater, M., Steed, A. &amp; Chrysanthou, Y. (2002). <em>Computer graphics and virtual environments: from realism to real-time</em>.  Addison-Wesley.\n\n\n",
    "course_name": "Computer Graphics and Image Processing",
    "course_code": "CompGraph",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompGraph",
    "lecturers": ["pr10"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "CompNet": {
    "supervisions": null,
    "lectures": 24,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html",
    "description": "\n\n\n<a name=\"SECTION03035100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03035200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>\nOverview of networking using the Internet as an example. LANs and\nWANs. OSI reference model, Internet TCP/IP Protocol Stack.  Client/server\nparadigm, circuit-switching, packet-switching, Internet structure,\nnetworking delays and packet loss. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Application layer.</b>\nService requirements, WWW, HTTP, electronic mail, Domain Name System,\nP2P, socket programming API. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Transport layer.</b>\nService models, multiplexing/demultiplexing, connection-less transport\n(UDP), principles of reliable data transfer, connection-oriented\ntransport (TCP), TCP congestion control, TCP variants. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer addressing.</b>\nNetwork layer services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\n [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network layer routing.</b>\nRouting and forwarding, routing algorithms, routing in the Internet,\nRIP, OSPF, BGP, multicast. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Link layer and local area networks.</b>\nLink layer services, error detection and correction, Multiple Access\nProtocols, link layer addressing, Ethernet, hubs and switches,\nPoint-to-Point Protocol. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Wireless and mobile networks.</b>\nWireless links and network characteristics, Wi-Fi: IEEE 802.11 wireless\nLANs, mobility management and mobile IP. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Multimedia networking.</b>\nNetworked multimedia applications, best-effort service and multimedia\ndelivery requirements, multimedia protocols (RTSP, RTP, RTCP, SIP),\ncontent distribution networks.  [3\u00a0lectures]\n\n<p></p></li>\n<li><b>Network security and network management.</b>\nCryptography, integrity, securing email, securing TCP (SSL), firewalls\nand IDS, network management components, Internet management framework,\npresentation services. [1\u00a0lecture]\n\n<p></p></li>\n\n\n<a name=\"SECTION03035300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to analyse a communication system by separating out the\ndifferent functions provided by the network;\n\n<p></p></li>\n<li>understand that there are fundamental limits to any communications \nsystem;\n\n<p></p></li>\n<li>understand the general principles behind multiplexing, addressing,\nrouting, reliable transmission and other stateful protocols as well as\nspecific examples of each;\n\n<p></p></li>\n<li>understand what FEC is and how CRCs work;\n\n<p></p></li>\n<li>be able to compare communications systems in how they solve\nsimilar problems;\n\n<p></p></li>\n<li>have an informed view of both the internal workings of the\n  Internet and of a number of common Internet applications and\n  protocols.\n\n<p></p></li>\n\n\n<a name=\"SECTION03035400000000000000\">Recommended reading</a>\n\n* Kurose, J.F. &amp; Ross, K.W. (2009). <em>Computer networking: a top-down approach</em>. Addison-Wesley (5th ed.).\n<br/>Peterson, L.L. &amp; Davie, B.S. (2011). <em>Computer networks: a systems approach</em>. Morgan Kaufmann (5th ed.). ISBN 9780123850591\n<br/>Comer, D. &amp; Stevens, D. (2005). <em>Internetworking with TCP-IP, vol. </em>1<em> and </em>2. Prentice\u00a0Hall (5th ed.).\n<br/>Stevens, W.R., Fenner, B. &amp; Rudoff, A.M. (2003). <em>UNIX network programming, Vol.I: The sockets networking API</em>. Prentice\u00a0Hall (3rd ed.).\n\n\n",
    "course_name": "Computer Networking",
    "course_code": "CompNet",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompNet",
    "lecturers": ["awm22"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "Databases": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html",
    "description": "\n\n\n<a name=\"SECTION03036100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03036200000000000000\">Lectures</a>\n\n\n<li><b>Introduction.</b>\nWhat is a database system? \nDatabase systems are more than just a collection of data. \nThree level architecture. \nOnLine Transaction Processing (OLTP) <span class=\"textit\">versus</span> \nOnLine Analytic Processing (OLAP). \n\n<p></p></li>\n<li><b>The relational data model.</b> \nRelations are sets of records. \nRepresenting entities and relationships as relations. \nQueries as derived relations. \nRelations are the basis of SQL (but note the use of multi-sets). \n\n<p></p></li>\n<li><b>Entity-Relationship (E/R) modelling.</b>\nA bit of set theory. \nEntities have attributes. \nRelations have <em>arity</em>. \nDatabase design and data modelling. \n\n<p></p></li>\n<li><b>Relational algebra and relational calculus.</b>\nRelational algebra as an abstract query language. \nCore operations - selection, projection, product, renaming, and joins. \nRelational calculus as an abstract query language \n that uses notation from set theory. \nEquivalence with relational algebra. \n\n<p></p></li>\n<li><b>SQL and integrity constraints.</b>\nAn overview of the core of SQL. \nSQL has constructs taken from both the relational algebra\n and the relational calculus. \nIntegrity constraints as special queries, often required to yield a null result. \n\n<p></p></li>\n<li><b>Case Study - Cancer registry for the NHS - challenges.</b> ECRIC is \na cancer registry, recording details about all tumours in people in the \nEast of England. This data is particularly sensitive, and its use is \nstrictly controlled. The lecture focusses on the challenges of scaling up \nthe registration system to cover all cancer patients in England, while \nstill maintaining the long term accuracy and continuity of the data set.\n\n<p></p></li>\n<li><b>Schema refinement I.</b> \nThe evils of redundancy. \nThe benefits of redundancy. \nFunctional dependencies (FDs) as a formal means of investigating\n redundancy. \nRelational decomposition. \nArmstrong\u2019s axioms and Heath\u2019s Rule. \n\n<p></p></li>\n<li><b>Schema refinement II and Normal Forms.</b> \nSchema normalisation. \nFirst and Second normal form.  \nThird normal form and Boyce-Codd normal form. \nMulti-valued dependencies (MVDs) and lossless-join decomposition. \nFourth normal form. \n\n<p></p></li>\n<li><b>Schema refinement III and advanced design.</b> \nGeneral Decomposition Method (GDM). Decomposition examples.\nGDM always preserves lossless-join decomposition. \nGDM may not preserve functional dependencies.\nWeak entity sets. Ternary or multiple binary relationships?\n\n<p></p></li>\n<li><b>On-line Analytical Processing (OLAP).</b>  \nWhen to forget about data normalisation. \nBeware of buzz-words and the Data Warehouse Death March. \nMore on OLTP <span class=\"textit\">versus</span> OLAP. \nWhat is a <em>data cube</em>? \nData modelling for data warehouses: <em>star schema</em>. \n\n<p></p></li>\n<li><b>Case Study - Cancer registry for the NHS - experiences.</b>\nThe extension of ECRIC to cover all of England requires the integration of data from seven other regions, each of which has developed its own database schema.\nJem Rashbass has a long track record in NHS IT, and is now CEO of ECRIC, making him the DB customer.\nHe will explain what\u2019s needed and why - some of the existing challenges and future opportunities.  \nThe session will close with an open forum in which the DBA of the now national level Cancer Registry DBMS will join Jem.\n\n<p></p></li>\n<li><b>XML as a data exchange format.</b> \nWhat is XML? \nXML can be used to share data between proprietary relational databases. \nXML-based databases? \n\n<p></p></li>\n\n\n<a name=\"SECTION03036300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to design entity-relationship diagrams to represent simple\ndatabase application scenarios;\n\n<p></p></li>\n<li>know how to convert entity-relationship diagrams to relational \ndatabase schemas in the standard Normal Forms;\n\n<p></p></li>\n<li>be able to program simple database applications in SQL;\n\n<p></p></li>\n<li>understand the basic theory of the relational model and both its\nstrengths and weaknesses;\n\n<p></p></li>\n<li>be familiar with various recent trends in the database area.\n\n<p></p></li>\n\n\n<a name=\"SECTION03036400000000000000\">Recommended reading</a>\n\n* Silberschatz, A., Korth, H.F. &amp; Sudarshan, S. (2002). <em>Database system concepts</em>. McGraw-Hill (4th ed.).\n<br/>Ullman, J. &amp; Widom, J. (1997). <em>A first course in database systems</em>. Prentice Hall.\n<br/>Date, C.J. (2004). <em>An introduction to database systems</em>. Addison-Wesley (8th ed.).\n<br/>Miszczyk, J. and others (1998). <em>Mastering data warehousing functions</em>. (IBM Redbook DB2/400) Chapters 1 &amp; 2 only.  <a href=\"http://www.wminformatica.com/PDFs/DB2400-Mastering Data Warehousing.pdf\" name=\"tex2html14\"><tt>http://www.wminformatica.com/PDFs/DB2400-Mastering Data Warehousing.pdf</tt></a>\n<br/>Garcia-Molina, H. <em>Data warehousing and OLAP</em>. Stanford University. <tt><a href=\"http://www.cs.uh.edu/~ceick/6340/dw-olap.ppt\" name=\"tex2html13\">http://www.cs.uh.edu/~ceick/6340/dw-olap.ppt</a></tt>\n\n",
    "course_name": "Databases",
    "course_code": "Databases",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Databases",
    "lecturers": ["km10"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": true,
    "easter": false
  },
  "ArtIntI": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligence.html",
    "description": "\n\n\n<a name=\"SECTION03041100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03041200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b> Alternate ways of thinking about\n  AI. <span class=\"textit\">Agents</span> as a unifying view of AI systems. The basic\n  structure of an agent. Interaction of an agent with the\n  environment. Assessment of agents. What does this course cover, and\n  what is left out?  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Search I.</b> How can search serve as a fundamental\n  paradigm for intelligent problem-solving? Simple, <span class=\"textit\">uninformed\n  search</span> algorithms. Tree search and graph search. More\n  sophisticated <span class=\"textit\">heuristic search</span> algorithms. The\n  A* algorithm and its properties. Improving memory\n  efficiency: the A* and recursive best first search\n  algorithms. Local search and gradient descent. \n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Search II.</b> Search in an adversarial\n  environment. Computer game playing. The minimax algorithm and its\n  shortcomings. Improving minimax using alpha-beta pruning.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Constraint satisfaction problems (CSPs).</b> Standardising\n  search problems to a common format. The backtracking algorithm for\n  CSPs.  Heuristics for improving the search for a solution. Forward\n  checking, constraint propagation and arc consistency. Backtracking,\n  backjumping using Gaschnig\u2019s algorithm, graph-based backjumping.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning I.</b> How can we\n  represent and deal with commonsense knowledge and other forms of\n  knowledge? Semantic networks, frames and rules. How can we use\n  inference in conjunction with a knowledge representation scheme to\n  perform reasoning about the world and thereby to solve problems?\n  Inheritance, forward and backward chaining. [1\u00a0lectures]\n\n<p></p></li>\n<li><b>Knowledge representation and reasoning II.</b> Knowledge\n  representation and reasoning using first order logic. The frame,\n  qualification and ramification problems.  The situation\n  calculus. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Planning.</b> Methods for planning in advance how to solve a\n  problem. The STRIPS language. Achieving preconditions, backtracking\n  and fixing threats by promotion or demotion: the partial-order\n  planning algorithm. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Learning.</b> A brief introduction to supervised learning from\n  examples. Learning as fitting a curve to data. The\n  perceptron. Learning by gradient descent. Multilayer perceptrons and\n  the backpropagation algorithm. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION03041300000000000000\">Objectives</a>\n\nAt the end of the course students should:\n\n\n<li>appreciate the distinction between the popular view of the field\nand the actual research results;\n\n<p></p></li>\n<li>appreciate the fact that the computational complexity of most AI\n  problems requires us regularly to deal with approximate techniques;\n\n<p></p></li>\n<li>appreciate different perspectives on what the problems of\nartificial intelligence are and how different approaches are\njustified;\n\n<p></p></li>\n<li>be able to design basic problem solving methods based on\n  AI-based search, knowledge representation, reasoning, planning, and\n  learning algorithms.\n\n<p></p></li>\n\n\n<a name=\"SECTION03041400000000000000\">Recommended reading</a>\n\nThe recommended text is:\n\n* Russell, S. &amp; Norvig, P. (2010). <em>Artificial intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd ed.).\n<br/>There are many good books available on artificial intelligence; one \nalternative is:\n\nPoole, D. L. &amp; Mackworth, A. K. (2010). <em>Artificial intelligence: foundations of computational agents</em>.  Cambridge University Press.\n\nFor some of the material you might find it useful to consult more \nspecialised texts, in particular:\n\nDechter, R. (2003). <span class=\"textit\">Constraint processing</span>. Morgan Kaufmann.\n<br/>Cawsey, A. (1998). <em>The essence of artificial intelligence</em>. Prentice\u00a0Hall.\n<br/>Ghallab, M., Nau, D. &amp; Traverso, P. (2004). <span class=\"textit\">Automated planning: theory and practice</span>. Morgan Kaufmann.\n<br/>Bishop, C.M. (2006). <em>Pattern recognition and machine learning</em>. Springer.\n<br/>\n",
    "course_name": "Artificial Intelligence\u00a0I",
    "course_code": "ArtIntI",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/ArtIntI",
    "lecturers": ["sbh11"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": false,
    "easter": true
  },
  "ConceptsPL": {
    "supervisions": null,
    "lectures": 8,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConceptsinProgrammingLanguages.html",
    "description": "\n\n\n<a name=\"SECTION03042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03042200000000000000\">Lectures</a>\n\n<li><b>Introduction, motivation, and overview.</b>\nWhat is a programming language?  Application domains in language \ndesign.  Program execution models.  Theoretical foundations. \nLanguage standardization.  History.\n\n<p></p></li>\n<li><b>The first procedural language: FORTRAN\u00a0(1954-58).</b>\nExecution model.  Data types.  Control structures.  Storage.\nSubroutines and functions.  Parameter passing.\n\n<p></p></li>\n<li><b>The first declarative language: LISP\u00a0(1958-62).</b>\nExpressions, statements, and declarations.  S-expressions and\nlists.  Recursion.  Static and dynamic scope.  Abstract \nmachine.  Garbage collection.  Programs as data.  Parameter \npassing.  Strict and lazy evaluation.\n\n<p></p></li>\n<li><b>Block-structured procedural languages: Algol\u00a0(1958-68) \nand Pascal\u00a0(1970).</b>\nBlock structure.  \nParameters and parameter passing.  Stack and heap storage. \nData types.  Arrays and pointers.\n\n<p></p></li>\n<li><b>Object-oriented languages -- Concepts and origins:\nSimula\u00a0(1964-67) and Smalltalk\u00a0(1971-80).</b>\nDynamic lookup.  Abstraction.  Subtyping.  Inheritance.  Object \nmodels.\n\n<p></p></li>\n<li><b>Types.</b>\nTypes in programming languages.  Type systems.  Type safety.  \nType checking and type inference.  Polymorphism.  Overloading.  \nType equivalence. \n\n<p></p></li>\n<li><b>Data abstraction and modularity: SML Modules\u00a0(1984-97).</b>\nInformation hiding.  Modularity.  Signatures, structures, and functors. \nSharing.\n\n<p></p></li>\n<li><b>The state of the art: Scala\u00a0(2004-06).</b>\nProcedural and declarative aspects.  Blocks and functions.  Classes \nand objects.  Generic types and methods.  Variance annotations.  \nMixin-class composition.\n</li>\n\n\n<a name=\"SECTION03042300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be familiar with several \nlanguage paradigms and how they relate to different application\n   domains;\n\n<p></p></li>\n<li>understand the design space of programming languages, including\n   concepts and constructs from past \nlanguages as well as those that may be used \nin the future;\n\n<p></p></li>\n<li>develop a critical understanding of the programming languages that\n   we use by being able to identify and compare the same concept as it\n   appears in different languages.\n\n<p></p></li>\n\n\n<a name=\"SECTION03042400000000000000\">Recommended reading</a>\n\nBooks:\n\n* Mitchell, J.C. (2003). <em>Concepts in programming languages</em>. Cambridge University Press.\n<br/>* Scott, M.L. (2009). <em>Programming language pragmatics</em>.  Morgan Kaufmann.\nOdersky, M. (2008). <em>Scala by example</em>. Programming Methods Laboratory, EPFL.\n<br/>Pratt, T.W. &amp; Zelkowitz, M.V. (2001). <em>Programming languages: design and implementation</em>.  Prentice Hall.\n\nPapers:\n\nKay, A.C. (1993).  \n  The early history of Smalltalk.  \n  <em>ACM SIGPLAN Notices</em>, Vol.\u00a028, No.\u00a03.\n<br/>Kernighan, B. (1981).  \n  Why Pascal is not my favorite programming language.  \n  AT&amp;T Bell Laboratories.  \n  <em>Computing Science Technical Report</em> No.\u00a0100.\n<br/>Koenig, A. (1994).  \n  An anecdote about ML type inference.  \n  <em>USENIX Symposium on Very High Level Languages</em>.\n<br/>Landin, P.J. (1966).\n  The next 700 programming languages.\n  <em>Communications of the ACM</em>, Vol.\u00a09, Issue\u00a03.\n<br/>Odersky, M. <em>et al.</em> (2006).\n  An overview of the Scala programming language.\n  <em>Technical Report LAMP-REPORT-2006-001</em>, Second Edition.\n<br/>McCarthy, J. (1960).  \n  Recursive functions of symbolic expressions and their computation \n  by machine.  \n  <em>Communications of the ACM</em>, 3(4):184-195.\n<br/>Stroustrup, B. (1991). \n  What is Object-Oriented Programming?  (1991 revised version). \n  <em>Proceedings\u00a01st European Software Festival</em>.\n\n\n",
    "course_name": "Concepts in Programming Languages",
    "course_code": "ConceptsPL",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/ConceptsPL",
    "lecturers": ["am21"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": false,
    "easter": true
  },
  "EconLaw": {
    "supervisions": null,
    "lectures": 8,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsandLaw.html",
    "description": "\n\n\n<a name=\"SECTION03043100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03043200000000000000\">Lectures</a>\n\n<li><b>Game theory.</b> The choice between cooperation and conflict. \nPrisoners\u2019 Dilemma; Nash equilibrium; hawk-dove; iterated games; \nevolution of strategies; application to biology and computer science.\n\n<p></p></li>\n<li><b>Classical economics.</b> Brief history of economics. \nDefinitions: preference, utility, choice and budget. Pareto\nefficiency; the discriminating monopolist. Welfare and the Arrow\ntheorem.\n\n<p></p></li>\n<li><b>Classical economics continued.</b> Supply and demand; \nelasticity; utility; the marginalist revolution; competitive\nequilibrium. Trade; monopoly rents; public goods; oligopoly. The\nbusiness cycle.\n\n<p></p></li>\n<li><b>Market failure.</b> Asymmetric information: the market for \nlemons; adverse selection; moral hazard; signalling; and brands.\nTransaction costs and the theory of the firm. Behavioural economics:\nbounded rationality, heuristics and biases.\n\n<p></p></li>\n<li><b>Auctions.</b> English auctions; Dutch auctions; all-pay\nauctions; Vickrey auctions. The winner\u2019s curse. The revenue\nequivalence theorem.  Mechanism design and the combinatorial\nauction. Problems with real auctions. Applicability of auction\nmechanisms in computer science.\n\n<p></p></li>\n<li><b>Principles of law.</b> Contract and tort; copyright and patent; \nbinding actions; liabilities and remedies; competition law; choice of\nlaw and jurisdiction.\n\n<p></p></li>\n<li><b>Law and the Internet.</b> EU directives including distance \nselling, electronic commerce, data protection, electronic signatures \nand copyright; their UK implementation. UK laws that specifically\naffect the Internet, including RIP.\n\n<p></p></li>\n<li><b>Network economics.</b> Real and virtual networks, supply-side \n<em>versus</em> demand-side scale economies, Metcalfe\u2019s law, the dominant firm\nmodel, price discrimination. Regulatory and other public policy issues\nof information goods and services markets.\n\n<p></p></li>\n\n\n<a name=\"SECTION03043300000000000000\">Objectives</a>\n\nAt the end of the course students should have a basic appreciation of\neconomic and legal terminology and arguments. They should understand\nsome of the applications of economic models to systems engineering and\ntheir interest to theoretical computer science. They should also\nunderstand the main constraints that markets and legislation place on\nfirms dealing in information goods and services.\n\n\n<a name=\"SECTION03043400000000000000\">Recommended reading</a>\n\n* Shapiro, C. &amp; Varian, H. (1998). <em>Information rules</em>. Harvard Business School Press.\n<br/>Varian, H. (1999). <em>Intermediate microeconomics - a modern approach</em>. Norton.\n\nFurther reading:\n\nSmith, A. (1776). <i>An inquiry into the nature and causes of the wealth of \nnations</i>, available at\u00a0\u00a0\u00a0\u00a0<a href=\"http://www.econlib.org/LIBRARY/Smith/smWN.html\" name=\"tex2html15\"><tt>http://www.econlib.org/LIBRARY/Smith/smWN.html</tt></a>\n<br/>Poundstone, W. (1992). <i>Prisoner\u2019s dilemma</i>. Anchor Books.\n<br/>Levitt, S.D. &amp; Dubner, S.J. (2005). <i>Freakonomics</i>. Morrow.\n<br/>Seabright, P. (2005). <i>The company of strangers</i>. Princeton.\n<br/>Anderson, R. (2008). <em>Security engineering</em> (Chapter 7). Wiley.\n<br/>Galbraith, J.K. (1991). <i>A history of economics</i>. Penguin.\n<br/>Lessig L. (2005). <i>Code and other laws of cyberspace v2</i>, available at\n<br/><a href=\"http://www.lessig.org/\" name=\"tex2html16\"><tt>http://www.lessig.org/</tt></a>\n\n",
    "course_name": "Economics and Law",
    "course_code": "EconLaw",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/EconLaw",
    "lecturers": ["rja14"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": false,
    "easter": true
  },
  "SecurityI": {
    "supervisions": null,
    "lectures": 12,
    "prerequisite_for": [],
    "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SecurityI.html",
    "description": "\n\n\n<a name=\"SECTION03044100000000000000\">Aims</a>\n\n\n<a name=\"SECTION03044200000000000000\">Lectures</a>\n\n<li><b>Cryptography.</b> Introduction, terminology, finite rings and\n  fields, modular arithmetic, GF(<span class=\"MATH\"><img align=\"BOTTOM\" alt=\"$2^n$\" border=\"0\" height=\"21\" src=\"img2.png\" width=\"23\"/></span>), pseudo-random functions and\n  permutations.\n\n<p></p></li>\n<li><b>Classic ciphers.</b> Vigen\u00e9re, perfect secrecy, Vernam,\n  computational security, Kerckhoffs\u2019 principle, random bit sources.\n\n<p></p></li>\n<li><b>Stream ciphers.</b> Attacking linear-congruential RNGs and\n  LFSRs, Trivium, RC4.\n\n<p></p></li>\n<li><b>Block ciphers.</b> SP networks, Feistel/Luby-Rackoff structure,\n  DES, AES, modes of operation, message authentication codes.\n\n<p></p></li>\n<li><b>Secure hash functions.</b> One-way functions, collision\n  resistance, Merkle-Damg\u00e5rd construction, padding, birthday\n  problem, MD5, SHA, HMAC, stream authentication, Merkle tree,\n  Lamport one-time signatures.\n\n<p></p></li>\n<li><b>Asymmetric cryptography.</b> Key-management problem,\n  signatures, certificates, PKI, discrete-logarithm problem,\n  Diffie-Hellman key exchange, ElGamal encryption and signature,\n  hybrid cryptography.\n\n<p></p></li>\n<li><b>Entity authentication.</b> Passwords, trusted path, phishing,\n  CAPTCHA. Authentication protocols: one-way and challenge-response\n  protocols, Needham-Schroeder, protocol failure examples, hardware\n  tokens.\n\n<p></p></li>\n<li><b>Access control.</b> Discretionary access control matrix, DAC in\n  POSIX and Windows, elevated rights and setuid bits, capabilities,\n  mandatory access control, covert channels, Clark-Wilson integrity.\n\n<p></p></li>\n<li><b>Operating system security.</b> Trusted computing base, domain\n  separation, reference mediation, residual information protection.\n\n<p></p></li>\n<li><b>Software security.</b> Malicious software, viruses. Common\n  implementation vulnerabilities: buffer overflows, integer overflows,\n  meta characters, syntax incompatibilities, race conditions,\n  unchecked values, side channels.\n\n<p></p></li>\n<li><b>Network security.</b> Vulnerabilities of TCP/IP, DNS.\n  HTTP authentication, cookies, cross-site scripting, browser\n  sandboxes. Firewalls, VPNs.\n\n<p></p></li>\n<li><b>Security policies and management.</b> Application-specific\n  security requirements, targets and policies, security management,\n  BS 7799.\n\n<p></p></li>\n\n\n<a name=\"SECTION03044300000000000000\">Objectives</a>\n\nBy the end of the course students should \n\n\n<li>be familiar with core security terms and concepts;\n\n<p></p></li>\n<li>have a basic understanding of some commonly used attack\n  techniques and protection mechanisms;\n\n<p></p></li>\n<li>have gained basic insight into aspects of modern cryptography\n  and its applications;\n\n<p></p></li>\n<li>appreciate the range of meanings that \u201csecurity\u201d has across\n  different applications.\n\n<p></p></li>\n\n\n<a name=\"SECTION03044400000000000000\">Recommended reading</a>\n\n* Paar, Ch. &amp; Pelzl, J. (2010). <em>Understanding cryptography</em>. Springer.\n<br/>Gollmann, D. (2010). <em>Computer security</em>. Wiley (3rd ed.).\n\n\n",
    "course_name": "Security\u00a0I",
    "course_code": "SecurityI",
    "course_url": "https://www.cl.cam.ac.uk/teaching/1112/SecurityI",
    "lecturers": ["mgk25"],
    "year": "1112",
    "tripos_part": "1b",
    "michaelmas": false,
    "lent": false,
    "easter": true
  }
}
