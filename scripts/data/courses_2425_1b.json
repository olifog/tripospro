{"ConcDisSys": {"supervisions": 4, "prerequisite_for": ["CC"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ConcurrentandDistributedSystems.html", "description": "<h2>Aims</h2>\n<p>This course considers two closely related topics, Concurrent\n  Systems and Distributed Systems, over 16 lectures. The aim of the\n  first half of the course is to introduce concurrency control\n  concepts and their implications for system design and\n  implementation. The aims of the latter half of the course are to\n  study the fundamental characteristics of distributed systems,\n  including their models and architectures; the implications for\n  software design; some of the techniques that have been used to\n  build them; and the resulting details of good distributed\n  algorithms and applications.</p>\n<h2>Lectures: Concurrency</h2>\n<ul>\n<li>Introduction to concurrency, threads, and mutual exclusion.\n    Introduction to concurrent systems; threads; interleaving;\n    preemption; parallelism; execution orderings; processes and\n    threads; kernel vs. user threads; M:N threads; atomicity;\n    mutual exclusion; and mutual exclusion locks (mutexes).</li>\n<li>Automata Composition. Synchronous and asynchronous\n    parallelism; sequential consistency; rendezvous. Safety,\n    liveness and deadlock; the Dining Philosophers; Hardware\n    foundations for atomicity: test-and-set,\n    load-linked/store-conditional and fence instructions. Lamport\n    bakery algorithm.</li>\n<li>Common design patterns: semaphores, producer-consumer, and\n    MRSW. Locks and invariants; semaphores; condition\n    synchronisation; N-resource allocation; two-party and\n    generalised producer-consumer; Multi-Reader, Single-Write\n    (MRSW) locks.</li>\n<li>CCR, monitors, and concurrency in practice. Conditional\n    critical regions (CCR); monitors; condition variables;\n    signal-wait vs. signal-continue semantics; concurrency in\n    practice (kernels, pthreads, Java, Cilk, OpenMP).</li>\n<li>Deadlock and liveness guarantees Offline vs. online; model\n    checking; resource allocation graphs; lock order checking;\n    deadlock prevention, avoidance, detection, and recovery;\n    livelock; priority inversion; auto parallelisation.</li>\n<li>Concurrency without shared data; transactions. Active\n    objects; message passing; tuple spaces; CSP; and actor models.\n    Composite operations; transactions; ACID; isolation; and\n    serialisability.</li>\n<li>Further transactions History graphs; good and bad\n    schedules; isolation vs. strict isolation; 2-phase locking;\n    rollback; timestamp ordering (TSO); and optimistic concurrency\n    control (OCC).</li>\n<li>Crash recovery, lock-free programming, and transactional\n    memory. Write-ahead logging, checkpoints, and recovery.\n    Lock-free programming. Hardware and software transactional\n    memories.</li>\n</ul>\n<p>\u00a0</p>\n<h2>Lectures: Distributed Systems</h2>\n<ul>\n<li>Introduction to distributed systems; RPC. Avantages and\n    challenges of distributed systems; unbounded delay and partial\n    failure; network protocols; transparency; client-server\n    systems; remote procedure call (RPC); marshalling; interface\n    definition languages (IDLs).</li>\n<li>System models and faults.\u00a0Synchronous, partially\n    synchronous, and asynchronous network models; crash-stop,\n    crash-recovery, and Byzantine faults; failures, faults, and\n    fault tolerance; two generals problem.</li>\n<li>Time, clocks, and ordering of events.\u00a0Physical clocks;\n    leap seconds; UTC; clock synchronisation and drift; Network\n    Time Protocol (NTP). Causality; happens-before relation.</li>\n<li>Logical time; Lamport clocks; vector clocks. Broadcast\n    (FIFO, causal, total order); gossip protocols.</li>\n<li>Replication. Quorums; idempotence; replica consistency;\n    read-after-write consistency. State machine replication;\n    leader-based replication.</li>\n<li>Consensus and total order broadcast. FLP result; leader\n    election; the Raft consensus algorithm.</li>\n<li>Replica consistency. Two-phase commit; relationship between\n    2PC and consensus; linearizability; ABD algorithm; eventual\n    consistency; CAP theorem.</li>\n<li>Case studies. Conflict-free Replicated Data Types (CRDTs);\n    collaborative text editing. Google's Spanner; TrueTime.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of Concurrent Systems portion of the course,\n  students should:</p>\n<ul>\n<li>understand the need for concurrency control in operating\n    systems and applications, both mutual exclusion and condition\n    synchronisation;</li>\n<li>understand how multi-threading can be supported and the\n    implications of different approaches;</li>\n<li>be familiar with the support offered by various programming\n    languages for concurrency control and be able to judge the\n    scope, performance implications and possible applications of\n    the various approaches;</li>\n<li>be aware that dynamic resource allocation can lead to\n    deadlock;</li>\n<li>understand the concept of transaction; the properties of\n    transactions, how they can be implemented, and how their\n    performance can be optimised based on optimistic\n    assumptions;</li>\n<li>understand how the persistence properties of transactions\n    are addressed through logging; and</li>\n<li>have a high-level understanding of the evolution of\n    software use of concurrency in the operating-system kernel case\n    study.</li>\n</ul>\n<p>At the end of the Distributed Systems portion of the course,\n  students should:</p>\n<ul>\n<li>understand the difference between shared-memory concurrency\n    and distributed systems;</li>\n<li>understand the fundamental properties of distributed\n    systems and their implications for system design;</li>\n<li>understand notions of time, including logical clocks,\n    vector clocks, and physical time synchronisation;</li>\n<li>be familiar with various approaches to data and service\n    replication, as well as the concept of replica\n    consistency;</li>\n<li>understand the effects of large scale on the provision of\n    fundamental services and the tradeoffs arising from scale;</li>\n<li>appreciate the implications of individual node and network\n    communications failures on distributed computation;</li>\n<li>be aware of a variety of programming models and\n    abstractions for distributed systems, such as RPC, middleware,\n    and total order broadcast;</li>\n<li>be familiar with a range of distributed algorithms, such as\n    consensus, causal broadcast, and two-phase commit.</li>\n</ul>\n<h2>Recommended reading</h2>\n<ul>\n<li>Modern Operating Systems\u00a0(free PDF available online)\n    by Andrew S Tanenbaum, Herbert Bos</li>\n<li>Java Concurrency in Practice' (2006 but still highly\n    relevant) by Brian Goetz</li>\n<li>Kleppmann, M. (2017). Designing data-intensive\n    applications. O\u2019Reilly.</li>\n<li>Tanenbaum, A.S. and van Steen, M. (2017).\u00a0Distributed\n    systems, 3rd edition.\u00a0<a href=\"https://www.distributed-systems.net/index.php/books/ds3/\">available\n    online</a>.</li>\n<li>Cachin, C., Guerraoui, R. and Rodrigues, L.\n    (2011)\u00a0Introduction to Reliable and Secure Distributed\n    Programming. Springer (2nd edition).</li>\n</ul>\n", "course_name": "Concurrent and Distributed Systems", "course_code": "ConcDisSys", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/ConcDisSys", "lecturers": ["mk428"], "lectures": 16, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "DataSci": {"supervisions": 4, "prerequisite_for": ["ADS", "CSM", "MLBayInfer", "NLP", "QuantComp"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DataScience.html", "description": "<h2>Aims</h2>\n<p>This course introduces fundamental tools for describing and\n  reasoning about data. There are two themes: designing probability\n  models to describe systems; and drawing conclusions based on data\n  generated by such systems.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Specifying and fitting probability models.</strong>\n    Random variables. Maximum likelihood estimation. Generative and\n    supervised models. Goodness of fit.</li>\n<li><strong>Feature spaces.</strong> Vector spaces, bases,\n    inner products, projection. Linear models. Model fitting as\n    projection. Design of features.</li>\n<li><strong>Handling probability models.</strong> Handling pdf\n    and cdf. Bayes\u2019s rule. Monte Carlo estimation. Empirical\n    distribution.</li>\n<li><strong>Inference.</strong> Bayesianism. Frequentist\n    confidence intervals, hypothesis testing. Bootstrap\n    resampling.</li>\n<li><strong>Random processes.</strong> Markov chains.\n    Stationarity, and drift analysis. Processes with memory.\n    Learning a random process.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to formulate basic probabilistic models, including\n    discrete time Markov chains and linear models</li>\n<li>be familiar with common random variables and their uses,\n    and with the use of empirical distributions rather than\n    formulae</li>\n<li>understand different types of inference about noisy data,\n    including model fitting, hypothesis testing, and making\n    predictions</li>\n<li>understand the fundamental properties of inner product\n    spaces and orthonormal systems, and their application to\n    modelling</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* F.M. Dekking, C. Kraaikamp, H.P. Lopuha\u00e4, L.E. Meester\n  (2005). A modern introduction to probability and statistics:\n  understanding why and how. Springer.</p>\n<p>S.M. Ross (2002). Probability models for computer science.\n  Harcourt / Academic Press.</p>\n<p>M. Mitzenmacher and E. Upfal (2005). Probability and\n  computing: randomized algorithms and probabilistic analysis.\n  Cambridge University Press.</p>\n", "course_name": "Data Science", "course_code": "DataSci", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/DataSci", "lecturers": [], "lectures": 16, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ECAD+Arch": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>The aims of this course are to enable students to apply the\n  concepts learned in the Computer Design course. In particular a\n  web based tutor is used to introduce the SystemVerilog hardware\n  description language, while the remaining practical classes will\n  then allow students to implement the design of components in this\n  language.</p>\n<h2>Practical Classes</h2>\n<ul>\n<li><strong>Web tutor</strong> The first class uses a web based\n    tutor to rapidly teach the SystemVerilog language.</li>\n<li><strong>FPGA design flow</strong> Test driven hardware\n    development for FPGA including an embedded processor and\n    peripherals [3\u00a0classes]</li>\n<li><strong>Embedded system implementation</strong> Embedded\n    system implementation on FPGA [3-4\u00a0classes]</li>\n</ul>\n<h2>Objectives</h2>\n<ul>\n<li>Gain experience in electronic computer aided design (ECAD)\n    through learning a design-flow for field programmable gate\n    arrays (FPGAs).</li>\n<li>Learn how to interface to peripherals like a touch\n    screen.</li>\n<li>Learn how to debug hardware and software systems in\n    simulation.</li>\n<li>Understand how to construct and program a heterogeneous\n    embedded system.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Harris, D.M. and Harris, S.L. (2007). <i>Digital design and\n  computer architecture: from gates to processors</i>. Morgan\n  Kaufmann.</p>\n<p>Pointers to sources of more specialist information are\n  included on the associated course web page.</p>\n", "course_name": "ECAD and Architecture Practical Classes", "course_code": "ECAD+Arch", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/ECAD+Arch", "lecturers": ["atm26"], "lectures": null, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "EconLaw": {"supervisions": 2, "prerequisite_for": ["Business", "ECommerce"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-EconomicsLawandEthics.html", "description": "<h2>Aims</h2>\n<p>This course aims to give students an introduction to some\n  basic concepts in economics, law and ethics.</p>\n<h2>Lectures</h2>\n<ul>\n<li>Classical economics and consumer theory. Prices and\n    markets; Pareto efficiency; preferences; utility; supply and\n    demand; the marginalist revolution; elasticity; the welfare\n    theorems; transaction costs.</li>\n<li>Information economics. The discriminating monopolist;\n    marginal costs; effects of technology on supply and demand;\n    competition and information; lock in; real and virtual\n    networks; Metcalfe\u2019s law; the dominant firm model; price\n    discrimination; bundling; income distribution.</li>\n<li>Market failure and behavioural economics. Market failure:\n    the business cycle; recession and technology; tragedy of the\n    commons; externalities; monopoly rents; asymmetric information:\n    the market for lemons; adverse selection; moral hazard;\n    signalling. Behavioural economics: bounded rationality,\n    heuristics and biases; nudge theory; the power of defaults;\n    agency effects.</li>\n<li>Auction theory and game theory. Auction theory: types of\n    auctions; strategic equivalence; the revenue equivalence\n    theorem; the winner\u2019s curse; problems with real auctions;\n    mechanism design and the combinatorial auction; applicability\n    of auction mechanisms in computer science; advertising\n    auctions. Game theory: the choice between cooperation and\n    conflict; strategic forms; dominant strategy equilibrium; Nash\n    equilibrium; the prisoners\u2019 dilemma; evolution of strategies;\n    stag hunt; volunteer\u2019s dilemma; chicken; iterated games;\n    hawk-dove; application to computer science.</li>\n<li>Principles of law. Criminal and civil law; contract law;\n    choice of law and jurisdiction; arbitration; tort; negligence;\n    defamation; intellectual property rights.</li>\n<li>Law and the Internet. Computer evidence; the General Data\n    Protection Regulation; UK laws that specifically affect the\n    Internet; e-commerce regulations; privacy and electronic\n    communications.</li>\n<li>Philosophies of ethics. Authority, intuitionist, egoist and\n    deontological theories; utilitarian and Rawlsian models;\n    morality; insights from evolutionary psychology, neurology, and\n    experimental ethics; professional codes of ethics; research\n    ethics.</li>\n<li>Contemporary ethical issues. The Internet and social\n    policy; current debates on privacy, surveillance, and\n    censorship; responsible vulnerability disclosure; algorithmic\n    bias; predictive policing; gamification and engagement;\n    targeted political advertising; environmental impacts.</li>\n</ul>\n<h2>Objectives</h2>\n<p>On\u00a0completion of this course, students should be able\n  to:</p>\n<ul>\n<li>Reflect\u00a0on and discuss professional, economic, social,\n    environmental, moral and ethical\u00a0issues relating\n    to\u00a0computer science</li>\n<li>Define\u00a0and explain economic and legal terminology and\n    arguments</li>\n<li>Apply\u00a0the philosophies and theories covered to\n    computer science problems and\u00a0scenarios</li>\n<li>Reflect\u00a0on the main constraints that market,\n    legislation and ethics place on firms\u00a0dealing in\n    information\u00a0goods and services</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Shapiro, C. &amp; Varian, H. (1998). Information rules.\n  Harvard Business School Press.<br/>\n  Hare, S. (2022). Technology is not neutral: A short guide to\n  technology ethics. London Publishing Partnership.</p>\n<h3>Further reading:</h3>\n<p>Smith, A. (1776). An inquiry into the nature and causes of the\n  wealth of nations, available at\u00a0\u00a0\u00a0 <a href=\"http://www.econlib.org/library/Smith/smWN.html\">http://www.econlib.org/library/Smith/smWN.html</a><br/>\n\n  Thaler, R.H. (2016). Misbehaving. Penguin.<br/>\n  Galbraith, J.K. (1991). A history of economics. Penguin.<br/>\n  Poundstone, W. (1992). Prisoner\u2019s dilemma. Anchor Books.<br/>\n  Pinker, S (2011). The Better Angels of our Nature. Penguin.<br/>\n  Anderson, R. (2008). Security engineering (Chapter 7). Wiley.<br/>\n  Varian, H. (1999). Intermediate microeconomics - a modern\n  approach. Norton.<br/>\n  Nuffield Council on Bioethics (2015) The collection, linking and\n  use of data in biomedical research and health care.</p>\n", "course_name": "Economics, Law and Ethics", "course_code": "EconLaw", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/EconLaw", "lecturers": ["afb21", "rnc1"], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FGraphics": {"supervisions": 2, "prerequisite_for": ["ER"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherGraphics.html", "description": "<h2>Aims</h2>\n<p>The course introduces fundamental concepts of modern graphics\n  pipelines.</p>\n<h2>Lectures</h2>\n<p>The order and content of lectures is provisional and subject\n  to change.</p>\n<ul>\n<li>Geometry Representations. Parametric surfaces, implicit\n    surfaces, meshes, point-set surfaces, geometry processing\n    pipeline. [1 lecture]</li>\n<li>Discrete Differential Geometry. Surface normal and\n    curvature, Laplace-Beltrami operator, heat diffusion. [1\n    lecture]</li>\n<li>Geometry Processing.\u00a0 Parametrization, filtering, 3D\n    capture. [1 lecture]</li>\n<li>Animation I. Animation types, animation pipeline,\n    rigging/skinning, character animation. [1 lecture]</li>\n<li>Animation II. Blending transformations, pose-space\n    animation, controllers. [1 lecture]</li>\n<li>The Rendering Equation. Radiosity, reflection models,\n    BRDFs, local vs. global illumination. [1 lecture]</li>\n<li>Distributed Ray Tracing. Quadrature, importance sampling,\n    recursive ray tracing. [1 lecture]</li>\n<li>Inverse Rendering. Differentiable rendering, inverse\n    problems. [1 lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>On completing the course, students should be able to</p>\n<ul>\n<li>understand and use fundamental 3D geometry/scene\n    representations and operations;</li>\n<li>learn animation techniques and controls;</li>\n<li>learn how light transport is modeled and simulated in\n    rendering;</li>\n<li>understand how graphics and rendering can be used to solve\n    computer perception problems.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Students should expect to refer to one or more of these books,\n  but should not find it necessary to purchase any of them.</p>\n<ul>\n<li>Shirley, P. and Marschner, S. (2009). Fundamentals of\n    Computer Graphics. CRC Press (3rd ed.).</li>\n<li>Watt, A. (2000). 3D Computer Graphics. Addison-Wesley (3rd\n    ed).</li>\n<li>Hughes, van Dam, McGuire, Skalar, Foley, Feiner and Akeley\n    (2013). Computer Graphics: Principles and Practice.\n    Addison-Wesley (3rd edition)</li>\n<li>Akenine-M\u00f6ller, et. al. (2018). Real-time rendering. CRC\n    Press (4th ed.).</li>\n</ul>\n", "course_name": "Further Graphics", "course_code": "FGraphics", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/FGraphics", "lecturers": [], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "FJava": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>The goal of this course is to provide students with the\n  ability to understand the advanced programming features available\n  in the Java programming language, completing the coverage of the\n  language started in the Programming in Java course. The course is\n  designed to accommodate students with diverse programming\n  backgrounds; consequently Java is taught from first principles in\n  a practical class setting where students can work at their own\n  pace from a course handbook.</p>\n<p>Objectives</p>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand different mechanisms for communication between\n    distributed applications and be able to evaluate their\n    trade-offs;</li>\n<li>be able to use Java generics and annotations to improve\n    software usability, readability and safety;</li>\n<li>understand and be able to exploit the Java class-loading\n    mechansim;</li>\n<li>understand and be able to use concurrency control\n    correctly;</li>\n<li>be able to implement a vector clock algorithm and the\n    happens-before relation.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Goetz, B. (2006). <em>Java concurrency in practice</em>.\n  Addison-Wesley.<br/>\n  Gosling, J., Joy, B., Steele, G., Bracha, G. and Buckley, A.\n  (2014). <em>The Java language specification, Java SE 8\n  Edition</em>. Addison-Wesley.<br/>\n<a href=\"http://docs.oracle.com/javase/specs/jls/se8/html/\" id=\"tex2html11\" name=\"tex2html11\">http://docs.oracle.com/javase/specs/jls/se8/html/</a></p>\n", "course_name": "Further Java", "course_code": "FJava", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/FJava", "lecturers": [], "lectures": 10, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "GroupProj": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Group Project", "course_code": "GroupProj", "course_url": "https://www.cl.cam.ac.uk/teaching/group-projects/", "lecturers": ["afb21", "rkh23", "tcg40"], "lectures": null, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": true, "easter": false}, "IntComArch": {"supervisions": 5, "prerequisite_for": ["AdComArch", "CySecurity"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoComputerArchitecture.html", "description": "<h2>Aims</h2>\n<p>The aims of this course are to introduce a hardware\n  description language (SystemVerilog) and computer architecture\n  concepts in order to design computer systems. The parallel\n  ECAD+Arch practical classes will allow students to apply the\n  concepts taught in lectures.</p>\n<h2>Lectures</h2>\n<p><strong>Part 1 - Gates to processors\u00a0</strong></p>\n<ul>\n<li><strong>Technology trends and design challenges.</strong>\n    Current technology, technology trends, ECAD trends, challenges.\n    [1 lecture]</li>\n<li><strong>Digital system design.</strong> Practicalities of\n    mapping SystemVerilog descriptions of hardware (including a\n    processor) onto an FPGA board. Tips and pitfalls when\n    generating larger modular designs. [1 lecture]</li>\n<li><strong>Eight great ideas in computer\n    architecture.</strong> [1 lecture]</li>\n<li><strong>Reduced instruction set computers and\n    RISC-V.</strong> Introduction to the RISC-V processor design.\n    [1 lecture]</li>\n<li><strong>Executable and synthesisable models.</strong> [1\n    lecture]</li>\n<li><strong>Pipelining.</strong> [2 lectures]</li>\n<li><strong>Memory hierarchy and caching.</strong> Caching,\n    etc. [1 lecture]</li>\n<li><strong>Support for operating systems.</strong> Memory\n    protection, exceptions, interrupts, etc. [1 lecture]</li>\n<li><strong>Other instruction set architectures.</strong> CISC,\n    stack, accumulator. [1 lecture]</li>\n</ul>\n<p><strong>Part 2\u00a0</strong></p>\n<ul>\n<li><strong>Overview of Systems-on-Chip (SoCs) and\n    DRAM.</strong> [1 lecture] High-level SoCs, DRAM storage and\n    accessing.</li>\n<li><strong>Multicore Processors.</strong> [2 lectures]\n    Communication, cache coherence, barriers and synchronisation\n    primitives.</li>\n<li><strong>Graphics processing units (GPUs)</strong> [2\n    lectures] Basic GPU architecture and programming.</li>\n<li><strong>Future Directions</strong> [1 lecture] Where is\n    computer architecture heading?</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to read assembler given a guide to the instruction\n    set and be able to write short pieces of assembler if given an\n    instruction set or asked to invent an instruction set;</li>\n<li>understand the differences between RISC and CISC\n    assembler;</li>\n<li>understand what facilities a processor provides to support\n    operating systems, from memory management to software\n    interrupts;</li>\n<li>understand memory hierarchy including different cache\n    structures and coherency needed for multicore systems;</li>\n<li>understand how to implement a processor in\n    SystemVerilog;</li>\n<li>appreciate the use of pipelining in processor design;</li>\n<li>have an appreciation of control structures used in\n    processor design;</li>\n<li>have an appreciation of system-on-chips and their\n    components;</li>\n<li>understand how DRAM stores data;</li>\n<li>understand how multicore processors communicate;</li>\n<li>understand how GPUs work and have an appreciation of how to\n    program them.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Patterson, D.A. and Hennessy, J.L. (2017). <i>Computer\n  organization and design: The hardware/software interface RISC-V\n  edition</i>. Morgan Kaufmann. ISBN\u00a0978-0-12-812275-4.</p>\n<p>Recommended further reading:</p>\n<p>Harris, D.M. and Harris, S.L. (2012). <i>Digital design and\n  computer architecture</i>. Morgan Kaufmann.\n  ISBN\u00a0978-0-12-394424-5.<br/>\n  Hennessy, J. and Patterson, D. (2006). <i>Computer architecture:\n  a quantitative approach</i>. Elsevier (4th ed.).\n  ISBN\u00a0978-0-12-370490-0. (Older versions of the book are also\n  still generally relevant.)</p>\n<p>Pointers to sources of more specialist information are\n  included in the lecture notes and on the associated course web\n  page.</p>\n", "course_name": "Introduction to Computer Architecture", "course_code": "IntComArch", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/IntComArch", "lecturers": ["rdm34", "tmj32"], "lectures": 16, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "ProgC": {"supervisions": 3, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgramminginCandC++.html", "description": "<h2>Aims</h2>\n<p>This course aims</p>\n<ul>\n<li>to provide a solid introduction to programming in C and to\n    provide an overview of the principles and constraints that\n    affect the way in which the C programming language has been\n    designed and is used;</li>\n<li>to introduce the key additional features of C++.</li>\n</ul>\n<p>\u00a0</p>\n<h2>Lectures</h2>\n<ol>\n<li><strong>Introduction to the C\n    language.</strong>\u00a0Background and goals of C. Types,\n    expressions, control flow and strings.</li>\n<li><strong>(continued)\u00a0</strong>Functions. Multiple\n    compilation units. Scope. Segments. Incremental compilation.\n    Preprocessor.</li>\n<li><strong>(continued)\u00a0</strong>Pointers and pointer\n    arithmetic. Function pointers. Structures and Unions.</li>\n<li><strong>(continued)\u00a0</strong>Const and volatile\n    qualifiers. Typedefs. Standard input/output. Heap allocation.\n    Miscellaneous Features, Hints and Tips.</li>\n<li><strong>C semantics and tools.\u00a0</strong>Undefined vs\n    implementation-defined behaviour. Buffer and integer overflows.\n    ASan, MSan, UBsan, Valgrind checkers.</li>\n<li><strong>Memory allocation, data structures and\n    aliasing.\u00a0</strong>Malloc/free, tree and DAG examples and\n    their deallocation using a memory arena.</li>\n<li><strong>Further memory management.\u00a0</strong>Reference\n    Counting and Garbage Collection</li>\n<li><strong>Memory hierarchy and cache\n    optimization.\u00a0</strong>Data structure layouts. Intrusive\n    lists. Array-of-structs vs struct-of-arrays representations.\n    Loop blocking.</li>\n<li><strong>Debugging.</strong>\u00a0Using print statements,\n    assertions and an interactive debugger. Unit testing and\n    regression.</li>\n<li><strong>Introduction to C++.\u00a0</strong>Goals of C++.\n    Differences between C and C++. References versus pointers.\n    Overloaded functions.</li>\n<li><strong>Objects in C++.\u00a0</strong>Classes and structs.\n    Destructors. Resource Acquisition is Initialisation. Operator\n    overloading. Virtual functions. Casts. Multiple inheritance.\n    Virtual base classes.</li>\n<li><strong>Other C++ concepts.\u00a0</strong>Templates and\n    meta-programming.</li>\n</ol>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to read and write C programs;</li>\n<li>understand the interaction between C programs and the host\n    operating system;</li>\n<li>be familiar with the structure of C program execution in\n    machine memory;</li>\n<li>understand the potential dangers of writing programs in\n    C;</li>\n<li>understand the object model and main additional features of\n    C++.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Kernighan, B.W. and Ritchie, D.M. (1988).\u00a0<em>The C\n  programming language</em>. Prentice\u00a0Hall (2nd ed.).</p>\n", "course_name": "Programming in C and C++", "course_code": "ProgC", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/ProgC", "lecturers": ["djg11"], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "Semantics": {"supervisions": 3, "prerequisite_for": ["CAT", "HLog+ModC", "MSP", "Types"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SemanticsofProgrammingLanguages.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce the structural,\n  operational approach to programming language semantics. It will\n  show how to specify the meaning of typical programming language\n  constructs, in the context of language design, and how to reason\n  formally about semantic properties of programs.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Transition systems. The idea\n    of structural operational semantics. Transition semantics of a\n    simple imperative language. Language design options. [2\n    lectures]</li>\n<li><strong>Types.</strong> Introduction to formal type\n    systems. Typing for the simple imperative language. Statements\n    of desirable properties. [2 lectures]</li>\n<li><strong>Induction.</strong> Review of mathematical\n    induction. Abstract syntax trees and structural induction.\n    Rule-based inductive definitions and proofs. Proofs of type\n    safety properties. [2 lectures]</li>\n<li><strong>Functions.</strong> Call-by-name and call-by-value\n    function application, semantics and typing. Local recursive\n    definitions. [2 lectures]</li>\n<li><strong>Data.</strong> Semantics and typing for products,\n    sums, records, references. [1 lecture]</li>\n<li><strong>Subtyping.</strong> Record subtyping and simple\n    object encoding. [1 lecture]</li>\n<li><strong>Semantic equivalence.</strong> Semantic equivalence\n    of phrases in a simple imperative language, including the\n    congruence property. Examples of equivalence and\n    non-equivalence. [1 lecture]</li>\n<li><strong>Concurrency.</strong> Shared variable interleaving.\n    Semantics for simple mutexes; a serializability property. [1\n    lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with rule-based presentations of the\n    operational semantics and type systems for some simple\n    imperative, functional and interactive program constructs;</li>\n<li>be able to prove properties of an operational semantics\n    using various forms of induction (mathematical, structural, and\n    rule-based);</li>\n<li>be familiar with some operationally-based notions of\n    semantic equivalence of program phrases and their basic\n    properties.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Pierce, B.C. (2002). <i>Types and programming languages</i>.\n  MIT Press.<br/>\n  Hennessy, M. (1990). <i>The semantics of programming\n  languages</i>. Wiley. Out of print, but available on the web at\n  <a href=\"http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf\">\n  http://www.cs.tcd.ie/matthew.hennessy/splexternal2015/resources/sembookWiley.pdf</a><br/>\n\n  Winskel, G. (1993). <i>The formal semantics of programming\n  languages</i>. MIT Press.</p>\n", "course_name": "Semantics of Programming Languages", "course_code": "Semantics", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/Semantics", "lecturers": ["pes20"], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "UnixTools": {"supervisions": 0, "prerequisite_for": ["CC", "CySecurity"], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>This video-lecture course gives students who have already\n  basic Unix/Linux experience some additional practical\n  software-engineering knowledge: how to use the shell and related\n  tools as an efficient working environment, how to automate\n  routine tasks, and how version-control and automated-build tools\n  can help to avoid confusion and accidents, especially when\n  working in teams. These are essential skills, both in industrial\n  software development and student projects.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Unix concepts.</strong> Brief review of Unix\n    history and design philosophy, documentation, terminals,\n    inter-process communication mechanisms and conventions, shell,\n    command-line arguments, environment variables, file\n    descriptors.</li>\n<li><strong>Shell concepts.</strong> Program invocation,\n    redirection, pipes, file-system navigation, argument expansion,\n    quoting, job control, signals, process groups, variables,\n    locale, history and alias functions, security\n    considerations.</li>\n<li><strong>Scripting.</strong> Plain-text formats,\n    executables, #!, shell control structures and functions.\n    Startup scripts.</li>\n<li><strong>Text, file and networking tools.</strong> sed,\n    grep, chmod, find, ssh, rsync, tar, zip, etc.</li>\n<li><strong>Version control.</strong> diff, patch, RCS,\n    Subversion, git.</li>\n<li><strong>Software development tools.</strong> C compiler,\n    linker, debugger, make.</li>\n<li><strong>Perl.</strong> Introduction to a powerful scripting\n    and text-manipulation language. [2\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be confident in performing routine user tasks on a POSIX\n    system, understand command-line user-interface conventions and\n    know how to find more detailed documentation;</li>\n<li>appreciate how simple tools can be combined to perform a\n    large variety of tasks;</li>\n<li>be familiar with the most common tools, file formats and\n    configuration practices;</li>\n<li>be able to understand, write, and maintain shell scripts\n    and makefiles;</li>\n<li>appreciate how using a version-control system and fully\n    automated build processes help to maintain reproducibility and\n    audit trails during software development;</li>\n<li>know enough about basic development tools to be able to\n    install, modify and debug C source code;</li>\n<li>have understood the main concepts of, and gained initial\n    experience in, writing Perl scripts (excluding the facilities\n    for object-oriented programming).</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Robbins, A. (2005). <em>Unix in a nutshell</em>. O\u2019Reilly (4th\n  ed.).<br/>\n  Schwartz, R.L., Foy, B.D. and Phoenix, T. (2011). <em>Learning\n  Perl</em>. O\u2019Reilly (6th ed.).</p>\n", "course_name": "Unix Tools", "course_code": "UnixTools", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/UnixTools", "lecturers": ["mgk25"], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": true, "lent": false, "easter": false}, "CompConstr": {"supervisions": 4, "prerequisite_for": ["ForModLang", "OptComp"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-CompilerConstruction.html", "description": "<h2>Aims</h2>\n<p>This course aims to cover the main concepts associated with\n  implementing compilers for programming languages. We use a\n  running example called SLANG (a Small LANGuage) inspired by the\n  languages described in 1B Semantics. A toy compiler (written in\n  ML) is provided, and students are encouraged to extend it in\n  various ways.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Overview of compiler structure</strong> The\n    spectrum of interpreters and compilers; compile-time and\n    run-time. Compilation as a sequence of translations from\n    <em>higher-level</em> to <em>lower-level</em> intermediate\n    languages, where each translation preserves semantics. The\n    structure of a simple compiler: lexical analysis and syntax\n    analysis, type checking, intermediate representations,\n    optimisations, code generation. Overview of run-time data\n    structures: stack and heap. Virtual machines.\n    [1\u00a0lecture]</li>\n<li><strong>Lexical analysis and syntax analysis.</strong>\n    Lexical analysis based on regular expressions and finite state\n    automata. Using LEX-tools. How does LEX work? Parsing based on\n    context-free grammars and push-down automata. Grammar\n    ambiguity, left- and right-associativity and operator\n    precedence. Using YACC-like tools. How does YACC work? LL(k)\n    and LR(k) parsing theory. [3\u00a0lectures]</li>\n<li><strong>Compiler Correctness</strong> Recursive functions\n    can be transformed into iterative functions using the\n    Continuation-Passing Style (CPS) transformation. CPS applied to\n    a (recursive) SLANG interpreter to derive, in a step-by-step\n    manner, a correct stack-based compiler. [3\u00a0lectures]</li>\n<li><strong>Data structures, procedures/functions</strong>\n    Representing tuples, arrays, references. Procedures and\n    functions: calling conventions, nested structure, non-local\n    variables. Functions as <em>first-class</em> values represented\n    as <em>closures</em>. Simple optimisations: inline expansion,\n    constant folding, elimination of tail recursion, peephole\n    optimisation. [5\u00a0lectures]</li>\n<li><strong>Advanced topics</strong> Run-time memory management\n    (garbage collection). Static and dynamic linking. Objects and\n    inheritance; implementation of method dispatch. Try-catch\n    exception mechanisms. Compiling a compiler via bootstrapping.\n    [4\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should understand the\n  overall structure of a compiler, and will know significant\n  details of a number of important techniques commonly used. They\n  will be aware of the way in which language features raise\n  challenges for compiler builders.</p>\n<h2>Recommended reading</h2>\n<p>* Aho, A.V., Sethi, R. and Ullman, J.D. (2007). <em>Compilers:\n  principles, techniques and tools</em>. Addison-Wesley (2nd\n  ed.).<br/>\n  Mogensen, T. \u00c6. (2011). <em>Introduction to compiler design</em>.\n  Springer. <a href=\"http://www.diku.dk/~torbenm/Basics\" id=\"tex2html13\" name=\"tex2html13\">http://www.diku.dk/\u00a0torbenm/Basics</a>.</p>\n", "course_name": "Compiler Construction", "course_code": "CompConstr", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/CompConstr", "lecturers": ["jdy22"], "lectures": 16, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompTheory": {"supervisions": 3, "prerequisite_for": ["Complexity", "QuantComp", "Types"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputationTheory.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce several apparently\n  different formalisations of the informal notion of algorithm; to\n  show that they are equivalent; and to use them to demonstrate\n  that there are uncomputable functions and algorithmically\n  undecidable problems.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction: algorithmically undecidable\n    problems.</strong> Decision problems. The informal notion of\n    algorithm, or effective procedure. Examples of algorithmically\n    undecidable problems. [1 lecture]</li>\n<li><strong>Register machines.</strong> Definition and\n    examples; graphical notation. Register machine computable\n    functions. Doing arithmetic with register machines. [1\n    lecture]</li>\n<li><strong>Universal register machine.</strong> Natural number\n    encoding of pairs and lists. Coding register machine programs\n    as numbers. Specification and implementation of a universal\n    register machine. [2\u00a0lectures]</li>\n<li><strong>Undecidability of the halting problem.</strong>\n    Statement and proof. Example of an uncomputable partial\n    function. Decidable sets of numbers; examples of undecidable\n    sets of numbers. [1 lecture]</li>\n<li><strong>Turing machines.</strong> Informal description.\n    Definition and examples. Turing computable functions.\n    Equivalence of register machine computability and Turing\n    computability. The Church-Turing Thesis. [2\u00a0lectures]</li>\n<li><strong>Primitive and partial recursive functions.</strong>\n    Definition and examples. Existence of a recursive, but not\n    primitive recursive function. A partial function is partial\n    recursive if and only if it is computable.\n    [2\u00a0lectures]</li>\n<li><strong>Lambda-Calculus.</strong> Alpha and beta\n    conversion. Normalization. Encoding data. Writing recursive\n    functions in the lambda-calculus. The relationship between\n    computable functions and lambda-definable functions.\n    [3\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be familiar with the register machine, Turing machine and\n    lambda-calculus models of computability;</li>\n<li>understand the notion of coding programs as data, and of a\n    universal machine;</li>\n<li>be able to use diagonalisation to prove the undecidability\n    of the Halting Problem;</li>\n<li>understand the mathematical notion of partial recursive\n    function and its relationship to computability.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Hopcroft, J.E., Motwani, R. and Ullman, J.D. (2001).\n  <i>Introduction to automata theory, languages, and\n  computation</i>. Addison-Wesley (2nd ed.).<br/>\n  * Hindley, J.R. and Seldin, J.P. (2008). <i>Lambda-calculus and\n  combinators, an introduction</i>. Cambridge University Press (2nd\n  ed.).<br/>\n  Cutland, N.J. (1980). <i>Computability: an introduction to\n  recursive function theory</i>. Cambridge University Press.<br/>\n  Davis, M.D., Sigal, R. and Weyuker, E.J. (1994).\n  <i>Computability, complexity and languages</i>. Academic Press\n  (2nd ed.).<br/>\n  Sudkamp, T.A. (2005). <i>Languages and machines</i>.\n  Addison-Wesley (3rd ed.).</p>\n", "course_name": "Computation Theory", "course_code": "CompTheory", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/CompTheory", "lecturers": [], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "CompNet": {"supervisions": 5, "prerequisite_for": ["CC", "CySecurity", "PrincComm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerNetworking.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce key concepts and\n  principles of computer networks. The course will use a top-down\n  approach to study the Internet and its protocol stack. Instances\n  of architecture, protocol, application-examples will include\n  email, web and media-streaming. We will cover communications\n  services (e.g., TCP/IP) required to support such network\n  applications. The implementation and deployment of communications\n  services in practical networks: including wired and wireless LAN\n  environments, will be followed by a discussion of issues of\n  network-management. Throughout the course, the Internet\u2019s\n  architecture and protocols will be used as the primary examples\n  to illustrate the fundamental principles of computer\n  networking.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Overview of networking using\n    the Internet as an example. LANs and WANs. OSI reference model,\n    Internet TCP/IP Protocol Stack. Circuit-switching,\n    packet-switching, Internet structure, networking delays and\n    packet loss. [3\u00a0lectures]</li>\n<li><strong>Link layer and local area networks.</strong> Link\n    layer services, error detection and correction, Multiple Access\n    Protocols, link layer addressing, Ethernet, hubs and switches,\n    Point-to-Point Protocol. [2\u00a0lectures]</li>\n<li><strong>Wireless and mobile networks.</strong> Wireless\n    links and network characteristics, Wi-Fi: IEEE 802.11 wireless\n    LANs. [1\u00a0lecture]</li>\n<li><strong>Network layer addressing.</strong> Network layer\n    services, IP, IP addressing, IPv4, DHCP, NAT, ICMP, IPv6.\n    [3\u00a0lectures]</li>\n<li><strong>Network layer routing.</strong> Routing and\n    forwarding, routing algorithms, routing in the Internet,\n    multicast. [3\u00a0lectures]</li>\n<li><strong>Transport layer.</strong> Service models,\n    multiplexing/demultiplexing, connection-less transport (UDP),\n    principles of reliable data transfer, connection-oriented\n    transport (TCP), TCP congestion control, TCP variants.\n    [6\u00a0lectures]</li>\n<li><strong>Application layer.</strong> Client/server paradigm,\n    WWW, HTTP, Domain Name System, P2P. [1.5\u00a0lectures]</li>\n<li><strong>Multimedia networking.</strong> Networked\n    multimedia applications, multimedia delivery requirements,\n    multimedia protocols (SIP), content distribution networks.\n    [0.5\u00a0lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to analyse a communication system by separating out\n    the different functions provided by the network;</li>\n<li>understand that there are fundamental limits to any\n    communications system;</li>\n<li>understand the general principles behind multiplexing,\n    addressing, routing, reliable transmission and other stateful\n    protocols as well as specific examples of each;</li>\n<li>understand what FEC is;</li>\n<li>be able to compare communications systems in how they solve\n    similar problems;</li>\n<li>have an informed view of both the internal workings of the\n    Internet and of a number of common Internet applications and\n    protocols.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Peterson, L.L. and Davie, B.S. (2011). <em>Computer\n  networks: a systems approach</em>. Morgan Kaufmann (5th ed.).\n  ISBN 9780123850591<br/>\n  Kurose, J.F. and Ross, K.W. (2009). <em>Computer networking: a\n  top-down approach</em>. Addison-Wesley (5th ed.).<br/>\n  Comer, D. and Stevens, D. (2005). <em>Internetworking with\n  TCP-IP, vol.</em> 1 <em>and</em> 2. Prentice\u00a0Hall (5th\n  ed.).<br/>\n  Stevens, W.R., Fenner, B. and Rudoff, A.M. (2003). <em>UNIX\n  network programming, Vol.I: The sockets networking API</em>.\n  Prentice\u00a0Hall (3rd ed.).</p>\n", "course_name": "Computer Networking", "course_code": "CompNet", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/CompNet", "lecturers": ["awm22"], "lectures": 20, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "FHCI": {"supervisions": 2, "prerequisite_for": ["HCAI"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FurtherHuman-ComputerInteraction.html", "description": "<h2>Aims</h2>\n<p>This aim of this course is to provide an introduction to the\n  theoretical foundations of Human Computer Interaction, and an\n  understanding of how these can be applied to the design of\n  complex technologies.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Theory driven approaches to HCI.</strong> What is a\n    theory in HCI? Why take a theory driven approach to HCI?</li>\n<li><strong>Design of visual displays.</strong> Segmentation\n    and variables of the display plane. Modes of\n    correspondence.</li>\n<li><strong>Goal-oriented interaction.</strong> Using cognitive\n    theories of planning, learning and understanding to understand\n    user behaviour, and what they find hard.</li>\n<li><strong>Designing smart systems.</strong> Using statistical\n    methods to anticipate user needs and actions with Bayesian\n    strategies.</li>\n<li><strong>Designing efficient systems.</strong> Measuring and\n    optimising human performance through quantitative experimental\n    methods.</li>\n<li><strong>Designing meaningful systems.</strong> Qualitative\n    research methods to understand social context and requirements\n    of user experience.</li>\n<li><strong>Evaluating interactive system designs.</strong>\n    Approaches to evaluation in systems research and engineering,\n    including Part II Projects.</li>\n<li><strong>Designing complex systems.</strong> Worked case\n    studies of applying the theories to a hard HCI problem.\n    Research directions in HCI.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should be able to apply\n  theories of human performance and cognition to system design,\n  including selection of appropriate techniques to analyse, observe\n  and improve the usability of a wide range of technologies.</p>\n<h2>Recommended reading</h2>\n<p>* Preece, J., Sharp, H. and Rogers, Y. (2015). <em>Interaction\n  design: beyond human-computer interaction</em>. Wiley (Currently\n  in 4th edition, but earlier editions will suffice).</p>\n<p>Further reading:</p>\n<p>Carroll, J.M. (ed.) (2003). <em>HCI models, theories and\n  frameworks: toward a multi-disciplinary science</em>. Morgan\n  Kaufmann.</p>\n", "course_name": "Further Human\u2013Computer Interaction", "course_code": "FHCI", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/FHCI", "lecturers": ["afb21"], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "LogicProof": {"supervisions": 3, "prerequisite_for": ["HLog+ModC"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-LogicandProof.html", "description": "<h2>Aims</h2>\n<p>This course will teach logic, especially the predicate\n  calculus. It will present the basic principles and definitions,\n  then describe a variety of different formalisms and algorithms\n  that can be used to solve problems in logic. Putting logic into\n  the context of Computer Science, the course will show how the\n  programming language Prolog arises from the automatic proof\n  method known as resolution. It will introduce topics that are\n  important in mechanical verification, such as binary decision\n  diagrams (BDDs), SAT solvers and modal logic.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to logic.</strong> Schematic\n    statements. Interpretations and validity. Logical consequence.\n    Inference.</li>\n<li><strong>Propositional logic.</strong> Basic syntax and\n    semantics. Equivalences. Normal forms. Tautology checking using\n    CNF.</li>\n<li><strong>The sequent calculus.</strong> A simple\n    (Hilbert-style) proof system. Natural deduction systems.\n    Sequent calculus rules. Sample proofs.</li>\n<li><strong>First order logic.</strong> Basic syntax.\n    Quantifiers. Semantics (truth definition).</li>\n<li><strong>Formal reasoning in FOL.</strong> Free\n    <em>versus</em> bound variables. Substitution. Equivalences for\n    quantifiers. Sequent calculus rules. Examples.</li>\n<li><strong>Clausal proof methods.</strong> Clause form. A\n    SAT-solving procedure. The resolution rule. Examples.\n    Refinements.</li>\n<li><strong>Skolem functions, Unification and Herbrand\u2019s\n    theorem.</strong> Prenex normal form. Skolemisation. Most\n    general unifiers. A unification algorithm. Herbrand models and\n    their properties.</li>\n<li><strong>Resolution theorem-proving and Prolog.</strong>\n    Binary resolution. Factorisation. Example of Prolog execution.\n    Proof by model elimination.</li>\n<li><strong>Satisfiability Modulo Theories.</strong> Decision\n    problems and procedures. How SMT solvers work.</li>\n<li><strong>Binary decision diagrams.</strong> General\n    concepts. Fast canonical form algorithm. Optimisations.\n    Applications.</li>\n<li><strong>Modal logics.</strong> Possible worlds semantics.\n    Truth and validity. A Hilbert-style proof system. Sequent\n    calculus rules.</li>\n<li><strong>Tableaux methods.</strong> Simplifying the sequent\n    calculus. Examples. Adding unification. Skolemisation. The\n    world\u2019s smallest theorem prover?</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to manipulate logical formulas accurately;</li>\n<li>be able to perform proofs using the presented formal\n    calculi;</li>\n<li>be able to construct a small BDD;</li>\n<li>understand the relationships among the various calculi,\n    e.g. SAT solving, resolution and Prolog;</li>\n<li>understand the concept of a decision procedure and the\n    basic principles of \u201csatisfiability modulo theories\u201d.</li>\n<li>be able to apply the unification algorithm and to describe\n    its uses.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Huth, M. and Ryan, M. (2004). <em>Logic in computer science:\n  modelling and reasoning about systems</em>. Cambridge University\n  Press (2nd ed.).<br/>\n  Ben-Ari, M. (2001). <em>Mathematical logic for computer\n  science</em>. Springer (2nd ed.).</p>\n", "course_name": "Logic and Proof", "course_code": "LogicProof", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/LogicProof", "lecturers": ["mj201"], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "Prolog": {"supervisions": 2, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Prolog.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to introduce programming in the\n  Prolog language. Prolog encourages a different programming style\n  to Java or ML and particular focus is placed on programming to\n  solve real problems that are suited to this style. Practical\n  experimentation with the language is strongly encouraged.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to Prolog.</strong> The structure of a\n    Prolog program and how to use the Prolog interpreter.\n    Unification. Some simple programs.</li>\n<li><strong>Arithmetic and lists.</strong> Prolog\u2019s support for\n    evaluating arithmetic expressions and lists. The space\n    complexity of program evaluation discussed with reference to\n    last-call optimisation.</li>\n<li><strong>Backtracking, cut, and negation.</strong> The cut\n    operator for controlling backtracking. Negation as failure and\n    its uses.</li>\n<li><strong>Search and cut.</strong> Prolog\u2019s search method for\n    solving problems. Graph searching exploiting Prolog\u2019s built-in\n    search mechanisms.</li>\n<li><strong>Difference structures.</strong> Difference lists:\n    introduction and application to example programs.</li>\n<li><strong>Building on Prolog.</strong> How particular\n    limitations of Prolog programs can be addressed by techniques\n    such as Constraint Logic Programming (CLP) and tabled\n    resolution.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to write programs in Prolog using techniques such\n    as accumulators and difference structures;</li>\n<li>know how to model the backtracking behaviour of program\n    execution;</li>\n<li>appreciate the unique perspective Prolog gives to problem\n    solving and algorithm design;</li>\n<li>understand how larger programs can be created using the\n    basic programming techniques used in this course.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Bratko, I. (2001). <em>PROLOG programming for artificial\n  intelligence</em>. Addison-Wesley (3rd or 4th\u00a0ed.).<br/>\n  Sterling, L. and Shapiro, E. (1994). <em>The art of Prolog</em>.\n  MIT Press (2nd\u00a0ed.).</p>\n<p>Further reading:</p>\n<p>O\u2019Keefe, R. (1990). <em>The craft of Prolog</em>. MIT Press.\n  [This book is beyond the scope of this course, but it is very\n  instructive. If you understand its contents, you\u2019re more than\n  prepared for the examination.]</p>\n", "course_name": "Prolog", "course_code": "Prolog", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/Prolog", "lecturers": ["ijl20"], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": true, "easter": false}, "ArtInt": {"supervisions": 3, "prerequisite_for": ["NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ArtificialIntelligence.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to some\n  fundamental issues and algorithms in artificial intelligence\n  (AI). The course approaches AI from an algorithmic, computer\n  science-centric perspective; relatively little reference is made\n  to the complementary perspectives developed within psychology,\n  neuroscience or elsewhere. The course aims to provide some\n  fundamental tools and algorithms required to produce AI systems\n  able to exhibit limited human-like abilities, particularly in the\n  form of problem solving by search, game-playing, representing and\n  reasoning with knowledge, planning, and learning.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction.</strong> Alternate ways of thinking\n    about AI. Agents as a unifying view of AI systems.\n    [1\u00a0lecture]</li>\n<li><strong>Search I.</strong> Search as a fundamental paradigm\n    for intelligent problem-solving. Simple, uninformed search\n    algorithms. Tree search and graph search. [1\u00a0lecture]</li>\n<li><strong>Search II.</strong> More sophisticated heuristic\n    search algorithms. The A* algorithm and its properties.\n    Improving memory efficiency: the IDA* and recursive best first\n    search algorithms. Local search and gradient descent.\n    [1\u00a0lecture]</li>\n<li><strong>Game-playing.</strong> Search in an adversarial\n    environment. The minimax algorithm and its shortcomings.\n    Improving minimax using alpha-beta pruning.\n    [1\u00a0lecture]</li>\n<li><strong>Constraint satisfaction problems (CSPs).</strong>\n    Standardising search problems to a common format. The\n    backtracking algorithm for CSPs. Heuristics for improving the\n    search for a solution. Forward checking, constraint propagation\n    and arc consistency. [1\u00a0lecture]</li>\n<li><strong>Backjumping in CSPs.</strong> Backtracking,\n    backjumping using Gaschnig\u2019s algorithm, graph-based\n    backjumping. [1\u00a0lecture]</li>\n<li><strong>Knowledge representation and reasoning I.</strong>\n    How can we represent and deal with commonsense knowledge and\n    other forms of knowledge? Semantic networks, frames and rules.\n    How can we use inference in conjunction with a knowledge\n    representation scheme to perform reasoning about the world and\n    thereby to solve problems? Inheritance, forward and backward\n    chaining. [1\u00a0lecture]</li>\n<li><strong>Knowledge representation and reasoning II.</strong>\n    Knowledge representation and reasoning using first order logic.\n    The frame, qualification and ramification problems. The\n    situation calculus. [1\u00a0lecture]</li>\n<li><strong>Planning I.</strong> Methods for planning in\n    advance how to solve a problem. The STRIPS language. Achieving\n    preconditions, backtracking and fixing threats by promotion or\n    demotion: the partial-order planning algorithm.\n    [1\u00a0lecture]</li>\n<li><strong>Planning II.</strong> Incorporating heuristics into\n    partial-order planning. Planning graphs. The GRAPHPLAN\n    algorithm. Planning using propositional logic. Planning as a\n    constraint satisfaction problem. [1\u00a0lecture]</li>\n<li><strong>Neural Networks I.</strong> A brief introduction to\n    supervised learning from examples. Learning as fitting a curve\n    to data. The perceptron. Learning by gradient descent.\n    [1\u00a0lecture]</li>\n<li><strong>Neural Networks II.</strong> Multilayer perceptrons\n    and the backpropagation algorithm. [1\u00a0lecture]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>appreciate the distinction between the popular view of the\n    field and the actual research results;</li>\n<li>appreciate the fact that the computational complexity of\n    most AI problems requires us regularly to deal with approximate\n    techniques;</li>\n<li>be able to design basic problem solving methods based on\n    AI-based search, knowledge representation, reasoning, planning,\n    and learning algorithms.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>The recommended text is:</p>\n<p>* Russell, S. and Norvig, P. (2010). <em>Artificial\n  intelligence: a modern approach</em>. Prentice\u00a0Hall (3rd\n  ed.).</p>\n<p>There are many good books available on artificial\n  intelligence; one alternative is:</p>\n<p>Poole, D. L. and Mackworth, A. K. (2017). <em>Artificial\n  intelligence: foundations of computational agents</em>. Cambridge\n  University Press (2nd ed.).</p>\n<p>For some of the material you might find it useful to consult\n  more specialised texts, in particular:</p>\n<p>Dechter, R. (2003). Constraint processing. Morgan\n  Kaufmann.</p>\n<p>Cawsey, A. (1998). <em>The essence of artificial\n  intelligence</em>. Prentice\u00a0Hall.</p>\n<p>Ghallab, M., Nau, D. and Traverso, P. (2004). Automated\n  planning: theory and practice. Morgan Kaufmann.</p>\n<p>Bishop, C.M. (2006). <em>Pattern recognition and machine\n  learning</em>. Springer.</p>\n<p>Brachman, R.J and Levesque, H.J. (2004). <em>Knowledge\n  Representation and Reasoning</em>. Morgan Kaufmann.</p>\n", "course_name": "Artificial Intelligence", "course_code": "ArtInt", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/ArtInt", "lecturers": ["sbh11"], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "Complexity": {"supervisions": 3, "prerequisite_for": ["Crypto"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComplexityTheory.html", "description": "<h2>Aims</h2>\n<p>The aim of the course is to introduce the theory of\n  computational complexity. The course will explain measures of the\n  complexity of problems and of algorithms, based on time and space\n  used on abstract models. Important complexity classes will be\n  defined, and the notion of completeness established through a\n  thorough study of NP-completeness. Applications to cryptography\n  will be considered.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Algorithms and problems.</strong> Complexity of\n    algorithms and of problems. Lower and upper bounds. Examples:\n    sorting and travelling salesman.</li>\n<li><strong>Time and space.</strong> Models of computation and\n    measures of complexity. Time and space complexity on a Turing\n    machine. Decidability and complexity.</li>\n<li><strong>Time complexity.</strong> Time complexity classes.\n    Polynomial time problems and algorithms. Problems on numbers,\n    graphs and formulas.</li>\n<li><strong>Non-determinism.</strong> Non-deterministic\n    machines. The complexity class NP and its various\n    characterizations. Non-deterministic algorithms for\n    satisfiability and other problems in NP.</li>\n<li><strong>NP-completeness.</strong> Reductions and\n    completeness. NP-completeness of satisfiability.</li>\n<li><strong>More NP-complete problems.</strong> Graph-theoretic\n    problems. Independent set, clique and 3-colourability.</li>\n<li><strong>More NP-complete problems.</strong> Sets, numbers\n    and scheduling. Matching, set covering and knapsack.</li>\n<li><strong>coNP.</strong> Validity of boolean formulae and its\n    completeness. NP\u00a0\u2229\u00a0coNP. Primality and\n    factorisation.</li>\n<li><strong>Cryptographic complexity.</strong> One-way\n    functions. The class UP.</li>\n<li><strong>Space complexity.</strong> Deterministic and\n    non-deterministic space complexity classes. The reachability\n    method. Savitch\u2019s theorem.</li>\n<li><strong>Hierarchy.</strong> The time and space hierarchy\n    theorems and complete problems.</li>\n<li><strong>Descriptive complexity.</strong> Logics capturing\n    complexity classes. Fagin\u2019s theorem.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to analyse practical problems and classify them\n    according to their complexity;</li>\n<li>be familiar with the phenomenon of NP-completeness, and be\n    able to identify problems that are NP-complete;</li>\n<li>be aware of a variety of complexity classes and their\n    interrelationships;</li>\n<li>understand the role of complexity analysis in\n    cryptography.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Papadimitriou, Ch.H. (1994). <em>Computational\n  complexity</em>. Addison-Wesley.<br/>\n  Goldreich, O. (2010). <em>P, NP, and NP-Completeness: the basics\n  of computational complexity</em>. Cambridge University Press.\n  Sipser, M. (1997). <em>Introduction to the theory of\n  computation</em>. PWS.</p>\n", "course_name": "Complexity Theory", "course_code": "Complexity", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/Complexity", "lecturers": [], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "CySecurity": {"supervisions": 3, "prerequisite_for": ["ECommerce"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Cybersecurity.html", "description": "<h2>Aims</h2>\n<p>In today\u2019s digital society, computer security is vital for\n  commercial competitiveness, national security and privacy of\n  individuals. Protection against both criminal and state-sponsored\n  attacks will need a large cohort of skilled individuals with an\n  understanding of the principles of security and with practical\n  experience of the application of these principles. We want you to\n  become one of them. In this adversarial game, to defeat the bad\n  guys, the good guys have to be at least as skilled at them.\n  Therefore this course has a strong foundation of becoming\n  proficient at actual attacks. A theoretical understanding is of\n  course necessary, but without some practice the bad guys will run\n  circles around the good guys. In 12 hours I can\u2019t bring you from\n  zero to the stage where you can invent new attacks and\n  countermeasures, but at least by practicing and dissecting common\n  attacks (akin to \u201cstudying the classics\u201d) I\u2019ll give you a feeling\n  for the kind of adversarial thinking that is required in this\n  field. Large portions of this course are hands-on: you will need\n  to acquire the relevant skills rather than just reading about it.\n  The recommended course textbook will be especially helpful to\n  those with no prior low-level hacking experience.</p>\n<h2>Lectures</h2>\n<ul>\n<li>\n<p><strong>Introduction.</strong><br/>\n      The adversarial nature of security; thinking like the\n      attacker; confidentiality, integrity and availability;\n      systems-level thinking; Trusted Computing Base; role of\n      cryptography.<br/>\n<br/>\n<strong>Fundamentals of access control</strong> (chapter\n      1).<br/>\n      Discretionary vs mandatory access control; discretionary\n      access control in POSIX; file permissions, file ownership,\n      groups, permission bits.<br/>\n<br/>\n<strong>Software security</strong> (spanning 4 book\n      chapters)<br/>\n      Setuid (chapter 2): privileged programs, attack surfaces,\n      exploitable vulnerabilities, privilege escalation from\n      regular user to root.<br/>\n      Buffer overflow (chapter 4): stack memory layout, exploiting\n      a buffer overflow vulnerability, guessing unknown addresses,\n      payload, countermeasures and counter-countermeasures.<br/>\n      Return to libc and return-oriented programming (chapter 5):\n      exploiting a non-executable stack, chaining function calls,\n      chaining ROP gadgets.<br/>\n      SQL injection (chapter 14): vulnerability and its\n      exploitation, countermeasures, input filtering, prepared\n      statements.<br/>\n<br/>\n<strong>Authentication.</strong><br/>\n      Something you know, have, are; passwords, their dominance,\n      their shortcomings and the many attempts at replacing them;\n      password cracking; tokens; biometrics; taxonomy of Single\n      Sign-On systems; password managers.<br/>\n<br/>\n<strong>Web and internet security</strong> (spanning 3 book\n      chapters).<br/>\n      Cross-Site Request Forgery (chapter 12): why cross-site\n      requests, CSRF attacks on HTTP GET and HTTP POST,\n      countermeasures.<br/>\n      Cross-Site Scripting (chapter 13): non-persistent vs\n      persistent XSS, javascript, self-propagating XSS worm,\n      countermeasures;<br/>\n<br/>\n<strong>Human factors.</strong><br/>\n      Users are not the enemy; Compliance budget; Prospect theory;\n      7 principles for systems security.<br/>\n<br/>\n<strong>Additional topics.</strong><br/>\n      Viruses, worms and quines; lockpicking; privilege escalation\n      in physical locks; conclusions.<br/>\n<br/>\n      To complete the course successfully, students must acquire\n      the practical ability to carry out (as opposed to just\n      describing) the exploits mentioned in the syllabus, given a\n      vulnerable system. The low-level hands-on portions of the\n      course are supported by the very helpful course textbook.\n      Those who choose not to study on the recommended textbook\n      will be severely disadvantaged.<br/>\n<br/>\n<strong>Recommended textbook:</strong> Wenliang Du. Computer\n      Security: A Hands-on Approach. 3rd Edition. ISBN:\n      978-17330039-5-7. Published: 1 May 2022.</p>\n<p><a href=\"https://www.handsonsecurity.net\">https://www.handsonsecurity.net</a>.\n      Some chapters freely available online.</p>\n<p><br/>\n<strong>Optional additional books</strong> (not\n      substitutes):</p>\n<p>Ross Anderson, <em>Security Engineering</em> 3rd Ed,\n      Wiley, 2020.\u00a0ISBN: 978-1-119-64278-7. <a href=\"https://www.cl.cam.ac.uk/~rja14/book.html\">https://www.cl.cam.ac.uk/~rja14/book.html</a>.\n      Some chapters freely available online.</p>Paul van Oorschot,\n      <em>Computer Security and the Internet</em>, Springer,\n      2020.\u00a0ISBN: 978-3-030-33648-6 (hardcopy),\n      978-3-030-33649-3 (eBook). <a href=\"https://people.scs.carleton.ca/~paulv/toolsjewels.html\">https://people.scs.carleton.ca/~paulv/toolsjewels.html</a>.\n      All chapters freely available online.\n    </li>\n</ul>\n", "course_name": "Cybersecurity", "course_code": "CySecurity", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/CySecurity", "lecturers": ["fms27"], "lectures": 12, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}, "ForModLang": {"supervisions": 2, "prerequisite_for": ["NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FormalModelsofLanguage.html", "description": "<h2>Aims</h2>\n<p>This course studies formal models of language and considers\n  how they might be relevant to the processing and acquisition of\n  natural languages. The course will extend knowledge of formal\n  language theory; introduce several new grammars; and use concepts\n  from information theory to describe natural language.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Natural language and the Chomsky hierarchy\n    1.</strong> Recap classes of language. Closure properties of\n    language classes. Recap pumping lemma for regular languages.\n    Discussion of relevance (or not) to natural languages (example\n    embedded clauses in English).</li>\n<li><strong>Natural language and the Chomsky hierarchy\n    2.</strong> Pumping lemma for context free languages.\n    Discussion of relevance (or not) to natural languages (example\n    Swiss-German cross serial dependancies). Properties of\n    minimally context sensitive languages. Introduction to tree\n    adjoining grammars.</li>\n<li><strong>Language processing and context free grammar\n    parsing 1.</strong> Recap of context free grammar parsing.\n    Language processing predictions based on top down parsing\n    models (example Yngve\u2019s language processing predictions).\n    Language processing predictions based on probabilistic parsing\n    (example Halle\u2019s language processing predictions).</li>\n<li><strong>Language processing and context free grammar\n    parsing 2.</strong> Introduction to context free grammar\n    equivalent dependancy grammars. Language processing predictions\n    based on Shift-Reduce parsing (examples prosodic look-ahead\n    parsers, Parsey McParseface).</li>\n<li><strong>Grammar induction of language classes.</strong>\n    Introduction to grammar induction. Discussion of relevance (or\n    not) to natural language acquisition. Gold\u2019s theorem.\n    Introduction to context free grammar equivalent categorial\n    grammars and their learnable classes.</li>\n<li><strong>Natural language and information theory 1.</strong>\n    Entropy and natural language typology. Uniform information\n    density as a predictor for language processing.</li>\n<li><strong>Natural language and information theory 2.</strong>\n    Noisy channel encoding as a model for spelling error,\n    translation and language processing.</li>\n<li><strong>Vector space models and word vectors.</strong>\n    Introduction to word vectors (example Word2Vec). Word vectors\n    as predictors for semantic language processing.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand how known natural languages relate to formal\n    languages in the Chomsky hierarchy;</li>\n<li>have knowledge of several context free grammars\n    equivalents;</li>\n<li>understand how we might make predictions about language\n    processing and language acquisition from formal models;</li>\n<li>know how to use information theoretic concepts to describe\n    aspects of natural language.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Jurafsky, D. and Martin, J. (2008). <em>Speech and language\n  processing</em>. Prentice Hall.<br/>\n  Manning, C.D. and Schutze, H. (1999) <em>Foundations of\n  statistical natural language processing</em>. MIT Press.<br/>\n  Ruslan, M. (2003) <em>The Oxford handbook of computational\n  linguistics</em>. Oxford University Press.<br/>\n  Clark, A., Fox, C. and Lappin, S. (2010) <em>The handbook of\n  computational linguistics and natural language processing</em>.\n  Wiley-Blackwell.<br/>\n  Kozen, D. (1997) <em>Automata and computibility</em>.\n  Springer.</p>\n", "course_name": "Formal Models of Language", "course_code": "ForModLang", "course_url": "https://www.cl.cam.ac.uk/teaching/2425/ForModLang", "lecturers": ["pjb48"], "lectures": 8, "year": "2425", "tripos_part": "1b", "michaelmas": false, "lent": false, "easter": true}}