{"Databases": {"supervisions": 3, "prerequisite_for": [], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Databases.html", "description": "<h2>Aims</h2>\n<p>This course introduces basic concepts for database systems as\n  seen from the perspective of application designers. That is, the\n  focus is on the abstractions supported by database management\n  systems and not on how those abstractions are implemented.</p>\n<p>The database world is currently undergoing swift and dramatic\n  transformations largely driven by Internet-oriented applications\n  and services. Today many more options are available to database\n  application developers than in the past and so it is becoming\n  increasingly difficult to sort fact from fiction. The course\n  attempts to cut through the fog with a practical approach that\n  emphasises engineering tradeoffs that underpin these recent\n  developments and also guide our selection of \u201cthe right tool for\n  the job.\u201d</p>\n<p>This course covers three approaches. First, the traditional\n  mainstay of the database industry -- the relational approach --\n  is described with emphasis on eliminating logical redundancy in\n  data. Then two representatives of recent trends are presented --\n  graph-oriented and document-oriented databases. The lectures are\n  supported with two Help and Tick sessions, where students gain\n  hands-on experience and guidance with the Assessed Exercises\n  (ticks).</p>\n<h2>Lectures</h2>\n<ul>\n<li>L1 <strong>Introduction</strong>. What is a database\n    system? What is a data model? Typical DBMS configurations and\n    variations (fast queries or reliable update). In-core, in\n    secondary store or distributed.</li>\n<li>L2 <strong>Conceptual modelling</strong>. Entities,\n    relations, E/R diagrams and implementation-independent\n    modelling, weak entities, cardinality.</li>\n<li>L3+4 <strong>The relational database model</strong>.\n    Implementing E/R models with relational tables. Relational\n    algebra and SQL. Basic query primitives. Update anomalies\n    caused by redundancy. Minimising redundancy with normalised\n    schemas.</li>\n<li>L5 <strong>Transactions</strong>. On-Line Transaction\n    Processing. On-line Analytical Processing. Reliability,\n    throughput, normal forms, ACID, BASE, eventual\n    consistency.</li>\n<li>L6 <strong>Documents and semi-structured data</strong>. The\n    NoSQL, schema-free movement. XML/JSON. Key/value stores.\n    Embracing data redundancy: representing data for fast,\n    application-specific access. Path queries (if time\n    permits).</li>\n<li>L7 <strong>Further SQL</strong>. Multisets, NULL values,\n    aggregates, transitive closure, expressibility (nested queries\n    and recursive SQL).</li>\n<li>L8 <strong>Graph databases</strong>. Optimised for\n    processing enormous numbers of nodes and edges. Implementing\n    E/R models in a graph-oriented database. Comparison of the\n    presented models.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to design entity-relationship diagrams to represent\n    simple database application scenarios</li>\n<li>know how to convert entity-relationship diagrams to\n    relational- and graph-oriented implementations</li>\n<li>understand the fundamental tradeoff between the ease of\n    updating data and the response time of complex queries</li>\n<li>understand that no single data architecture can be used to\n    meet all data management requirements</li>\n<li>be familiar with recent trends in the database area.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Lemahieu, W., Broucke, S. van den and Baesens, B. (2018)\n  <em>Principles of database management</em>. Cambridge University\n  Press.</p>\n", "course_name": "Databases", "course_code": "Databases", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/Databases", "lecturers": ["djg11"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": 3, "prerequisite_for": ["ECAD+Arch", "IntComArch", "OpSystems"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "<h2>Aims</h2>\n<p>The aims of this course are to present the principles of\n  combinational and sequential digital logic design and\n  optimisation at a gate level. The use of n and p channel MOSFETs\n  for building logic gates is also introduced.</p>\n<h2>Topics</h2>\n<ul>\n<li><strong>Introduction.</strong> Semiconductors to computers.\n    Logic variables. Examples of simple logic. Logic gates. Boolean\n    algebra. De Morgan\u2019s theorem.</li>\n<li><strong>Logic minimisation.</strong> Truth tables and\n    normal forms. Karnaugh maps. Quine-McCluskey method.</li>\n<li><strong>Binary adders.</strong> Half adder, full adder,\n    ripple carry adder, fast carry generation.</li>\n<li><strong>Combinational logic design: further\n    considerations.</strong> Multilevel logic. Gate propagation\n    delay. An introduction to timing diagrams. Hazards and hazard\n    elimination. Other ways to implement combinational logic.</li>\n<li><strong>Introduction to practical classes.</strong>\n    Prototyping box. Breadboard and Dual in line (DIL) packages.\n    Wiring.</li>\n<li><strong>Sequential logic.</strong> Memory elements. RS\n    latch. Transparent D latch. Master-slave D flip-flop. T and JK\n    flip-flops. Setup and hold times.</li>\n<li><strong>Sequential logic.</strong> Counters: Ripple and\n    synchronous. Shift registers. System timing - setup time\n    constraint, clock skew, metastability.</li>\n<li><strong>Synchronous State Machines.</strong> Moore and\n    Mealy finite state machines (FSMs). Reset and self starting.\n    State transition diagrams. Elimination of redundant states -\n    row matching and state equivalence/implication table.</li>\n<li><strong>Further state machines.</strong> State assignment:\n    sequential, sliding, shift register, one hot. Implementation of\n    FSMs.</li>\n<li><strong>Introduction to microprocessors.</strong>\n    Microarchitecture, fetch, register access, memory access,\n    branching, execution time.</li>\n<li><strong>Electronics, Devices and Circuits.</strong> Current\n    and voltage, conductors/insulators/semiconductors, resistance,\n    basic circuit theory, the potential divider. Solving non-linear\n    circuits. P-N junction (forward and reverse bias), N and p\n    channel MOSFETs (operation and characteristics) and n-MOSFET\n    logic, e.g., n-MOSFET inverter. Power consumption and switching\n    time problems problems in n-MOSFET logic. CMOS logic (NOT, NAND\n    and NOR gates), logic families, noise margin.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand the relationships between combination logic and\n    boolean algebra, and between sequential logic and finite state\n    machines;</li>\n<li>be able to design and minimise combinational logic;</li>\n<li>appreciate tradeoffs in complexity and speed of\n    combinational designs;</li>\n<li>understand how state can be stored in a digital logic\n    circuit;</li>\n<li>know how to design a simple finite state machine from a\n    specification and be able to implement this in gates and edge\n    triggered flip-flops;</li>\n<li>understand how to use MOSFETs to build digital logic\n    circuits.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Harris, D.M. and Harris, S.L. (2013). <em>Digital design and\n  computer architecture</em>. Morgan Kaufmann (2nd ed.). The first\n  edition is still relevant.<br/>\n  Katz, R.H. (2004). <em>Contemporary logic design</em>.\n  Benjamin/Cummings. The 1994 edition is more than sufficient.<br/>\n  Hayes, J.P. (1993). <em>Introduction to digital logic\n  design</em>. Addison-Wesley.</p>\n<p>Books for reference:</p>\n<p>Horowitz, P. and Hill, W. (1989). <em>The art of\n  electronics</em>. Cambridge University Press (2nd\u00a0ed.) (more\n  analog).<br/>\n  Weste, N.H.E. and Harris, D. (2005). <em>CMOS VLSI Design - a\n  circuits and systems perspective</em>. Addison-Wesley (3rd\n  ed.).<br/>\n  Mead, C. and Conway, L. (1980). <em>Introduction to VLSI\n  systems</em>. Addison-Wesley.<br/>\n  Crowe, J. and Hayes-Gill, B. (1998). <em>Introduction to digital\n  electronics</em>. Butterworth-Heinemann.<br/>\n  Gibson, J.R. (1992). <em>Electronic logic circuits</em>.\n  Butterworth-Heinemann.</p>\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/DigElec", "lecturers": ["ijw24"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMath": {"supervisions": 6, "prerequisite_for": ["CAT", "CompConstr", "CompTheory", "Crypto", "ForModLang", "IntroProb", "MLBayInfer", "MSP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematics.html", "description": "<h2>Aims</h2>\n<p>The course aims to introduce the mathematics of discrete\n  structures, showing it as an essential tool for computer science\n  that can be clever and beautiful.</p>\n<h2>Lectures</h2>\n<ul>\n<li>\n<strong>Proof [5\u00a0lectures].</strong>\n<p>Proofs in practice and mathematical jargon. Mathematical\n      statements: implication, bi-implication, universal\n      quantification, conjunction, existential quantification,\n      disjunction, negation. Logical deduction: proof strategies\n      and patterns, scratch work, logical equivalences. Proof by\n      contradiction. Divisibility and congruences. Fermat\u2019s Little\n      Theorem.</p>\n</li>\n<li>\n<strong>Numbers [5\u00a0lectures].</strong>\n<p>Number systems: natural numbers, integers, rationals,\n      modular integers. The Division Theorem and Algorithm. Modular\n      arithmetic. Sets: membership and comprehension. The greatest\n      common divisor, and Euclid\u2019s Algorithm and Theorem. The\n      Extended Euclid\u2019s Algorithm and multiplicative inverses in\n      modular arithmetic. The Diffie-Hellman cryptographic method.\n      Mathematical induction: Binomial Theorem, Pascal\u2019s Triangle,\n      Fundamental Theorem of Arithmetic, Euclid\u2019s infinity of\n      primes.</p>\n</li>\n<li>\n<strong>Sets [9\u00a0lectures].</strong>\n<p>Extensionality Axiom: subsets and supersets. Separation\n      Principle: Russell\u2019s Paradox, the empty set. Powerset Axiom:\n      the powerset Boolean algebra, Venn and Hasse diagrams.\n      Pairing Axiom: singletons, ordered pairs, products. Union\n      axiom: big unions, big intersections, disjoint unions.\n      Relations: composition, matrices, directed graphs, preorders\n      and partial orders. Partial and (total) functions.\n      Bijections: sections and retractions. Equivalence relations\n      and set partitions. Calculus of bijections: characteristic\n      (or indicator) functions. Finite cardinality and counting.\n      Infinity axiom. Surjections. Enumerable and countable sets.\n      Axiom of choice. Injections. Images: direct and inverse\n      images. Replacement Axiom: set-indexed constructions. Set\n      cardinality: Cantor-Schoeder-Bernstein Theorem, unbounded\n      cardinality, diagonalisation, fixed-points. Foundation\n      Axiom.</p>\n</li>\n<li>\n<strong>Formal languages and automata\n      [5\u00a0lectures].</strong>\n<p>Introduction to inductive definitions using rules and\n      proof by rule induction. Abstract syntax trees. Regular\n      expressions and their algebra. Finite automata and regular\n      languages: Kleene\u2019s theorem and the Pumping Lemma.</p>\n</li>\n</ul>\n<h2>Objectives</h2>\n<p>On completing the course, students should be able to</p>\n<ul>\n<li>prove and disprove mathematical statements using a variety\n    of techniques;</li>\n<li>apply the mathematical principle of induction;</li>\n<li>know the basics of modular arithmetic and appreciate its\n    role in cryptography;</li>\n<li>understand and use the language of set theory in\n    applications to computer science;</li>\n<li>define sets inductively using rules and prove properties\n    about them;</li>\n<li>convert between regular expressions and finite\n    automata;</li>\n<li>use the Pumping Lemma to prove that a language is not\n    regular.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Biggs, N.L. (2002). <em>Discrete mathematics.</em> Oxford\n  University Press (Second Edition).<br/>\n  Davenport, H. (2008). <em>The higher arithmetic: an introduction\n  to the theory of numbers.</em> Cambridge University Press.<br/>\n  Hammack, R. (2013). <em>Book of proof.</em> Privately published\n  (Second edition). Available at:<br/>\n<a href=\"http://www.people.vcu.edu/~rhammack/BookOfProof/index.html\" id=\"tex2html4\" name=\"tex2html4\">http://www.people.vcu.edu/\u00a0rhammack/BookOfProof/index.html</a><br/>\n  Houston, K. (2009). <em>How to think like a mathematician: a\n  companion to undergraduate mathematics.</em> Cambridge University\n  Press.<br/>\n  Kozen, D.C. (1997). <em>Automata and computability</em>.\n  Springer.<br/>\n  Lehman, E.; Leighton, F.T.; Meyer, A.R. (2014). <em>Mathematics\n  for computer science.</em> Available on-line.<br/>\n  Velleman, D.J. (2006). <em>How to prove it: a structured\n  approach.</em> Cambridge University Press (Second Edition).</p>\n", "course_name": "Discrete Mathematics", "course_code": "DiscMath", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/DiscMath", "lecturers": ["mpf23", "js2878"], "lectures": 24, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 3, "prerequisite_for": ["CAT", "NLP", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "<h2>Aims</h2>\n<p>The main aim of this course is to present the basic principles\n  of programming. As the introductory course of the Computer\n  Science Tripos, it caters for students from all backgrounds. To\n  those who have had no programming experience, it will be\n  comprehensible; to those experienced in languages such as C, it\n  will attempt to correct any bad habits that they have learnt.</p>\n<p>A further aim is to introduce the principles of data\n  structures and algorithms. The course will emphasise the\n  algorithmic side of programming, focusing on problem-solving\n  rather than on hardware-level bits and bytes. Accordingly it will\n  present basic algorithms for sorting, searching, etc., and\n  discuss their efficiency using <em>O</em>-notation. Worked\n  examples (such as polynomial arithmetic) will demonstrate how\n  algorithmic ideas can be used to build efficient\n  applications.</p>\n<p>The course will use a functional language (OCaml). OCaml is\n  particularly appropriate for inexperienced programmers, since a\n  faulty program cannot crash and OCaml\u2019s unobtrusive type system\n  captures many program faults before execution. The course will\n  present the elements of functional programming, such as curried\n  and higher-order functions. But it will also introduce\n  traditional (procedural) programming, such as assignments, arrays\n  and references.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to Programming.</strong> The role of\n    abstraction and representation. Introduction to integer and\n    floating-point arithmetic. Declaring functions. Decisions and\n    booleans. Example: integer exponentiation.</li>\n<li><strong>Recursion and Efficiency.</strong> Examples:\n    Exponentiation and summing integers. Iteration <em>versus</em>\n    recursion. Examples of growth rates. Dominance and\n    <em>O</em>-Notation. The costs of some representative\n    functions. Cost estimation.</li>\n<li><strong>Lists.</strong> Basic list operations. Append.\n    Na\u00efve <em>versus</em> efficient functions for length and\n    reverse. Strings.</li>\n<li><strong>More on lists.</strong> The utilities take and\n    drop. Pattern-matching: zip, unzip. A word on polymorphism. The\n    \u201cmaking change\u201d example.</li>\n<li><strong>Sorting.</strong> A random number generator.\n    Insertion sort, mergesort, quicksort. Their efficiency.</li>\n<li><strong>Datatypes and trees.</strong> Pattern-matching and\n    case expressions. Exceptions. Binary tree traversal (conversion\n    to lists): preorder, inorder, postorder.</li>\n<li><strong>Dictionaries and functional arrays.</strong>\n    Functional arrays. Dictionaries: association lists (slow)\n    <em>versus</em> binary search trees. Problems with unbalanced\n    trees.</li>\n<li><strong>Functions as values.</strong> Nameless functions.\n    Currying. The \u201capply to all\u201d functional, map. Examples: The\n    predicate functionals filter and exists.</li>\n<li><strong>Sequences, or lazy lists.</strong> Non-strict\n    functions such as <em>IF</em>. Call-by-need <em>versus</em>\n    call-by-name. Lazy lists. Their implementation in OCaml.\n    Applications, for example Newton-Raphson square roots.</li>\n<li><strong>Queues and search strategies.</strong> Depth-first\n    search and its limitations. Breadth-first search (BFS).\n    Implementing BFS using lists. An efficient representation of\n    queues. Importance of efficient data representation.</li>\n<li><strong>Elements of procedural programming.</strong>\n    Address <em>versus</em> contents. Assignment <em>versus</em>\n    binding. Own variables. Arrays, mutable or not. Introduction to\n    linked lists.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course, students should</p>\n<ul>\n<li>be able to write simple OCaml programs;</li>\n<li>understand the fundamentals of using a data structure to\n    represent some mathematical abstraction;</li>\n<li>be able to estimate the efficiency of simple algorithms,\n    using the notions of average-case, worse-case and amortised\n    costs;</li>\n<li>know the comparative advantages of insertion sort, quick\n    sort and merge sort;</li>\n<li>understand binary search and binary search trees;</li>\n<li>know how to use currying and higher-order functions;</li>\n<li>understand how OCaml combines imperative and functional\n    programming in a single language.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>John Whitington. <em>OCaml from the Very Beginning</em>.\n  (http://ocaml-book.com).</p>\n<p>Okasaki, C. (1998). <em>Purely functional data\n  structures</em>. Cambridge University Press.</p>\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/FoundsCS", "lecturers": ["avsm2"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "HW": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": "\n<p>The Hardware Practical Classes accompany the Digital\n  Electronics series of lectures. The aim of the Practical Classes\n  is to enable students to get hands-on experience of designing,\n  building, and testing and debugging of digital electronic\n  circuits. The labs will take place in the Intel Lab. located in\n  the William Gates Building (WGB).</p>\n<p>The Digital Electronics lecture series occupies 12 lectures in\n  the first 4 weeks of the Michaelmas Term, while the Practical\n  Classes occupy the latter 6 weeks of the Michaelmas Term and the\n  first 6 weeks of the Lent Term. If required, extra sessions will\n  be available for any students needing to 'catch-up' on missed\n  sessions or to complete any remaining practical work.</p>\n<p>The Practical Classes take the form of 4 workshops,\n  specifically:</p>\n<ul>\n<li>Workshop 1 \u2013 Electronic Die;</li>\n<li>Workshop 2 \u2013 Shaft Position Encoder;</li>\n<li>Workshop 3 \u2013 Debouncing a Switch;</li>\n<li>Workshop 4 \u2013 Framestore for an LED Array.</li>\n</ul>\n<p>In general, the workshops require some preparatory work to be\n  done prior to the practical session. These tasks are highlighted\n  at the beginning of each Worksheet. Typically this involves\n  preparing a design that you will then build, test and modify\n  during the practical class. Note that insufficient preparation\n  prior to the practical classes may compromise effective use of\n  your time in the Intel lab.</p>\n<p>In the Practical Classes you will usually work on your own,\n  and you are expected to complete one Workshop in each of your\n  scheduled sessions. Demonstrators are available during the\n  sessions to assist you with any queries or problems you may\n  have.</p>\n<p>Important: Remember to get your work ticked.</p>\n", "course_name": "Hardware Practical Classes", "course_code": "HW", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/HW", "lecturers": ["ijw24"], "lectures": null, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Graphics": {"supervisions": 2, "prerequisite_for": ["ER", "FGraphics"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoGraphics.html", "description": "<h2>Aims</h2>\n<p>To introduce the necessary background, the basic algorithms,\n  and the applications of computer graphics and graphics\n  hardware.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Background.</strong> What is an image? Resolution\n    and quantisation. Storage of images in memory. [1 lecture]</li>\n<li><strong>Rendering.</strong> Perspective. Reflection of\n    light from surfaces and shading. Geometric models. Ray tracing.\n    [2 lectures]</li>\n<li><strong>Graphics pipeline.</strong> Polygonal mesh models.\n    Transformations using matrices in 2D and 3D. Homogeneous\n    coordinates. Projection: orthographic and perspective. [1\n    lecture]</li>\n<li><strong>Graphics hardware and modern OpenGL.</strong> GPU\n    rendering. GPU frameworks and APIs. Vertex processing.\n    Rasterisation. Fragment processing. Working with meshes and\n    textures. Z-buffer. Double-buffering and frame synchronization.\n    [2 lectures]</li>\n<li>\u00a0</li>\n<li><strong>Human vision, colour and tone mapping</strong>.\n    Perception of colour. Tone mapping. Colour spaces. [2\n    lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should be able to:</p>\n<ul>\n<li>understand and apply in practice basic concepts of\n    ray-tracing: ray-object intersection, reflections, refraction,\n    shadow rays, distributed ray-tracing, direct and indirect\n    illumination;</li>\n<li>describe and explain the following algorithms: z-buffer,\n    texture mapping, double buffering, mip-map, and\n    normal-mapping;</li>\n<li>use matrices and homogeneous coordinates to represent and\n    perform 2D and 3D transformations; understand and use 3D to 2D\n    projection, the viewing volume, and 3D clipping;</li>\n<li>implement OpenGL code for rendering of polygonal objects,\n    control camera and lighting, work with vertex and fragment\n    shaders;</li>\n<li>describe a number of colour spaces and their relative\n    merits.</li>\n<li>explain the need for tone mapping and colour processing in\n    rendering pipeline.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Shirley, P. and Marschner, S. (2009). <em>Fundamentals of\n  Computer Graphics</em>. CRC Press (3rd ed.).</p>\n<p>Foley, J.D., van Dam, A., Feiner, S.K. and Hughes, J.F.\n  (1990). <em>Computer graphics: principles and practice</em>.\n  Addison-Wesley (2nd ed.).</p>\n<p>Kessenich, J.M., Sellers, G. and Shreiner, D (2016).\n  <em>OpenGL Programming Guide: The Official Guide to Learning\n  OpenGL, Version 4.5 with SPIR-V</em>, [seventh edition and\n  later]</p>\n", "course_name": "Introduction to Graphics", "course_code": "Graphics", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/Graphics", "lecturers": ["rkm38"], "lectures": 8, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OOProg": {"supervisions": 3, "prerequisite_for": ["ConcDisSys", "FJava", "MSP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Object-OrientedProgramming.html", "description": "<h2>Aims</h2>\n<p>The goal of this course is to provide students with an\n  understanding of Object-Oriented Programming. Concepts are\n  demonstrated in multiple languages, but the primary language is\n  Java.</p>\n<h2>Lecture syllabus</h2>\n<ul>\n<li><strong>Types, Objects and Classes</strong> Moving from\n    functional to imperative. Functions, methods. Control flow.\n    values, variables and types. Primitive Types. Classes as custom\n    types. Objects vs Classes. Class definition, constructors.\n    Static data and methods.</li>\n<li><strong>Designing Classes</strong> Identifying classes. UML\n    class diagrams. Modularity. Encapsulation/data hiding.\n    Immutability. Access modifiers. Parameterised types\n    (Generics).</li>\n<li><strong>Pointers, References and Memory</strong> Pointers\n    and references. Reference types in Java. The call stack. The\n    heap. Iteration and recursion. Pass-by-value and\n    pass-by-reference.</li>\n<li><strong>Inheritance</strong> Inheritance. Casting.\n    Shadowing. Overloading. Overriding. Abstract Methods and\n    Classes.</li>\n<li><strong>Polymorphism and Multiple Inheritance</strong>\n    Polymorphism in ML and Java. Multiple inheritance. Interfaces\n    in Java.</li>\n<li><strong>Lifecycle of an Object</strong> Constructors and\n    chaining. Destructors. Finalizers. Garbage Collection:\n    reference counting, tracing.</li>\n<li><strong>Java Collections and Object Comparison</strong>\n    Java Collection interface. Key classes. Collections class.\n    Iteration options and the use of Iterator. Comparing primitives\n    and objects. Operator overloading.</li>\n<li><strong>Error Handling</strong> Types of errors.\n    Limitations of return values. Deferred error handling.\n    Exceptions. Custom exceptions. Checked vs unchecked.\n    Inappropriate use of exceptions. Assertions.</li>\n<li><strong>DesignLanguage evolution</strong> Need for\n    languages to evolve. Generics in Java. Type erasure.\n    Introduction to Java 8: Lambda functions, functions as values,\n    method references, streams.</li>\n<li><strong>Design Patterns</strong> Introduction to design\n    patterns. Open-closed principle. Examples of Singleton,\n    Decorator, State, Composite, Strategy, Observer. [2\n    lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>Provide an overview of key OOP concepts that are\n    transferable in mainstream programming languages;</li>\n<li>Gain an understanding of software development approaches\n    adopted in the industry including maintainability, testing, and\n    software design patterns;</li>\n<li>Increase programming familiarity with Java;</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>1. Real-World Software Development: A Project-Driven Guide to\n  Fundamentals in Java [Urma et al.]<br/>\n  2. Modern Java in Action (2nd edition) [Urma et al.].<br/>\n  3. Java How to Program: early objects [Deitel et al.]</p>\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/OOProg", "lecturers": ["rkh23"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OCaml": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "OCaml Practical Classes", "course_code": "OCaml", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/OCaml", "lecturers": ["jjl25"], "lectures": null, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/Registratn", "lecturers": ["arb33", "rkh23"], "lectures": null, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "SciComp": {"supervisions": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "<h2>Aims</h2>\n<p>This course is a hands-on introduction to using computers to\n  investigate scientific models and data.</p>\n<h2>Syllabus</h2>\n<ul>\n<li>Python notebooks. Overview of the Python programming\n    language. Use of notebooks for scientific computing.</li>\n<li>Numerical computation. Writing fast vectorized code in\n    numpy. Optimization and fitting. Simulation.</li>\n<li>Working with data. Data import. Common ways to summarize\n    and plot data, for univariate and multivariate analysis.</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>be able to import data, plot it, and summarize it\n    appropriately</li>\n<li>be able to write fast vectorized code for scientific / data\n    work</li>\n</ul>\n", "course_name": "Scientific Computing", "course_code": "SciComp", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/SciComp", "lecturers": ["djw1005", "awm22"], "lectures": 1, "year": "2324", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "Algorithm1": {"supervisions": 3, "prerequisite_for": ["Algorithm2", "ArtInt", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms1.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  computer algorithms and data structures, with an emphasis on\n  foundational material.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Sorting.</strong> Review of complexity and\n    O-notation. Trivial sorting algorithms of quadratic complexity.\n    Review of merge sort and quicksort, understanding their memory\n    behaviour on statically allocated arrays. Heapsort. Stability.\n    Other sorting methods including sorting in linear time. Median\n    and order statistics. [Ref: CLRS3 chapters 1, 2, 3, 6, 7, 8, 9]\n    [about 4 lectures]</li>\n<li><strong>Strategies for algorithm design.</strong> Dynamic\n    programming, divide and conquer, greedy algorithms and other\n    useful paradigms. [Ref: CLRS3 chapters 4, 15, 16] [about 3\n    lectures]</li>\n<li><strong>Data structures.</strong> Elementary data\n    structures: pointers, objects, stacks, queues, lists, trees.\n    Binary search trees. Red-black trees. B-trees. Hash tables.\n    Priority queues and heaps. [Ref: CLRS3 chapters 6, 10, 11, 12,\n    13, 18] [about 5 lectures].</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>have a thorough understanding of several classical\n    algorithms and data structures;</li>\n<li>be able to analyse the space and time efficiency of most\n    algorithms;</li>\n<li>have a good understanding of how a smart choice of data\n    structures may be used to increase the efficiency of particular\n    algorithms;</li>\n<li>be able to design new algorithms or modify existing ones\n    for new applications and reason about the efficiency of the\n    result.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and\n  Clifford Stein Introduction to Algorithms, Fourth Edition ISBN\n  9780262046305 Published: April 5, 2022.</p>\n<p>Sedgewick, R., Wayne, K. (2011). <em>Algorithms</em>.\n  Addison-Wesley. ISBN 978-0-321-57351-3.</p>\n<p>Kleinberg, J. and Tardos, \u00c9. (2006). <em>Algorithm\n  design</em>. Addison-Wesley. ISBN 978-0-321-29535-4.</p>\n<p>Knuth, D.A. (2011). <em>The Art of Computer Programming</em>.\n  Addison-Wesley. ISBN 978-0-321-75104-1.</p>\n", "course_name": "Algorithms 1", "course_code": "Algorithm1", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/Algorithm1", "lecturers": ["djw1005"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "Algorithm2": {"supervisions": 3, "prerequisite_for": ["ArtInt", "Complexity", "Prolog", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Algorithms2.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  computer algorithms and data structures, with an emphasis on\n  foundational material.</p>\n<h2>Lectures</h2>\n<ul style=\"list-style-type:square\">\n<li><strong>Graphs and path-finding algorithms.</strong> Graph\n    representations. Breadth-first and depth-first search.\n    Single-source shortest paths: Bellman-Ford and Dijkstra\n    algorithms. All-pairs shortest paths: dynamic programming and\n    Johnson\u2019s algorithms. [About 4 lectures]</li>\n<li><strong>Graphs and subgraphs.</strong> Maximum flow:\n    Ford-Fulkerson method, Max-flow min-cut theorem. Matchings in\n    bipartite graphs. Minimum spanning tree: Kruskal and Prim\n    algorithms. Topological sort. [About 4 lectures]</li>\n<li><strong>Advanced data structures.</strong> Binomial heap.\n    Amortized analysis: aggregate analysis, potential method.\n    Fibonacci heaps. Disjoint sets. [About 4 lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should:</p>\n<ul>\n<li>have a thorough understanding of several classical\n    algorithms and data structures;</li>\n<li>be able to analyse the space and time efficiency of most\n    algorithms;</li>\n<li>have a good understanding of how a smart choice of data\n    structures may be used to increase the efficiency of particular\n    algorithms;</li>\n<li>be able to design new algorithms or modify existing ones\n    for new applications and reason about the efficiency of the\n    result.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and\n  Clifford Stein Introduction to Algorithms, Fourth Edition ISBN\n  9780262046305 Published: April 5, 2022.</p>\n<p>Sedgewick, R., Wayne, K. (2011). Algorithms. Addison-Wesley.\n  ISBN 978-0-321-57351-3.</p>\n<p>Kleinberg, J. and Tardos, \u00c9. (2006). Algorithm design.\n  Addison-Wesley. ISBN 978-0-321-29535-4.</p>\n<p>Knuth, D.A. (2011). The Art of Computer Programming.\n  Addison-Wesley. ISBN 978-0-321-75104-1.</p>\n<p>\u00a0</p>\n<p>\u00a0</p>\n", "course_name": "Algorithms 2", "course_code": "Algorithm2", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/Algorithm2", "lecturers": ["djw1005"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "MLRD": {"supervisions": 4, "prerequisite_for": ["ADS", "NLP"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-MachineLearningandReal-worldData.html", "description": "<h2>Aims</h2>\n<p>This course introduces students to machine learning algorithms\n  as used in real-world applications, and to the experimental\n  methodology necessary to perform statistical analysis of\n  large-scale data from unpredictable processes. Students will\n  perform 3 extended practicals, as follows:</p>\n<ul>\n<li>Statistical classification: Determining movie review\n    sentiment using Naive Bayes (7 sessions);</li>\n<li>Sequence Analysis: Hidden Markov Modelling and its\n    application to a task from biology (predicting protein\n    interactions with a cell membrane) (4 sessions);</li>\n<li>Analysis of social networks, including detection of cliques\n    and central nodes (5 sessions).</li>\n</ul>\n<h2>Syllabus</h2>\n<ul>\n<li><strong>Topic One: Statistical Classification [7\n    sessions].</strong><br/>\n    Introduction to sentiment classification.<br/>\n    Naive Bayes parameter estimation.<br/>\n    Statistical laws of language.<br/>\n    Statistical tests for classification tasks.<br/>\n    Cross-validation and test sets.<br/>\n    Uncertainty and human agreement.</li>\n<li><strong>Topic Two: Sequence Analysis [4\n    sessions].</strong><br/>\n    Hidden Markov Models (HMM) and HMM training.<br/>\n    The Viterbi algorithm.<br/>\n    Using an HMM in a biological application.</li>\n<li><strong>Topic Three: Social Networks [5\n    sessions].</strong><br/>\n    Properties of networks: Degree, Diameter.<br/>\n    Betweenness Centrality.<br/>\n    Clustering using betweenness centrality.</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should be able to:</p>\n<ul>\n<li>understand and program two simple supervised machine\n    learning algorithms;</li>\n<li>use these algorithms in statistically valid experiments,\n    including the design of baselines, evaluation metrics,\n    statistical testing of results, and provision against\n    overtraining;</li>\n<li>visualise the connectivity and centrality in large\n    networks;</li>\n<li>use clustering (i.e., a type of unsupervised machine\n    learning) for detection of cliques in unstructured\n    networks.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>Jurafsky, D. and Martin, J. (2008). <em>Speech and language\n  processing</em>. Prentice Hall.</p>\n<p>Easley, D. and Kleinberg, J. (2010). <em>Networks, crowds, and\n  markets: reasoning about a highly connected world</em>. Cambridge\n  University Press.</p>\n", "course_name": "Machine Learning and Real-world Data", "course_code": "MLRD", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/MLRD", "lecturers": ["sht25", "av308"], "lectures": 16, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OpSystems": {"supervisions": 3, "prerequisite_for": ["ConcDisSys", "UnixTools"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "<h2>Aims</h2>\n<p>The overall aim of this course is to provide a general\n  understanding of the structure and key functions of the operating\n  system. Case studies will be used to illustrate and reinforce\n  fundamental concepts.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Introduction to operating systems.</strong>\n    Elementary computer organisaton. Abstract view of an operating\n    system. Key concepts: layering, multiplexing, performance,\n    caching, buffering, policies <em>versus</em> mechanisms. OS\n    evolution: multi-programming, time-sharing. Booting.\n    [1\u00a0lecture]</li>\n<li><strong>Protection.</strong> Dual-mode operation.\n    Protecting CPU, memory, I/O, storage. Kernels, micro-kernels,\n    and modules. System calls. Virtual machines and containers.\n    Subjects and objects. Authentication. Access matrix: ACLs and\n    capabilities. Covert channels. [1\u00a0lecture]</li>\n<li><strong>Processes.</strong> Job/process concepts. Process\n    lifecycle. Process management. Context switching. Inter-process\n    communication. [1\u00a0lecture]</li>\n<li><strong>Scheduling.</strong> CPU-I/O burst cycle.\n    Scheduling basics: preemption and non-preemption. Scheduling\n    algorithms: FCFS, SJF, SRTF, Priority, and Round Robin.\n    Multilevel scheduling. [2\u00a0lectures]</li>\n<li><strong>Memory management.</strong> Processes in memory.\n    Logical <em>versus</em> physical addresses. Partitions: static\n    <em>versus</em> dynamic, free space management, external\n    fragmentation. Segmented memory. Paged memory: concepts,\n    internal fragmentation, page tables. Demand\n    paging/segmentation. Page replacement strategies: FIFO, OPT,\n    and LRU with approximations including NRU, LFU, MFU, MRU.\n    Working set schemes. Thrashing. [3\u00a0lectures]</li>\n<li><strong>I/O subsystem.</strong> General structure. Polled\n    mode <em>versus</em> interrupt-driven I/O. Programmed I/O (PIO)\n    <em>versus</em> Direct Memory Access (DMA). Application I/O\n    interface: block and character devices, buffering, blocking,\n    non-blocking, asynchronous, and vectored I/O. Other issues:\n    caching, scheduling, spooling, performance.\n    [1\u00a0lecture]</li>\n<li><strong>File management.</strong> File concept. Directory\n    and storage services. File names and metadata. Directory\n    name-space: hierarchies, DAGs, hard and soft links. File\n    operations. Access control. Existence and concurrency control.\n    [1\u00a0lecture]</li>\n<li><strong>Unix case study.</strong> History. General\n    structure. Unix file system: file abstraction, directories,\n    mount points, implementation details. Processes: memory image,\n    lifecycle, start of day. The shell: basic operation, commands,\n    standard I/O, redirection, pipes, signals. Character and block\n    I/O. Process scheduling. [2\u00a0lectures]</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should be able to:</p>\n<ul>\n<li>describe the general structure and purpose of an operating\n    system;</li>\n<li>explain the concepts of process, address space, and\n    file;</li>\n<li>compare and contrast various CPU scheduling\n    algorithms;</li>\n<li>compare and contrast mechanisms involved in memory and\n    storage management;</li>\n<li>compare and contrast polled, interrupt-driven, and\n    DMA-based access to I/O devices.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Silberschatz, A., Galvin, P.C., and Gagne, G. (2018).\n  <em>Operating systems concepts</em>. Wiley (10th ed.). Prior\n  editions, at least back to 8th ed., should also be\n  acceptable.<br/>\n  Anderson, T. and Dahlin, M. (2014). <em>Operating Systems:\n  Principles and Practice</em>. Recursive Books (2nd ed.).<br/>\n  Bacon, J. and Harris, T. (2003). <em>Operating systems</em>.\n  Addison-Wesley (3rd ed.). Currently appears out-of-print.<br/>\n  Leffler, S. (1989). <em>The design and implementation of the\n  4.3BSD Unix operating system</em>. Addison-Wesley.<br/>\n  McKusick, M.K., Neville-Neil, G.N. and Watson, R.N.M. (2014)\n  <em>The Design and Implementation of the FreeBSD Operating\n  System</em>. Pearson Education. (2nd ed.).</p>\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/OpSystems", "lecturers": ["rmm1002"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "IntDesign": {"supervisions": 2, "prerequisite_for": ["FHCI"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-InteractionDesign.html", "description": "<h2>Aims</h2>\n<p>The aim of this course is to provide an introduction to\n  interaction design, with an emphasis on understanding and\n  experiencing the user-centred design process, from conducting\n  user research and requirements development to implementation and\n  evaluation, while understanding the background to human-computer\n  interaction.</p>\n<h2>Lectures</h2>\n<ul>\n<li><strong>Course overview and user research methods</strong>.\n    Introduction to the course and practicals. User-Centred Design.\n    User research methods.</li>\n<li><strong>Keeping usera in mind</strong>. User research data\n    analysis. Identifying users and stakeholders. Representing user\n    goals and activities. Identifying and establishing\n    requirements.</li>\n<li><strong>Design and prototyping</strong>. Methods for\n    exploring the design space. Prototyping and different kinds of\n    prototypes.</li>\n<li><strong>Visual and interaction design</strong>. Memory,\n    perception, attention, and their implications for interaction\n    design. Modalities of interaction, interaction design patterns,\n    information architecture, and their implications for\n    interaction design.</li>\n<li><strong>Evaluation</strong>. Practical methods for\n    evaluating designs. Evaluation methods without users.\n    Evaluation methods with users.</li>\n<li><strong>Case studies from industry and research</strong>.\n    Guest lectures (the topics of these lectures are subject to\n    change).</li>\n</ul>\n<h2>Objectives</h2>\n<p>By the end of the course students should</p>\n<ul>\n<li>have a thorough understanding of the user-centred design\n    process and be able to apply it to interaction design;</li>\n<li>be able to design new user interfaces that are informed by\n    principles of good design, and the principles of human visual\n    perception, cognition and communication;</li>\n<li>be able to prototype and implement interactive user\n    interfaces with a strong emphasis on users, usability and\n    appearance;</li>\n<li>be able to evaluate existing or new user interfaces using\n    multiple techniques;</li>\n<li>be able to compare and contrast different design techniques\n    and to critique their applicability to new domains.</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Preece, J., Rogers, Y. and Sharp, H. (2015). <em>Interaction\n  design</em>. Wiley (4th ed.).</p>\n", "course_name": "Interaction Design", "course_code": "IntDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/IntDesign", "lecturers": ["hg410"], "lectures": 16, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "IntroProb": {"supervisions": 3, "prerequisite_for": ["CSM", "RandAlgthm"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-IntroductiontoProbability.html", "description": "<h2>Aims</h2>\n<p>This course provides an elementary introduction to probability\n  and statistics with applications. Probability theory and the\n  related field of statistical inference provide the foundations\n  for analysing and making sense of data. The focus of this course\n  is to introduce the language and core concepts of probability\n  theory. The course will also cover some applications of\n  statistical inference and algorithms in order to equip students\n  with the ability to represent problems using these concepts and\n  analyse the data within these principles.</p>\n<h2>Lectures</h2>\n<p>Part 1 - Introduction to Probability</p>\n<ul>\n<li><strong>Introduction.</strong> Counting/Combinatorics\n    (revision), Probability Space, Axioms, Union Bound.</li>\n<li><strong>Conditional probability.</strong> Conditional\n    Probabilities and Independence, Bayes\u2019Theorem, Partition\n    Theorem</li>\n</ul>\n<p>Part 2 - Discrete Random Variables</p>\n<ul>\n<li><strong>Random variables.</strong> Definition of a Random\n    Variable, Probability Mass Function, Cumulative Distribution,\n    Expectation.</li>\n<li><strong>Probability distributions.</strong> Definition and\n    Properties of Expectation, Variance, different ways of\n    computing them, Examples of important Distributions (Bernoulli,\n    Binomial, Geometric, Poisson), Primer on Continuous\n    Distributions including Normal and Exponential\n    Distributions.</li>\n<li><strong>Multivariate distributions.</strong> Multiple\n    Random Variables, Joint and Marginal Distributions,\n    Independence of Random Variables, Covariance.</li>\n</ul>\n<p>Part 3 - Moments and Limit Theorems</p>\n<ul>\n<li><strong>Introduction.</strong> Law of Average, Useful\n    inequalities (Markov and Chebyshef), Weak Law of Large Numbers\n    (including Proof using Chebyshef\u2019s inequality), Examples.</li>\n<li><strong>Moments and Central Limit Theorem.</strong>\n    Introduction to Moments of Random Variables, Central Limit\n    Theorem (Proof using Moment Generating functions),\n    Example.</li>\n</ul>\n<p>Part 4 - Applications/Statistics</p>\n<ul>\n<li><strong>Statistics.</strong> Classical Parameter Estimation\n    (Maximum-Likelihood-Estimation), bias, sample mean, sample\n    variance), Examples (Collision-Sampling, Estimating Population\n    Size).</li>\n<li><strong>Algorithms.</strong> Online Algorithms (Secretary\n    Problem, Odd\u2019s Algorithm).</li>\n</ul>\n<h2>Objectives</h2>\n<p>At the end of the course students should</p>\n<ul>\n<li>understand the basic principles of probability spaces and\n    random variables</li>\n<li>be able to formulate problems using concepts from\n    probability theory and compute or estimate probabilities</li>\n<li>be familiar with more advanced concepts such as moments,\n    limit theorems and applications such as parameter\n    estimation</li>\n</ul>\n<h2>Recommended reading</h2>\n<p>* Ross, S.M. (2014). <em>A First course in probability</em>.\n  Pearson (9th ed.).</p>\n<p>Bertsekas, D.P. and Tsitsiklis, J.N. (2008). <em>Introduction\n  to probability</em>. Athena Scientific.</p>\n<p>Grimmett, G. and Welsh, D. (2014). <em>Probability: an\n  Introduction</em>. Oxford University Press (2nd ed.).</p>\n<p>Dekking, F.M., et. al. (2005) <em>A modern introduction to\n  probability and statistics</em>. Springer.</p>\n", "course_name": "Introduction to Probability", "course_code": "IntroProb", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/IntroProb", "lecturers": ["mj201", "tms41"], "lectures": 12, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "SWSecEng": {"supervisions": 3, "prerequisite_for": ["CYC", "CySecurity"], "past_exam_questions": "https://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareandSecurityEngineering.html", "description": "<h2>Aims</h2>\n<p>This course aims to introduce students to software and\n  security engineering, and in particular to the problems of\n  building large systems, safety-critical systems and systems that\n  must withstand attack by capable opponents. Case histories of\n  failure are used to illustrate what can go wrong,\n  while\u00a0current software and security engineering practice is\n  studied as a guide to how failures can be avoided.</p>\n<h2>Lectures</h2>\n<p><strong>1. What is a security policy or a safety case?\n  Definitions and examples;</strong> one-way flows for both\n  confidentiality and safety properties; separation of duties.\n  Top-down and bottom-up analysis methods. What architecture can\n  do, versus benefits of decoupling policy from mechanism.</p>\n<p><strong>2. Examples of safety and security policies.</strong>\n  Safety and security usability; the pyramid of harms. Predicting\n  and mitigating user errors. The prevention of fraud and error in\n  accounting systems; the safety usability of medical devices.</p>\n<p><strong>3. Attitudes to risk:</strong> expected\u00a0 utility,\n  prospect theory, framing, status quo bias. Authority, conformity\n  and gender; mental models, affordances and defaults. The\n  characteristics of human memory; forgetting passwords versus\n  guessing them.</p>\n<p><strong>4. Security protocols;</strong> how to enforce policy\n  using\u00a0 structured human interaction, cryptography or both.\n  Middleperson attacks.The role of verification and its\n  limitations.</p>\n<p><strong>5. Attacks on TLS, from rogue CAs through side\n  channels to Heartbleed.</strong> Other types of software bugs:\n  syntactic, timing, concurrency, code injection, buffer overflows.\n  Defensive\u00a0programming: secure coding, contracts.\n  Fuzzing.</p>\n<p><strong>6. The software crisis.</strong> Examples of\n  large-scale project failure, such as the London Ambulance Service\n  system and the NHS National Programme for IT. Intrinsic\n  difficulties with complex software.</p>\n<p><strong>7. Software engineering as the management of\n  complexity.\u00a0</strong>The software life cycle; requirements\n  analysis methods; modular design; the role of prototyping; the\n  waterfall, spiral and agile models.</p>\n<p><strong>8. The economics of software as a Service\n  (SaaS);</strong> the impact SaaS has on software engineering.\n  Continuous integration, release engineering, behavioural\n  analytics and experiment frameworks, rearchitecting systems while\n  in operation.</p>\n<p><strong>9. Critical systems:</strong> safety as an emergent\n  system property.\u00a0Examples of catastrophic failure: from\n  Therac-25 to the Boeing 737Max. The problems of managing\n  redundancy.\u00a0The overall process of safety engineering.</p>\n<p><strong>10. Managing the development of critical\n  systems:</strong> tools and methods, individual versus group\n  productivity, economics of testing and agile development,\n  measuring outcomes versus process, the technical and human\n  aspects of management, post-market surveillance and coordinated\n  disclosure. The sustainability of products with software\n  components.</p>\n<p>At the end of the course students should know how writing\n  programs with tough assurance targets, in large teams, or both,\n  differs from the programming exercises they have engaged in so\n  far. They should understand the different models of software\n  development described in the course as well as the value of\n  various development and management tools. They should understand\n  the development life cycle and its basic economics. They should\n  understand the various types of bugs, vulnerabilities and\n  hazards, how to find them, and how to avoid introducing them.\n  Finally, they should be prepared for the organizational aspects\n  of their Part\u00a0IB group project.</p>\n<h2>Recommended reading</h2>\n<p>Anderson, R. (Third Edition 2020). <em>Security\n  engineering</em> (Part 1 and Chapters 27-28). Wiley. Available\n  at: <a href=\"http://www.cl.cam.ac.uk/users/rja14/book.html\" id=\"tex2html5\" name=\"tex2html5\">http://www.cl.cam.ac.uk/users/rja14/book.html</a></p>\n", "course_name": "Software and Security Engineering", "course_code": "SWSecEng", "course_url": "https://www.cl.cam.ac.uk/teaching/2324/SWSecEng", "lecturers": ["rkh23", "arb33", "rmm1002", "mk428", "avsm2"], "lectures": 11, "year": "2324", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}