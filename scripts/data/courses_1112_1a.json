{"CompFunds": {"supervisions": null, "lectures": 4, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ComputerFundamentals.html", "description": "\n\n\n<a name=\"SECTION02021100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02021200000000000000\">Lectures</a>\n\n<li><b>Computer components</b>.  Brief history. Main components: CPU,\n  memory, peripherals (displays, graphics cards, hard drives, flash\n  drives, simple input devices), motherboard, buses.\n\n<p></p></li>\n<li><b>Data representation and operations</b>.  Simple model of\n  memory. Bits and bytes. Binary, hex, octal, decimal\n  numbers. Character and numeric arrays. Data as instructions:\n  von-Neumann architecture, fetch-execute cycle, program counter (PC).\n\n<p></p></li>\n<li><b>Low- and high-level computing</b>.  Pointers. The stack and\n  heap. Box and Pointer Diagrams. Levels of abstraction: machine code,\n  assembly, high-level languages. Compilers and\n  interpreters. Read-eval-print loop model.\n\n<p></p></li>\n<li><b>Platforms and multitasking</b>.  The need for operating\n  systems. Multicore systems, time-slicing. Virtual machines. The Java\n  bytecode/VM approach to portability. ML as a high-level language\n  emphasising mathematical expressivity over input-output.\n\n<p></p></li>\n\n\n<a name=\"SECTION02021300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>describe the fetch-execute cycle of a simple computer with\n  reference to the control and execution units;\n\n<p></p></li>\n<li>understand the different types of information which may be\n  stored within a computer memory;\n\n<p></p></li>\n<li>understand a simple assembly language program. \n\n<p></p></li>\n\n\n<a name=\"SECTION02021400000000000000\">Recommended reading</a>\n\nPatterson, D. &amp; Hennessy, J. (2009). <em>Computer organisation and design</em>. Morgan Kaufmann (4th ed.).\n<br/>Tanenbaum, A.S. (1990). <em>Structured computer organisation</em>. Prentice\u00a0Hall (3rd ed).\n<br/>\n", "course_name": "Computer Fundamentals", "course_code": "CompFunds", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/CompFunds", "lecturers": ["rkh23"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DigElec": {"supervisions": null, "lectures": 11, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DigitalElectronics.html", "description": "\n\n\n<a name=\"SECTION02024100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02024200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Semiconductors to computers. Logic\n  variables. Examples of simple logic. Logic gates. Boolean\n  algebra. De Morgan\u2019s theorem.\n\n<p></p></li>\n<li><b>Logic minimisation.</b>  Truth tables and normal forms. Karnaugh maps.\n\n<p></p></li>\n<li><b>Binary adders.</b>  Half adder, full adder, ripple carry\n  adder, fast carry generation.\n\n<p></p></li>\n<li><b>Combinational logic design: further considerations.</b>\n  Multilevel logic.  Gate propagation delay. An introduction to timing\n  diagrams. Hazards and hazard elimination. Other ways to implement\n  combinational logic.\n\n<p></p></li>\n<li><b>Introduction to practical classes.</b>  Prototyping\n  box. Breadboard and Dual in line (DIL) packages. Wiring. Use of\n  oscilloscope.\n\n<p></p></li>\n<li><b>Sequential logic.</b>  Memory elements. RS latch. Transparent\n  D latch.  Master-slave D flip-flop. T and JK flip-flops. Setup and\n  hold times.\n\n<p></p></li>\n<li><b>Sequential logic.</b>\nCounters: Ripple and synchronous. Shift registers.\n\n<p></p></li>\n<li><b>Synchronous State Machines.</b>  Moore and Mealy finite state\n  machines (FSMs). Reset and self starting. State transition diagrams.\n\n<p></p></li>\n<li><b>Further state machines.</b>  State assignment: sequential,\n  sliding, shift register, one hot. Implementation of FSMs.\n\n<p></p></li>\n<li><b>Circuits.</b>  Solving non-linear circuits. Potential\n  divider. N-channel MOSFET. N-MOS inverter. N-MOS logic. CMOS\n  logic. Logic families. Noise margin. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02024300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the relationships between combination logic\nand boolean algebra, and between sequential logic and finite state\nmachines;\n\n<p></p></li>\n<li>be able to design and minimise combinational logic;\n\n<p></p></li>\n<li>appreciate tradeoffs in complexity and speed of combinational\ndesigns;\n\n<p></p></li>\n<li>understand how state can be stored in a digital logic\ncircuit;\n\n<p></p></li>\n<li>know how to design a simple finite state machine from a specification\nand be able to implement this in gates and edge triggered flip-flops;\n\n<p></p></li>\n<li>understand how to use MOS transistors.\n\n<p></p></li>\n\n\n<a name=\"SECTION02024400000000000000\">Recommended reading</a>\n\n* Harris, D.M. &amp; Harris, S.L. (2007). Digital design and computer architecture. Morgan Kaufmann.\n<br/>Katz, R.H. (2004). <em>Contemporary logic design</em>. Benjamin/Cummings.  The 1994 edition is more than sufficient.\n<br/>Hayes, J.P. (1993). <em>Introduction to digital logic design</em>. Addison-Wesley.\n\nBooks for reference:\n\nHorowitz, P. &amp; Hill, W. (1989). <em>The art of electronics</em>.  Cambridge University Press (2nd\u00a0ed.) (more analog).\n<br/>Weste, N.H.E. &amp; Harris, D. (2005). <em>CMOS VLSI Design - a circuits and systems perspective</em>. Addison-Wesley (3rd ed.).\n<br/>Mead, C. &amp; Conway, L. (1980). <em>Introduction to VLSI systems</em>.  Addison-Wesley.\n<br/>Crowe, J. &amp; Hayes-Gill, B. (1998). <em>Introduction to digital electronics</em>. Butterworth-Heinemann.\n<br/>Gibson, J.R. (1992). <em>Electronic logic circuits</em>. Butterworth-Heinemann.\n\n\n", "course_name": "Digital Electronics", "course_code": "DigElec", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/DigElec", "lecturers": ["ijw24"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "DiscMathI": {"supervisions": null, "lectures": 9, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematicsI.html", "description": "\n\n\n<a name=\"SECTION02023100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02023200000000000000\">Lectures</a>\n\n\n<li><b>Logic.</b>\nPropositional and predicate logic formulas and their relationship to\ninformal reasoning, truth tables, validity.\n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Proof.</b>\nProving propositional and predicate formulas in a structured way.\nIntroduction and elimination rules.\n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Sets.</b>\nBasic set theory. Relations, graphs, and orders. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Induction.</b>\nProof by induction, including proofs about total functional\nprograms over natural numbers and lists. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02023300000000000000\">Objectives</a>\n\nOn completing the course, students should be able to\n\n\n<li>write a clear statement of a problem as a theorem in\n  mathematical notation;\n\n<p></p></li>\n<li>prove and disprove assertions using a variety\n  of techniques.\n\n<p></p></li>\n\n\n<a name=\"SECTION02023400000000000000\">Recommended reading</a>\n\n* Velleman, D.J. (1994). <em>How to prove it (a structured approach).</em> Cambridge University Press.\n<br/>* Rosen, K.H. (1999). <em>Discrete mathematics and its applications</em>. McGraw-Hill (6th ed.).\n<br/>Biggs, N.L. (1989). <em>Discrete mathematics.</em> Oxford University Press.\n<br/>Bornat, R. (2005). <em>Proof and disproof in formal logic.</em> Oxford University Press.\n<br/>Devlin, K. (2003). <em>Sets, functions, and logic: an introduction to abstract mathematics.</em> Chapman and Hall/CRC Mathematics (3rd ed.).\n<br/>Mattson, H.F. Jr (1993). <em>Discrete mathematics.</em> Wiley.\n<br/>Nissanke, N. (1999). <em>Introductory logic and sets for computer scientists.</em> Addison-Wesley.\n<br/>P\u00f3lya, G. (1980). <em>How to solve it.</em> Penguin.\n<br/>\n", "course_name": "Discrete Mathematics\u00a0I", "course_code": "DiscMathI", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/DiscMathI", "lecturers": ["ss368"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "FoundsCS": {"supervisions": 6, "lectures": 15, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-FoundationsofComputerScience.html", "description": "\n\n\n<a name=\"SECTION02022100000000000000\">Aims</a>\n\nA further aim is to introduce the principles of data structures and\nalgorithms.  The course will emphasise the algorithmic side of programming,\nfocusing on problem-solving rather than on hardware-level bits and bytes.\nAccordingly it will present basic algorithms for sorting, searching, etc., and\ndiscuss their efficiency using O-notation.  Worked examples (such as\npolynomial arithmetic) will demonstrate how algorithmic ideas can be used to\nbuild efficient applications.\n\nThe course will use a functional language (ML).  ML is particularly\nappropriate for inexperienced programmers, since a faulty program\ncannot crash.  The course will present the elements of functional\nprogramming, such as curried and higher-order functions. But it will\nalso discuss traditional (procedural) programming, such as\nassignments, arrays, pointers and mutable data structures.\n\n\n<a name=\"SECTION02022200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>\nLevels of abstraction.  Floating-point numbers, and why von Neumann\nwas wrong.  Why ML?  Integer arithmetic.  Giving names to values.\nDeclaring functions.  Static binding, or declaration <em>versus</em>\nassignment.\n\n<p></p></li>\n<li><b>Recursive functions.</b>\nExamples: Exponentiation and summing integers.  Overloading.\nDecisions and booleans.  Iteration <em>versus</em> recursion.\n\n<p></p></li>\n<li><b>O Notation.</b>\nExamples of growth rates.  Dominance.  O, Omega and Theta.  The costs\nof some sample functions.  Solving recurrence equations.\n\n<p></p></li>\n<li><b>Lists.</b>\nBasic list operations.  Append.  Na\u00efve <em>versus</em> efficient\nfunctions for length and reverse.  Strings.\n\n<p></p></li>\n<li><b>More on lists.</b>\nThe utilities <tt>take</tt> and <tt>drop</tt>.\nPattern-matching: zip, unzip.  A word on polymorphism.  The \u201cmaking change\u201d\nexample.\n\n<p></p></li>\n<li><b>Sorting.</b>\nA random number generator.  Insertion sort, mergesort, quicksort.\nTheir efficiency.\n\n<p></p></li>\n<li><b>Datatypes and trees.</b>\nPattern-matching and case expressions.  Exceptions.  Binary tree\ntraversal (conversion to lists): preorder, inorder, postorder.\n\n<p></p></li>\n<li><b>Dictionaries and functional arrays.</b>\nFunctional arrays.  Dictionaries: association lists (slow) <i>versus</i> binary search trees.  Problems with unbalanced trees.\n\n<p></p></li>\n<li><b>Queues and search strategies.</b>\nDepth-first search and its limitations.  Breadth-first search (BFS).\nImplementing BFS using lists.  An efficient representation of queues.\nImportance of efficient data representation.\n\n<p></p></li>\n<li><b>Functions as values.</b>\nNameless functions.  Currying.\n\n<p></p></li>\n<li><b>List functionals.</b>\nThe \u201capply to all\u201d functional, map.  Examples: matrix transpose and\nproduct.  The \u201cfold\u201d functionals.  Predicate functionals \u201cfilter\u201d\nand \u201cexists\u201d.\n\n<p></p></li>\n<li><b>Polynomial arithmetic.</b>\nAddition, multiplication of polynomials using ideas from sorting,\netc.\n\n<p></p></li>\n<li><b>Sequences, or lazy lists.</b>\nNon-strict functions such as <em>IF</em>.  Call-by-need <em>versus</em>\ncall-by-name.  Lazy lists.  Their implementation in ML.\nApplications, for example Newton-Raphson square roots.\n\n<p></p></li>\n<li><b>Elements of procedural programming.</b>\nAddress <em>versus</em> contents.  Assignment <em>versus</em> binding.\nOwn variables.  Arrays, mutable or not.\n\n<p></p></li>\n<li><b>Linked data structures.</b>\nLinked lists.  Surgical concatenation, reverse, etc.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022300000000000000\">Objectives</a>\n\nAt the end of the course, students should\n\n\n<li>be able to write simple ML programs;\n\n<p></p></li>\n<li>understand the importance of abstraction in computing;\n\n<p></p></li>\n<li>be able to estimate the efficiency of simple algorithms, using the \nnotions of average-case, worse-case and amortised costs;\n\n<p></p></li>\n<li>know the comparative advantages of insertion sort, quick sort and merge \nsort;\n\n<p></p></li>\n<li>understand binary search and binary search trees;\n\n<p></p></li>\n<li>know how to use currying and higher-order functions.\n\n<p></p></li>\n\n\n<a name=\"SECTION02022400000000000000\">Recommended reading</a>\n\n* Paulson, L.C. (1996). <em>ML for the working programmer</em>. Cambridge University Press (2nd\u00a0ed.).\n<br/>Okasaki, C. (1998). <em>Purely functional data structures</em>. Cambridge University Press.\n\nGentler alternative to the main text:\n<br/>Hansen, M. &amp; Rischel, H. (1999). <em>Introduction to programming using SML</em>. Addison-Wesley.\n\nFor reference only:\n<br/>Gansner, E.R. &amp; Reppy, J.H. (2004). <em>The Standard ML Basis Library</em>. Cambridge University Press. ISBN: 0521794781\n\n\n", "course_name": "Foundations of Computer Science", "course_code": "FoundsCS", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/FoundsCS", "lecturers": ["lp15"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Hardware": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n<li><a href=\"Introduction_2011.pdf\">Introduction</a>\n</li><li><a href=\"Workshop1_2011.pdf\">Workshop One</a> - Electronic Die\n</li><li><a href=\"Workshop2_2011.pdf\">Workshop Two</a> - Shaft Position Encoder\n</li><li><a href=\"Workshop3_2011.pdf\">Workshop Three</a> - Debouncing a Switch\n</li><li><a href=\"Workshop4_2011.pdf\">Workshop Four</a> - Framestore for an LED Array\n</li><li><a href=\"Workshop5_2011.pdf\">Workshop Five</a> - nMOS, pMOS and CMOS Inverters\n</li><li><a href=\"Workshop6_2011.pdf\">Workshop Six</a> - Digital-to-Analogue Conversion\n</li>\n", "course_name": "Hardware Practical Classes", "course_code": "Hardware", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Hardware", "lecturers": ["ijw24"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": true, "easter": false}, "MLuWindows": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<li><a href=\"w01hando.pdf\">Week 1 handout</a>\n</li><li><a href=\"w02hando.pdf\">Week 2 handout</a>\n</li><li><a href=\"../FoundsCS/ticks.pdf\">Exercises for ticks 1\u20135</a>\n</li><li><a href=\"../FoundsCS/tick6.pdf\">Exercise tick 6</a>\n</li>\n", "course_name": "ML under Windows", "course_code": "MLuWindows", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/MLuWindows", "lecturers": ["fhk1"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "OpSystems": {"supervisions": null, "lectures": 13, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-OperatingSystems.html", "description": "\n\n\n<a name=\"SECTION02025100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02025200000000000000\">Lectures</a>\n\n<li><b>Introduction to operating systems.</b>  Abstract view of an\n  operating system. OS evolution: multi-programming, time-sharing.\n  Dual-mode operation. Protecting I/O, memory, CPU.  Kernels and\n  micro-kernels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Processes and scheduling.</b>\n  Job/process concepts. Scheduling basics: CPU-I/O interleaving, (non-)preemption, context\n  switching. Scheduling algorithms: FCFS, SJF, SRTF, priority\n  scheduling, round robin. Combined schemes. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Memory management.</b>  Processes in memory. Logical\n  addresses. Partitions: static <em>versus</em> dynamic, free space\n  management, external fragmentation. Segmented memory.  Paged memory:\n  concepts, internal fragmentation, page tables.  Demand\n  paging/segmentation. Replacement strategies: OPT, FIFO, LRU (and\n  approximations), NRU, LFU/MFU, MRU.  Working set schemes. [3\u00a0lectures]\n\n<p></p></li>\n<li><b>I/O subsystem.</b>  General structure. Polled mode <em>    versus</em> interrupt-driven I/O.  Application I/O interface: block\n  and character devices, buffering, blocking <em>versus</em> non-blocking\n  I/O. Other issues: caching, scheduling, spooling, performance.\n  [1\u00a0lecture]\n\n<p></p></li>\n<li><b>File management.</b>  File concept. Directory and storage\n  services. File names and meta-data. Directory name-space:\n  hierarchies, DAGs, hard and soft links. File operations. Access\n  control.  Existence and concurrency control. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Protection.</b> Requirements. Subjects and objects. Design\n  principles. Authentication schemes. Access matrix: ACLs and\n  capabilities. Combined scheme.  Covert channels. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Unix case study.</b>  History. General structure. Unix file\n  system: file abstraction, directories, mount points, implementation\n  details.  Processes: memory image, life cycle, start of day.  The\n  shell: basic operation, commands, standard I/O, redirection, pipes,\n  signals. Character and block I/O.  Process scheduling. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Windows NT case study.</b>  History. Design principles.\n  Overall architecture. HAL.  Kernel: objects, processes, threads,\n  scheduling.  Executive: object manager and object namespace, process\n  manager, VM manager, I/O manager. File-System. Security\n  System. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02025300000000000000\">Objectives</a>\n\nAt the end of the course students should be able to\n\n\n<li>describe the general structure and purpose of an operating\n  system; \n\n<p></p></li>\n<li>explain the concepts of process, address space, and file;\n\n<p></p></li>\n<li>compare and contrast various CPU scheduling algorithms;\n\n<p></p></li>\n<li>understand the differences between segmented and paged memories,\n  and be able to describe the advantages and disadvantages of each;\n\n<p></p></li>\n<li>compare and contrast polled, interrupt-driven and DMA-based\n  access to I/O devices.\n\n<p></p></li>\n\n\n<a name=\"SECTION02025400000000000000\">Recommended reading</a>\n\n* Bacon, J. &amp; Harris, T. (2003). <em>Operating systems</em>.  Addison-Wesley (3rd ed.).\n<br/>Silberschatz, A., Peterson, J.L. &amp; Galvin, P.C. (2008). <i>Operating systems concepts</i>. Wiley (8th ed.).\n<br/>Leffler, S. (1989). <em>The design and implementation of the 4.3BSD Unix operating system</em>. Addison-Wesley.\n<br/>Solomon, D. &amp; Russinovich, M. (2000). <em>Inside Windows 2000</em>. Microsoft Press (3rd ed.).\n\n\n", "course_name": "Operating Systems", "course_code": "OpSystems", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/OpSystems", "lecturers": ["iml1"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "Registratn": {"supervisions": null, "lectures": null, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n<li><a href=\"registration-slides.pdf\">presentation slides</a> (<a href=\"registration-handout.pdf\">handout version</a>)\n\n</li><li><a href=\"../CST.pdf\">syllabus booklet</a>\n</li><li><a href=\"../../timetables/PartIACST.pdf\">timetable</a>\n</li><li><a href=\"../../timetables/portrait.pdf\">concise lecture list\nsummary</a> and\nan <a href=\"../../timetables/sfcst.html\">explanation</a> to help you\ndecode it\n\n</li><li><a href=\"../FoundsCS/ticks.pdf\">ML exercise sheets (ticks 1\u20135)</a>\n</li>\n", "course_name": "Registration", "course_code": "Registratn", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Registratn", "lecturers": ["mgk25"], "year": "1112", "tripos_part": "1a", "michaelmas": true, "lent": false, "easter": false}, "AlgorithI": {"supervisions": null, "lectures": 15, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-AlgorithmsI.html", "description": "\n\n\n<a name=\"SECTION02034100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02034200000000000000\">Lectures</a>\n\n<li><b>Sorting.</b>\nReview of complexity, O-notation, insertion sort, merge sort and \nquicksort. Understanding the memory behaviour of these algorithms with \nstatically allocated arrays. Heapsort. Other sorting methods including \nsorting in linear time. Median and order statistics.\n[Ref: Cormen <span class=\"textit\">et al.</span> Ch 1, 2, 3, 4, 6, 7, 8, 9] [about 4.5 lectures]\n\n<p></p></li>\n<li><b>Strategies for algorithm design.</b>\nDynamic programming, divide and conquer, greedy algorithms and other \nuseful paradigms.\n[Ref: Ch 4, 15, 16] [about 3.5 lectures]\n\n<p></p></li>\n<li><b>String matching.</b>\nNaive strategy. Rabin-Karp. Finite automata.\n[Ref: Ch 32] [about 1 lecture]\n\n<p></p></li>\n<li><b>Data structures.</b>\nAbstract data types. Pointers, stacks, queues, lists, trees. Binary \nsearch trees. Red-black trees. B-trees. Hash tables. Priority queues and \nheaps.\n[Ref: Ch 6, 10, 11, 12, 13, 18] [about 6 lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02034300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>have a good understanding of how several fundamental\nalgorithms work, particularly those concerned with sorting and searching;\n\n<p></p></li>\n<li>have a good understanding of the fundamental data structures\n  used in computer science;\n\n<p></p></li>\n<li>be able to analyse the space and time efficiency of most\n  algorithms;\n\n<p></p></li>\n<li>be able to design new algorithms or modify existing ones for new\n  applications and reason about the efficiency of the result.\n\n<p></p></li>\n\n\n<a name=\"SECTION02034400000000000000\">Recommended reading</a>\n\n* Cormen, T.H., Leiserson, C.D., Rivest, R.L. &amp; Stein, C. (2009). <em>Introduction to Algorithms</em>. MIT Press (3rd ed.). ISBN 978-0262533058\n<br/>Sedgewick, R. &amp; Wayne, K. (2011). <em>Algorithms</em>. Addison-Wesley (4th ed.). ISBN 978-0321573513.\n<br/>Kleinberg, J. &amp; Tardos, \u00c9. (2006). <em>Algorithm design</em>. Addison-Wesley. ISBN 9780321372918.\n<br/>Knuth, D.E. (2011). <em>The art of computer programming</em>. Addison-Wesley (3rd ed.).  ISBN 978-0321751041.\n\nStudents are expected to buy, make extensive use of, and keep as\nreference for their future career, one of the above textbooks: those\nnot doing so will be severely disadvantaged. The recommended choice is\nCormen <span class=\"textit\">et al</span>. which, in spite of its superb quality, covers the\nwhole syllabus and is one of the cheapest (about 35 GBP new for over\n1300 pages). The other textbooks may not cover the whole syllabus but\nare all excellent resources; their relative merits are discussed in\nthe course handout.\n\n\n", "course_name": "Algorithms\u00a0I", "course_code": "AlgorithI", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/AlgorithI", "lecturers": ["fms27"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": true}, "DiscMathII": {"supervisions": null, "lectures": 12, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-DiscreteMathematicsII.html", "description": "\n\n\n<a name=\"SECTION02036100000000000000\">Aims</a>\n\n\n<br/>\n<a name=\"SECTION02036200000000000000\">Lectures</a>\n\n<br/>\n\n<li><b>Sets and logic.</b> \nThe basic set operations (union,  intersection and complement) on subsets of \na fixed set.  The Boolean laws.  Propositional logic and its models.\nValidity, entailment, and equivalence of  propositions revisited.\nStructural induction illustrated on propositions. \n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Relations and functions.</b>\nProduct of sets. Relations, functions and partial functions.\nComposition and identity relations. \nInjective, surjective and bijective functions. Direct and inverse image of \na set under a relation. Equivalence relations and partitions;\nmodular arithmetic as an example.\nDirected graphs and partial orders.\nSize of sets (cardinality), especially countability. Cantor\u2019s \ndiagonal argument to show the reals are uncountable. \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Constructions on sets.</b> Russell\u2019s paradox. \nBasic sets, comprehension, indexed sets, unions, intersections, products,\ndisjoint unions, powersets. Characteristic functions. Sets of functions.\n Lambda notation for functions. Cantor\u2019s diagonal argument to \nshow power set strictly increases size.\n[2\u00a0lectures]\n\n<p></p></li>\n<li><b>Introduction to inductive definitions.</b>\nUsing rules to define sets; examples.\nReasoning principles: rule induction and its instances;\ninduction on derivations briefly. Simple applications, including transitive closure of a relation.  \n[3\u00a0lectures]\n\n<p></p></li>\n<li><b>Well-founded induction.</b>\nWell-founded relations and well-founded induction.\nOther induction principles as  instances of well-founded induction.\nProduct and lexicographic product of well-founded relations.\nExamples and applications, including to Euclid\u2019s algorithm for HCF/GCD.\nInformal understanding of definition by well-founded recursion. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02036300000000000000\">Objectives</a>\n\n<br/>\nOn completing this part of the course, students should be able to\n\n\n<li>understand and use the language of set theory; prove and\n  disprove assertions using a variety of techniques;\n\n<p></p></li>\n<li>understand Boolean operations as operations on sets and\n  formulate statements using Boolean logic;\n\n<p></p></li>\n<li>apply the principle of well-founded induction;\n\n<p></p></li>\n<li>define sets inductively using rules, and prove properties about \nthem.\n\n<p></p></li>\n\n\n<a name=\"SECTION02036400000000000000\">Recommended reading</a>\n\n<br/>\nComprehensive notes will be provided.  \n\n\n<br/>\nDevlin, K. (2003). <em>Sets, functions, and logic: an introduction to abstract mathematics</em>. Chapman and Hall/CRC Mathematics (3rd ed.).\n<br/>Biggs, N.L. (1989). <em>Discrete mathematics</em>. Oxford University Press.\n<br/>Mattson, H.F. Jr (1993). <em>Discrete mathematics</em>.  Wiley.\n<br/>Nissanke, N. (1999). <em>Introductory logic and sets for computer scientists</em>. Addison-Wesley.\n<br/>P\u00f3lya, G. (1980). <em>How to solve it</em>. Penguin.\n<br/>\n", "course_name": "Discrete Mathematics\u00a0II", "course_code": "DiscMathII", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/DiscMathII", "lecturers": ["gw104"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "FPComp": {"supervisions": null, "lectures": 6, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Floating-PointComputation.html", "description": "\n\n\n<a name=\"SECTION02033100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02033200000000000000\">Lectures</a>\n\n<li><b>Integer and floating-point representation and arithmetic.</b>\nSigned and unsigned integers and fixed-point; arithmetic, saturating arithmetic.\nIEEE 754/854 floating point (32 and 64 bit); zeros, infinities, NaN.\nBrief mention of IEEE 754r.\nWhat numbers are exactly representable in bases 2 and 10.\nAccuracy in terms of significant figures.\nFloating point arithmetic is non-associative, and mathematical equivalences\nfail.\nNonsensical results, e.g. <tt>sin(1e40)</tt>, counting in floating point.\n\n<p></p></li>\n<li><b>IEEE Floating-point arithmetic.</b>\nFloating point arithmetic, and the IEEE requirements.\nWhy the IEEE standard has endured.\nOverflow, underflow, progressive loss of significance.\n      Rounding modes.\nDifficulty in obtaining IEEE-quality in libraries.\nThe java.lang.Math trigonometric library promises.\n\n<p></p></li>\n<li><b>How floating-point computations diverge from real-number calculations.</b>\nAbsolute Error, Relative Error, Machine epsilon, Unit in Last Place (ulp).\nFinite computation: solving a quadratic.\nSumming a finite series.\nRounding (round-off) and truncation (discretisation) error.\nNumerical differentiation; determining a good step size.\n\n<p></p></li>\n<li><b>Iteration and when to stop.</b>\nUnbounded computation may produce unbounded errors.\nSolving equations by iteration and comparison to terminate it.\nNewton\u2019s method.\nIdea of order of convergence.\nWhy summing a Taylor series is problematic (loss of all precision,\n      range reduction, non-examinable hint at economisation).\n\n<p></p></li>\n<li><b>Ill-conditioned or chaotic problems.</b>\nEffect of changes of a few ulp in the inputs.\nConditioning number when amenable to mathematical analysis;\nMonte-Carlo exploration when not.\n\n<p></p></li>\n<li><b>Other approaches and their problems</b>\nAdaptive methods.\nArbitrary precision floating point, adaptive floating point, interval\narithmetic.\nDiscussion on the problems of exact real arithmetic.\nRemark on the x86 implementations of IEEE arithmetic, and compiler\n\u201coptimisations\u201d.\n\n<p></p></li>\n\n\n<a name=\"SECTION02033300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to convert simple decimal numbers to and from IEEE\n  floating-point format, and to perform IEEE arithmetic on them;\n\n<p></p></li>\n<li>be able to identify problems with floating-point implementations of\n      simple mathematical problems;\n\n<p></p></li>\n<li>know when a problem is likely to yield incorrect solutions no\n      matter how it is processed numerically;\n\n<p></p></li>\n<li>know to use a professionally-written package whenever possible\n      (and still to treat claims of accuracy with suspicion).\n\n<p></p></li>\n\n\n<a name=\"SECTION02033400000000000000\">Recommended reading</a>\n\nOverton, M.L. (2001). <em>Numerical computing with IEEE floating point arithmetic</em>. SIAM.\n\nFurther reading - goes far beyond the course\n\nGoldberg, D. (1991). <em>What every computer scientist should know about floating-point arithmetic</em>. ACM Computing Surveys, vol. 23, pp. 5-48.\n\n\n", "course_name": "Floating-Point Computation", "course_code": "FPComp", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/FPComp", "lecturers": ["djg11"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "OOProg": {"supervisions": 2, "lectures": 9, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-ProgrammingMethodsandJava.html", "description": "\n\n\n<a name=\"SECTION02032100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02032200000000000000\">Syllabus</a>\n\n\n<li><b>Hardware Refresher.</b> Fetch-execute cycle. Registers. System\n  Architectures. Imperative languages as closer to the hardware. The\n  JVM idea. [1/2\u00a0lecture]\n\n<p></p></li>\n<li><b>Programmer\u2019s Model of Memory.</b> Primitive\n  Types. Pointers. References. Pass-by-value and\n  pass-by-reference. Reference Types. [1/2\u00a0lecture] \n\n<p></p></li>\n<li><b>OOP Concepts.</b>  Objects vs classes. Identifying\n  objects. Distinguishing state and behaviour. UML class\n  diagrams. Modularity. Encapsulation. Inheritance. Casting. Polymorphism. Abstract\n  Classes. Multiple inheritance. Java interfaces. Representing\n  class-level data. Exceptions in brief. [3\u00a0lecture]\n\n<p></p></li>\n<li><b>Lifecycle of an Object.</b> Constructors. Destructors. Garbage\n  Collection. [1/2\u00a0lecture]\n\n<p></p></li>\n<li><b>Copying Objects.</b> Copy constructors. Cloning in\n  Java. Cloneable as a marker interface in Java. [1/2\u00a0lecture]\n\n<p></p></li>\n<li><b>Comparing Objects.</b> Comparing primitive types. Comparing\n  reference types. Comparable and Comparator in Java. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Templates and Generics.</b> Java Collections framework as\n  motivation. Examples of generic programming. [1\u00a0lecture]\n\n<p></p></li>\n<li><b>Design patterns and design examples.</b> Introduction to design\n  patterns. Applying design patterns to example problems. Design\n  patterns in the Java class library. Examples of building a Java\n  program from problem statement to testing. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Common Java errors.</b>\nThe need for care with syntax. Numerical overflow and other common\nproblems. [if time allows]\n\n<p></p></li>\n\n\n<a name=\"SECTION02032300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>understand the principles of OOP;\n\n<p></p></li>\n<li>be able to demonstrate good object-oriented programming skills\n    in Java;\n\n<p></p></li>\n<li>understand the capabilities and limitations of Java;\n\n<p></p></li>\n<li>be able to describe, recognise, apply and implement selected design\n    patterns in Java;\n\n<p></p></li>\n<li>be familiar with common errors in Java and its associated\n  libraries.\n\n<p></p></li>\n\n\n<a name=\"SECTION02032400000000000000\">Recommended reading</a>\n\nNo single text book covers all of the topics in this course. For those\nnew to OOP, the best introductions are usually found in the\nintroductory programming texts for OOP languages (such as Java, python\nor C++).  Look for those that are for people new to programming rather\nthan those that are designed for programmers transitioning between\nlanguages (the Deitel book is highlighted for this reason).  The web\nis also a very useful resource -- look for Java tutorials.\n\n* Deitel, H.M. &amp; Deitel, P.J. (2009). <em>Java: How to Program</em>. Prentice Hall (8th ed.).\n<br/>Flanagan, D. (2005). <em>Java in a nutshell : a desktop quick reference</em>. O\u2019Reilly (5th ed.).\n<br/>Flanagan, D. (2004). <em>Java examples in a nutshell : a tutorial companion to Java in a nutshell</em>. O\u2019Reilly (3rd ed.).\n<br/>Gamma, E., Helm, R., Johnson, R. &amp; Vlissides, A. (1995). <em>Design patterns: elements of reusable object-oriented software</em>. Addison-Wesley.\n<br/>Bloch, J. &amp; Gafter, N. (2005). <em>Java puzzlers</em>. Addison-Wesley.\n\n\n", "course_name": "Object-Oriented Programming", "course_code": "OOProg", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/OOProg", "lecturers": ["rkh23"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "Probabilty": {"supervisions": null, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-Probability.html", "description": "\n\n\n<a name=\"SECTION02035100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02035200000000000000\">Lectures</a>\n\n\n<li><b>Review of elementary probability theory.</b> Random\n  variables. Discrete and continuous distributions. Means and\n  variances, moments, independence, conditional probabilities. \n  Bayes\u2019s theorem. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Probability generating functions.</b> Definitions and\n  properties. Use in calculating moments of random variables and for\n  finding the distribution of sums of independent random\n  variables. [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Multivariate distributions and independence.</b> Random vectors\n  and independence. Joint and marginal density functions. Variance,\n  covariance and correlation. Conditional density functions.\n  [2\u00a0lectures]\n\n<p></p></li>\n<li><b>Elementary stochastic processes.</b> Random walks. Recurrence\n  and transience. The Gambler\u2019s Ruin problem. Solution using\n  difference equations. [2\u00a0lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02035300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>have a thorough understanding of concepts in probability theory and \n  a practical knowledge of associated calculations;\n\n<p></p></li>\n<li>be aware of applications of probability across the field of\n  computer science.\n\n<p></p></li>\n\n\n<a name=\"SECTION02035400000000000000\">Recommended reading</a>\n\n* Grimmett, G. &amp; Welsh, D. (1986). <em>Probability: an introduction</em>. Oxford University Press.\n\n\n", "course_name": "Probability", "course_code": "Probabilty", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/Probabilty", "lecturers": ["rg31"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "ProgJava": {"supervisions": 0, "lectures": 0, "prerequisite_for": [], "past_exam_questions": null, "description": null, "course_name": "Programming in Java", "course_code": "ProgJava", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/ProgJava", "lecturers": ["arb33", "acr31"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": false}, "SWDesign": {"supervisions": null, "lectures": 7, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-SoftwareDesign.html", "description": "\n\n\n<a name=\"SECTION02037100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02037200000000000000\">Lectures</a>\n\n<li><b>Introduction.</b>  Dealing with uncertainty in design, and the\n  need for a knowledge-based modeling process. Overview of the design\n  process, with reference to the terminology of the UML Rational\n  Unified Process (Inception phase, Elaboration phase, Construction\n  phase, Transition phase).\n<p></p></li>\n<li><b>Inception phase.</b>  Structured description of system usage\n  and function, requirements capture techniques, identification of\n  scenarios and UML use case diagrams. Description of scenario\n  elements in terms of CRC models - classes, responsibilities and\n  collaborators.\n<p></p></li>\n<li><b>Elaboration phase.</b> Systematic definition of classes, data\n  and system structure. Abstraction, modularisation and UML class\n  diagrams.  Combining top-down refinement with bottom-up\n  construction.\n<p></p></li>\n<li><b>Construction phase (1).</b> Object interaction, behaviour and state.  \nDifferent varieties of UML interaction diagram. Recognising coupling  \nbetween modules and responsibility-driven design. Structuring source  \ncode as a design model. Recognition of variable roles.\n\n<p></p></li>\n<li><b>Construction phase (2).</b> Data lifecycles and constraints, expressed\nusing UML statecharts and Z notation. Defensive programming methods\nincluding recognition of pre- and post-conditions, invariants,\ncomposition and assertions. Library components and\ndocumentation.\n<p></p></li>\n<li><b>Transition phase.</b> Rapid and agile prototyping strategies and  \niteration. Quality, testing and evaluation strategies, optimisation  \nand debugging techniques.\n<p></p></li>\n\n\n<a name=\"SECTION02037300000000000000\">Objectives</a>\n\nAt the end of the course, students should be able to undertake system\ndesign in a methodical manner, starting from a statement of system\nrequirements, developing a modular design model, refining it into an\nimplementation that clearly identifies and minimises risk, coding in a\nmanner that can be integrated with the work of a team, and using\nappropriate methods to identify and prevent faults.\n\n\n<a name=\"SECTION02037400000000000000\">Recommended reading</a>\n\nMcConnell, S. (2004). <i>Code complete: a practical handbook of software construction</i>. Microsoft Press (2nd ed.).\n<br/>Fowler, M. (2003). <i>UML distilled</i>. Addison-Wesley (3rd ed.).\n\nRevision and reinforcement of object-oriented concepts for those needing this:\n\nBarnes, D.J. &amp; K\u00f6lling, M. (2006). <em>Objects first with Java: a practical introduction using BlueJ</em>. Pearson Education (3rd ed.).\n\nFurther reading\n\nBroy, M. &amp; Denert, E. (ed.) (2002). <i>Software pioneers: contributions to software engineering</i>. Springer-Verlag.\n<br/>Collins, H. &amp; Pinch, T. (1998). <i>The Golem at large: what you should know about technology</i>. Cambridge University Press.\n<br/>Petroski, H. (1985). <i>To engineer is human: the role of failure in successful design</i>. Macmillan.\n<br/>Vincenti, W.G. (1990). <i>What engineers know and how they know it: analytical studies from aeronautical history</i>. Johns Hopkins University Press.\n<br/>Simon, H.A. (1996). <i>The sciences of the artificial</i>. MIT Press.\n<br/>Schon, D.A. (1990). <i>Educating the reflective practitioner</i>. Jossey-Bass.\n<br/>Pressman, R.S. (2010). <i>Software engineering</i>. McGraw-Hill (7th international ed.). ISBN 9780073375977\n<br/>\n", "course_name": "Software Design", "course_code": "SWDesign", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/SWDesign", "lecturers": ["cm542"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": true, "easter": true}, "FJavaBrfg": {"supervisions": null, "lectures": 1, "prerequisite_for": [], "past_exam_questions": null, "description": "\n\n\n<a name=\"SECTION02042100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02042200000000000000\">Lecture</a>\n\nThe lecture describes the requirements for the first assessed\nexercise of the Part\u00a0IB Further Java course.\n\n\n<a name=\"SECTION02042300000000000000\">Objectives</a>\n\nOn completing the exercise students should\n\n\n<li>be prepared for the Part\u00a0IB Further Java course;\n\n<p></p></li>\n<li>have developed their practical Java programming skills further.\n\n<p></p></li>\n\n\n\n", "course_name": "Further Java Briefing", "course_code": "FJavaBrfg", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/FJavaBrfg", "lecturers": ["arb33"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}, "RLFA": {"supervisions": null, "lectures": 8, "prerequisite_for": [], "past_exam_questions": "http://www.cl.cam.ac.uk/teaching/exams/pastpapers/t-RegularLanguagesandFiniteAutomata.html", "description": "\n\n\n<a name=\"SECTION02041100000000000000\">Aims</a>\n\n\n<a name=\"SECTION02041200000000000000\">Lectures</a>\n\n<li><b>Regular expressions.</b>\nSpecifying sets of strings by pattern-matching. [1 lecture]\n\n<p></p></li>\n<li><b>Finite state machines.</b>  Deterministic and\n  non-deterministic finite automata and the languages\n  they accept. [1 lecture]\n\n<p></p></li>\n<li><b>Regular languages.</b>  The language determined by a regular\n  expression is regular and every regular language is determined by\n  some regular expression. [2 lectures]\n\n<p></p></li>\n<li><b>The Pumping Lemma.</b> Proof and applications. [1 lecture]\n\n<p></p></li>\n<li><b>Context-Free grammars.</b> Context-free grammars. Backus-Naur\n  form (BNF). Chomsky and Greibach normal forms. Regular grammars.\n  The class of regular languages coincides with the class of languages\n  generated by a regular grammar. [1 lecture]\n\n<p></p></li>\n<li><b>Pushdown automata.</b> Pushdown automata and the languages\n  they accept. A language is context-free if and only\n  if it is accepted by some pushdown automaton. Forward look to\n  Computation Theory. [2 lectures]\n\n<p></p></li>\n\n\n<a name=\"SECTION02041300000000000000\">Objectives</a>\n\nAt the end of the course students should\n\n\n<li>be able to explain how to convert between the three ways of\n  representing regular sets of strings introduced in the course; and\n  be able to carry out such conversions by hand for simple cases;\n\n<p></p></li>\n<li>be able to use the Pumping Lemma to prove that a given set of\n  strings is not a regular language;\n\n<p></p></li>\n<li>be able to design a pushdown automaton to accept strings for a\n  given context-free grammar.\n\n<p></p></li>\n\n\n<a name=\"SECTION02041400000000000000\">Recommended reading</a>\n\nHopcroft, J.E., Motwani, R. &amp; Ullman, J.D. (2001). <em>Introduction to automata theory, languages, and computation</em>. Addison-Wesley (2nd ed.).\n<br/>* Kozen, D.C. (1997). <em>Automata and computability</em>. Springer-Verlag.\n<br/>\n", "course_name": "Regular Languages and Finite Automata", "course_code": "RLFA", "course_url": "https://www.cl.cam.ac.uk/teaching/1112/RLFA", "lecturers": ["amp12"], "year": "1112", "tripos_part": "1a", "michaelmas": false, "lent": false, "easter": true}}